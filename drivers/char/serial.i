# 1 "drivers/char/serial.c"
# 1 "<built-in>"
#define __VERSION__ "3.2.3 with SiByte modifications"
#define __USER_LABEL_PREFIX__ 
#define __REGISTER_PREFIX__ 
#define __HAVE_BUILTIN_SETJMP__ 1
#define __WCHAR_TYPE__ int
#define __WINT_TYPE__ unsigned int
#define __STDC__ 1
# 1 "<command line>"
#define __GNUC__ 3
# 1 "<command line>"
#define __GNUC_MINOR__ 2
# 1 "<command line>"
#define __GNUC_PATCHLEVEL__ 3
# 1 "<command line>"
#define __GXX_ABI_VERSION 102
# 1 "<command line>"
#define MIPSEL 1
# 1 "<command line>"
#define _MIPSEL 1
# 1 "<command line>"
#define unix 1
# 1 "<command line>"
#define mips 1
# 1 "<command line>"
#define _mips 1
# 1 "<command line>"
#define R3000 1
# 1 "<command line>"
#define _R3000 1
# 1 "<command line>"
#define __gnu_linux__ 1
# 1 "<command line>"
#define linux 1
# 1 "<command line>"
#define __ELF__ 1
# 1 "<command line>"
#define __PIC__ 1
# 1 "<command line>"
#define __pic__ 1
# 1 "<command line>"
#define __MIPSEL__ 1
# 1 "<command line>"
#define _MIPSEL 1
# 1 "<command line>"
#define __unix__ 1
# 1 "<command line>"
#define __mips__ 1
# 1 "<command line>"
#define __mips__ 1
# 1 "<command line>"
#define __R3000__ 1
# 1 "<command line>"
#define _R3000 1
# 1 "<command line>"
#define __gnu_linux__ 1
# 1 "<command line>"
#define __linux__ 1
# 1 "<command line>"
#define __ELF__ 1
# 1 "<command line>"
#define __PIC__ 1
# 1 "<command line>"
#define __pic__ 1
# 1 "<command line>"
#define __MIPSEL 1
# 1 "<command line>"
#define __unix 1
# 1 "<command line>"
#define __mips 1
# 1 "<command line>"
#define __mips 1
# 1 "<command line>"
#define __R3000 1
# 1 "<command line>"
#define __linux 1
# 1 "<command line>"
#define __OPTIMIZE__ 1
# 1 "<command line>"
#define __STDC_HOSTED__ 1
# 1 "<command line>"
#define __LANGUAGE_C 1
# 1 "<command line>"
#define _LANGUAGE_C 1
# 1 "<command line>"
#define LANGUAGE_C 1
# 1 "<command line>"
#define __SIZE_TYPE__ unsigned int
# 1 "<command line>"
#define __PTRDIFF_TYPE__ int
# 1 "<command line>"
#undef __mips
# 1 "<command line>"
#define __mips 2
# 1 "<command line>"
#define __mips_fpr 32
# 1 "<command line>"
#define _MIPS_FPSET 32
# 1 "<command line>"
#define _MIPS_ISA _MIPS_ISA_MIPS2
# 1 "<command line>"
#define _MIPS_SIM _MIPS_SIM_ABI32
# 1 "<command line>"
#define _MIPS_SZINT 32
# 1 "<command line>"
#define _MIPS_SZLONG 32
# 1 "<command line>"
#define _MIPS_SZPTR 32
# 1 "<command line>"
#undef __PIC__
# 1 "<command line>"
#undef __pic__
# 1 "<command line>"
#define __KERNEL__ 1
# 1 "<command line>"
#define KBUILD_BASENAME serial
# 1 "drivers/char/serial.c"
# 67 "drivers/char/serial.c"
static char *serial_version = "5.05c";
static char *serial_revdate = "2001-07-08";
# 100 "drivers/char/serial.c"
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/config.h" 1

#define _LINUX_CONFIG_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h" 1



#define AUTOCONF_INCLUDED 
#define CONFIG_MIPS 1
#define CONFIG_MIPS32 1





#define CONFIG_EXPERIMENTAL 1




#define CONFIG_MODULES 1

#define CONFIG_KMOD 1
# 28 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_PCI 1
#define CONFIG_PCI_AUTO 1






#define CONFIG_LOONGSON_FIX_RANDOM_INSTRUCTION_FETCH_SIDE_EFFECT_TO_DEVICE 1
#define CONFIG_LOONGSON_VIDEO_ACCELERATED 1


#define CONFIG_DUMMY_KEYB 1
#define CONFIG_GODSON2F_BOARDS 1




#define CONFIG_GODSON2F_LS1A_GOLDING 1
# 114 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_RWSEM_GENERIC_SPINLOCK 1

#define CONFIG_BOARD_SCACHE 1
#define CONFIG_PCI 1
#define CONFIG_NEW_PCI 1
#define CONFIG_HAVE_STD_PC_SERIAL_PORT 1
#define CONFIG_NONCOHERENT_IO 1
#define CONFIG_NEW_TIME_C 1
#define CONFIG_ISA 1
#define CONFIG_RTC 1

#define CONFIG_NB_ICT_BONITO 1
#define CONFIG_ONCHIP_L2_CACHE 1
#define CONFIG_IRQ_CPU 1






#define CONFIG_CPU_GODSON2 1
# 154 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_PAGE_SIZE_16KB 1






#define CONFIG_ONCHIP_L2_CACHE 1





#define CONFIG_PAGE_SIZE_16KB 1
# 176 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_CPU_ADVANCED 1
#define CONFIG_CPU_HAS_LLSC 1




#define CONFIG_CPU_GODSON2E 1
#define CONFIG_CPU_HAS_SYNC 1




#define CONFIG_CPU_LITTLE_ENDIAN 1

#define CONFIG_DEBUG26 1
#define CONFIG_NET 1
#define CONFIG_PCI 1
#define CONFIG_PCI_NEW 1
#define CONFIG_PCI_AUTO 1
#define CONFIG_PCI_NAMES 1



#define CONFIG_HOTPLUG 1
# 216 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_SYSVIPC 1
#define CONFIG_BSD_PROCESS_ACCT 1
#define CONFIG_SYSCTL 1
#define CONFIG_KCORE_ELF 1


#define CONFIG_BINFMT_ELF 1




#define CONFIG_BINFMT_MISC 1
# 260 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_BLK_DEV_LOOP 1

#define CONFIG_BLK_DEV_RAM 1
#define CONFIG_BLK_DEV_RAM_SIZE (40960)

#define CONFIG_BLK_STATS 1
# 282 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_PACKET 1

#define CONFIG_NETLINK_DEV 1


#define CONFIG_UNIX 1
#define CONFIG_INET 1
#define CONFIG_IP_MULTICAST 1

#define CONFIG_IP_PNP 1
# 343 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_IDE 1




#define CONFIG_BLK_DEV_IDE 1



#define CONFIG_BLK_DEV_IDEDISK 1
#define CONFIG_IDEDISK_MULTI_MODE 1
#define CONFIG_IDEDISK_STROKE 1


#define CONFIG_BLK_DEV_IDECD 1



#define CONFIG_IDE_TASK_IOCTL 1



#define CONFIG_BLK_DEV_IDEPCI 1
#define CONFIG_BLK_DEV_GENERIC 1
#define CONFIG_IDEPCI_SHARE_IRQ 1
#define CONFIG_BLK_DEV_IDEDMA_PCI 1


#define CONFIG_IDEDMA_PCI_AUTO 1

#define CONFIG_BLK_DEV_IDEDMA 1
# 404 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_IDEDMA_AUTO 1
# 416 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_SCSI 1
#define CONFIG_BLK_DEV_SD 1
#define CONFIG_SD_EXTRA_DEVS (40)



#define CONFIG_CHR_DEV_SG 1
# 520 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_NETDEVICES 1
# 535 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_NET_ETHERNET 1
# 549 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_NET_PCI 1
# 572 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_8139TOO 1
# 650 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_INPUT 1
#define CONFIG_INPUT_KEYBDEV 1
#define CONFIG_INPUT_MOUSEDEV 1
#define CONFIG_INPUT_MOUSEDEV_SCREEN_X (1024)
#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y (768)

#define CONFIG_INPUT_EVDEV 1





#define CONFIG_VT 1
#define CONFIG_VT_CONSOLE 1
#define CONFIG_SERIAL 1
#define CONFIG_SERIAL_CONSOLE 1


#define CONFIG_UNIX98_PTYS 1
#define CONFIG_UNIX98_PTY_COUNT (256)
# 680 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_MOUSE 1
#define CONFIG_PSMOUSE 1
# 726 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_WATCHDOG 1
# 752 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_RTC 1
# 774 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_AUTOFS_FS 1
#define CONFIG_AUTOFS4_FS 1
# 787 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_EXT3_FS 1
#define CONFIG_JBD 1

#define CONFIG_FAT_FS 1


#define CONFIG_VFAT_FS 1





#define CONFIG_RAMFS 1
# 808 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_NTFS_FS 1


#define CONFIG_PROC_FS 1



#define CONFIG_DEVPTS_FS 1



#define CONFIG_EXT2_FS 1
# 836 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_NFS_FS 1
#define CONFIG_NFS_V3 1

#define CONFIG_ROOT_NFS 1
#define CONFIG_NFSD 1
#define CONFIG_NFSD_V3 1

#define CONFIG_SUNRPC 1
#define CONFIG_LOCKD 1
#define CONFIG_LOCKD_V4 1
# 861 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_PARTITION_ADVANCED 1





#define CONFIG_MSDOS_PARTITION 1
# 878 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_NLS 1




#define CONFIG_NLS_DEFAULT "iso8859-1"
# 899 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_NLS_CODEPAGE_936 1
# 936 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_FB 1
#define CONFIG_DUMMY_CONSOLE 1
# 956 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_FBCON_ADVANCED 1



#define CONFIG_FBCON_CFB8 1
#define CONFIG_FBCON_CFB16 1
#define CONFIG_FBCON_CFB24 1
#define CONFIG_FBCON_CFB32 1
# 974 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_FBCON_FONTS 1
#define CONFIG_FONT_8x8 1
#define CONFIG_FONT_8x16 1
# 991 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_USB 1

#define CONFIG_USB_DEVICEFS 1

#define CONFIG_USB_EHCI_HCD 1


#define CONFIG_USB_OHCI 1




#define CONFIG_USB_STORAGE 1
# 1015 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_USB_HID 1
#define CONFIG_USB_HIDINPUT 1
# 1058 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_CROSSCOMPILE 1

#define CONFIG_KGDB 1
#define CONFIG_GDB_CONSOLE 1
#define CONFIG_DEBUG_INFO 1


#define CONFIG_LOG_BUF_SHIFT (0)
# 1076 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/autoconf.h"
#define CONFIG_ZLIB_INFLATE 1
#define CONFIG_ZLIB_DEFLATE 1
# 5 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/config.h" 2
# 101 "drivers/char/serial.c" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/version.h" 1
#define UTS_RELEASE "2.4.37.11"
#define LINUX_VERSION_CODE 132133
#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
# 102 "drivers/char/serial.c" 2


#define CONFIG_SERIAL_NOPAUSE_IO 
#define SERIAL_DO_RESTART 
# 117 "drivers/char/serial.c"
#define ENABLE_SERIAL_PCI 

#define CONFIG_SERIAL_SHARE_IRQ 


#define CONFIG_SERIAL_MANY_PORTS 
# 166 "drivers/char/serial.c"
#define CONFIG_SERIAL_RSA 

#define RS_STROBE_TIME (10*HZ)
#define RS_ISR_PASS_LIMIT 256
# 179 "drivers/char/serial.c"
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/module.h" 1







#define _LINUX_MODULE_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/compiler.h" 1

#define __LINUX_COMPILER_H 
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/compiler.h"
#define likely(x) __builtin_expect((x),1)
#define unlikely(x) __builtin_expect((x),0)







#define __attribute_used__ __attribute__((__unused__))
# 31 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/compiler.h"
#define __attribute_const__ __attribute__((__const__))






#define inline __inline__ __attribute__((always_inline))
#define __inline__ __inline__ __attribute__((always_inline))
#define __inline __inline__ __attribute__((always_inline))
# 55 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/compiler.h"
#define __user 
#define __iomem 
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/module.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/spinlock.h" 1

#define __LINUX_SPINLOCK_H 



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h" 1
# 20 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
#define _ASM_SYSTEM_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/sgidefs.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/sgidefs.h"
#define __ASM_SGIDEFS_H 
# 29 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/sgidefs.h"
#define _MIPS_ISA_MIPS1 1
#define _MIPS_ISA_MIPS2 2
#define _MIPS_ISA_MIPS3 3
#define _MIPS_ISA_MIPS4 4
#define _MIPS_ISA_MIPS5 5
#define _MIPS_ISA_MIPS32 6
#define _MIPS_ISA_MIPS64 7




#define _MIPS_SIM_ABI32 1
#define _MIPS_SIM_NABI32 2
#define _MIPS_SIM_ABI64 3
# 24 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/kernel.h" 1

#define _LINUX_KERNEL_H 







# 1 "/toolchain/lib/gcc-lib/mipsel-linux/3.2.3/include/stdarg.h" 1 3
# 34 "/toolchain/lib/gcc-lib/mipsel-linux/3.2.3/include/stdarg.h" 3
#define _STDARG_H 
#define _ANSI_STDARG_H_ 






#define __GNUC_VA_LIST 
typedef __builtin_va_list __gnuc_va_list;
# 54 "/toolchain/lib/gcc-lib/mipsel-linux/3.2.3/include/stdarg.h" 3
#define va_start(v,l) __builtin_stdarg_start((v),l)
#define va_end __builtin_va_end
#define va_arg __builtin_va_arg

#define va_copy(d,s) __builtin_va_copy((d),(s))

#define __va_copy(d,s) __builtin_va_copy((d),(s))
# 110 "/toolchain/lib/gcc-lib/mipsel-linux/3.2.3/include/stdarg.h" 3
typedef __gnuc_va_list va_list;





#define _VA_LIST_ 


#define _VA_LIST 


#define _VA_LIST_DEFINED 


#define _VA_LIST_T_H 


#define __va_list__ 
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/kernel.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/linkage.h" 1

#define _LINUX_LINKAGE_H 






#define CPP_ASMLINKAGE 







#define asmlinkage CPP_ASMLINKAGE


#define SYMBOL_NAME_STR(X) #X
#define SYMBOL_NAME(X) X

#define SYMBOL_NAME_LABEL(X) X ##:
# 44 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/linkage.h"
#define __ALIGN .align 4,0x90
#define __ALIGN_STR ".align 4,0x90"
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/kernel.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/stddef.h" 1

#define _LINUX_STDDEF_H 





#define NULL ((void *)0)



#define offsetof(TYPE,MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/kernel.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/types.h" 1

#define _LINUX_TYPES_H 




#define BITS_TO_LONGS(bits) (((bits)+BITS_PER_LONG-1)/BITS_PER_LONG)

#define DECLARE_BITMAP(name,bits) unsigned long name[BITS_TO_LONGS(bits)]

#define CLEAR_BITMAP(name,bits) memset(name, 0, BITS_TO_LONGS(bits)*sizeof(unsigned long))



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/posix_types.h" 1

#define _LINUX_POSIX_TYPES_H 
# 22 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/posix_types.h"
#define __NFDBITS (8 * sizeof(unsigned long))


#define __FD_SETSIZE 1024


#define __FDSET_LONGS (__FD_SETSIZE/__NFDBITS)


#define __FDELT(d) ((d) / __NFDBITS)


#define __FDMASK(d) (1UL << ((d) % __NFDBITS))

typedef struct {
        unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/posix_types.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/posix_types.h"
#define _ASM_POSIX_TYPES_H 







typedef unsigned int __kernel_dev_t;
typedef unsigned long __kernel_ino_t;
typedef unsigned int __kernel_mode_t;
typedef unsigned long __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef int __kernel_ipc_pid_t;
typedef int __kernel_uid_t;
typedef int __kernel_gid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef long __kernel_daddr_t;
typedef char * __kernel_caddr_t;

typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef int __kernel_uid32_t;
typedef int __kernel_gid32_t;
typedef __kernel_uid_t __kernel_old_uid_t;
typedef __kernel_gid_t __kernel_old_gid_t;


typedef long long __kernel_loff_t;


typedef struct {
        long val[2];
} __kernel_fsid_t;




static __inline__ __attribute__((always_inline)) void __FD_SET(unsigned long __fd, __kernel_fd_set *__fdsetp)
{
        unsigned long __tmp = __fd / (8 * sizeof(unsigned long));
        unsigned long __rem = __fd % (8 * sizeof(unsigned long));
        __fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
}


static __inline__ __attribute__((always_inline)) void __FD_CLR(unsigned long __fd, __kernel_fd_set *__fdsetp)
{
        unsigned long __tmp = __fd / (8 * sizeof(unsigned long));
        unsigned long __rem = __fd % (8 * sizeof(unsigned long));
        __fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
}


static __inline__ __attribute__((always_inline)) int __FD_ISSET(unsigned long __fd, const __kernel_fd_set *__p)
{
        unsigned long __tmp = __fd / (8 * sizeof(unsigned long));
        unsigned long __rem = __fd % (8 * sizeof(unsigned long));
        return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
}






static __inline__ __attribute__((always_inline)) void __FD_ZERO(__kernel_fd_set *__p)
{
        unsigned long *__tmp = __p->fds_bits;
        int __i;

        if (__builtin_constant_p((1024/(8 * sizeof(unsigned long))))) {
                switch ((1024/(8 * sizeof(unsigned long)))) {
                case 16:
                        __tmp[ 0] = 0; __tmp[ 1] = 0;
                        __tmp[ 2] = 0; __tmp[ 3] = 0;
                        __tmp[ 4] = 0; __tmp[ 5] = 0;
                        __tmp[ 6] = 0; __tmp[ 7] = 0;
                        __tmp[ 8] = 0; __tmp[ 9] = 0;
                        __tmp[10] = 0; __tmp[11] = 0;
                        __tmp[12] = 0; __tmp[13] = 0;
                        __tmp[14] = 0; __tmp[15] = 0;
                        return;

                case 8:
                        __tmp[ 0] = 0; __tmp[ 1] = 0;
                        __tmp[ 2] = 0; __tmp[ 3] = 0;
                        __tmp[ 4] = 0; __tmp[ 5] = 0;
                        __tmp[ 6] = 0; __tmp[ 7] = 0;
                        return;

                case 4:
                        __tmp[ 0] = 0; __tmp[ 1] = 0;
                        __tmp[ 2] = 0; __tmp[ 3] = 0;
                        return;
                }
        }
        __i = (1024/(8 * sizeof(unsigned long)));
        while (__i) {
                __i--;
                *__tmp = 0;
                __tmp++;
        }
}
# 47 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/posix_types.h" 2
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/types.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/types.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/types.h"
#define _ASM_TYPES_H 



typedef unsigned short umode_t;






typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;
# 38 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/types.h"
typedef __signed__ long long __s64;
typedef unsigned long long __u64;
# 49 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/types.h"
typedef __signed char s8;
typedef unsigned char u8;

typedef __signed short s16;
typedef unsigned short u16;

typedef __signed int s32;
typedef unsigned int u32;
# 66 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/types.h"
typedef __signed__ long long s64;
typedef unsigned long long u64;




#define BITS_PER_LONG _MIPS_SZLONG




typedef u32 dma_addr_t;

typedef u64 dma64_addr_t;




typedef unsigned long phys_t;
# 17 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/types.h" 2



typedef __kernel_fd_set fd_set;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_nlink_t nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_daddr_t daddr_t;
typedef __kernel_key_t key_t;
typedef __kernel_suseconds_t suseconds_t;


typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_uid16_t uid16_t;
typedef __kernel_gid16_t gid16_t;
# 52 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/types.h"
typedef __kernel_loff_t loff_t;







#define _SIZE_T 
typedef __kernel_size_t size_t;



#define _SSIZE_T 
typedef __kernel_ssize_t ssize_t;



#define _PTRDIFF_T 
typedef __kernel_ptrdiff_t ptrdiff_t;



#define _TIME_T 
typedef __kernel_time_t time_t;



#define _CLOCK_T 
typedef __kernel_clock_t clock_t;



#define _CADDR_T 
typedef __kernel_caddr_t caddr_t;



typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;


typedef unsigned char unchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;


#define __BIT_TYPES_DEFINED__ 

typedef __u8 u_int8_t;
typedef __s8 int8_t;
typedef __u16 u_int16_t;
typedef __s16 int16_t;
typedef __u32 u_int32_t;
typedef __s32 int32_t;



typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;


typedef __u64 uint64_t;
typedef __u64 u_int64_t;
typedef __s64 int64_t;
# 130 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/types.h"
struct ustat {
        __kernel_daddr_t f_tfree;
        __kernel_ino_t f_tinode;
        char f_fname[6];
        char f_fpack[6];
};
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/kernel.h" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/byteorder.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/byteorder.h"
#define _MIPS_BYTEORDER_H 






#define __BYTEORDER_HAS_U64__ 
#define __SWAB_64_THRU_32__ 







# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/little_endian.h" 1

#define _LINUX_BYTEORDER_LITTLE_ENDIAN_H 


#define __LITTLE_ENDIAN 1234


#define __LITTLE_ENDIAN_BITFIELD 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/swab.h" 1

#define _LINUX_BYTEORDER_SWAB_H 
# 23 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/swab.h"
#define ___swab16(x) ({ __u16 __x = (x); ((__u16)( (((__u16)(__x) & (__u16)0x00ffU) << 8) | (((__u16)(__x) & (__u16)0xff00U) >> 8) )); })







#define ___swab24(x) ({ __u32 __x = (x); ((__u32)( ((__x & (__u32)0x000000ffUL) << 16) | (__x & (__u32)0x0000ff00UL) | ((__x & (__u32)0x00ff0000UL) >> 16) )); })
# 40 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/swab.h"
#define ___swab32(x) ({ __u32 __x = (x); ((__u32)( (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); })
# 50 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/swab.h"
#define ___swab64(x) ({ __u64 __x = (x); ((__u64)( (__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | (__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | (__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | (__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) << 8) | (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >> 8) | (__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | (__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | (__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); })
# 64 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/swab.h"
#define ___constant_swab16(x) ((__u16)( (((__u16)(x) & (__u16)0x00ffU) << 8) | (((__u16)(x) & (__u16)0xff00U) >> 8) ))



#define ___constant_swab24(x) ((__u32)( (((__u32)(x) & (__u32)0x000000ffU) << 16) | (((__u32)(x) & (__u32)0x0000ff00U)) | (((__u32)(x) & (__u32)0x00ff0000U) >> 16) ))




#define ___constant_swab32(x) ((__u32)( (((__u32)(x) & (__u32)0x000000ffUL) << 24) | (((__u32)(x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(x) & (__u32)0xff000000UL) >> 24) ))





#define ___constant_swab64(x) ((__u64)( (__u64)(((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) | (__u64)(((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) | (__u64)(((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) | (__u64)(((__u64)(x) & (__u64)0x00000000ff000000ULL) << 8) | (__u64)(((__u64)(x) & (__u64)0x000000ff00000000ULL) >> 8) | (__u64)(((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) | (__u64)(((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) | (__u64)(((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56) ))
# 94 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/swab.h"
#define __arch__swab16(x) ({ __u16 __tmp = (x) ; ___swab16(__tmp); })


#define __arch__swab24(x) ({ __u32 __tmp = (x) ; ___swab24(__tmp); })


#define __arch__swab32(x) ({ __u32 __tmp = (x) ; ___swab32(__tmp); })


#define __arch__swab64(x) ({ __u64 __tmp = (x) ; ___swab64(__tmp); })



#define __arch__swab16p(x) __arch__swab16(*(x))


#define __arch__swab24p(x) __arch__swab24(*(x))


#define __arch__swab32p(x) __arch__swab32(*(x))


#define __arch__swab64p(x) __arch__swab64(*(x))



#define __arch__swab16s(x) do { *(x) = __arch__swab16p((x)); } while (0)


#define __arch__swab24s(x) do { *(x) = __arch__swab24p((x)); } while (0)


#define __arch__swab32s(x) do { *(x) = __arch__swab32p((x)); } while (0)


#define __arch__swab64s(x) do { *(x) = __arch__swab64p((x)); } while (0)







#define __swab16(x) (__builtin_constant_p((__u16)(x)) ? ___swab16((x)) : __fswab16((x)))



#define __swab24(x) (__builtin_constant_p((__u32)(x)) ? ___swab24((x)) : __fswab24((x)))



#define __swab32(x) (__builtin_constant_p((__u32)(x)) ? ___swab32((x)) : __fswab32((x)))



#define __swab64(x) (__builtin_constant_p((__u64)(x)) ? ___swab64((x)) : __fswab64((x)))
# 161 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/swab.h"
static __inline__ __attribute__((always_inline)) __attribute__((__const__)) __u16 __fswab16(__u16 x)
{
        return ({ __u16 __tmp = (x) ; ({ __u16 __x = (__tmp); ((__u16)( (((__u16)(__x) & (__u16)0x00ffU) << 8) | (((__u16)(__x) & (__u16)0xff00U) >> 8) )); }); });
}
static __inline__ __attribute__((always_inline)) __u16 __swab16p(__u16 *x)
{
        return ({ __u16 __tmp = (*(x)) ; ({ __u16 __x = (__tmp); ((__u16)( (((__u16)(__x) & (__u16)0x00ffU) << 8) | (((__u16)(__x) & (__u16)0xff00U) >> 8) )); }); });
}
static __inline__ __attribute__((always_inline)) void __swab16s(__u16 *addr)
{
        do { *(addr) = ({ __u16 __tmp = (*((addr))) ; ({ __u16 __x = (__tmp); ((__u16)( (((__u16)(__x) & (__u16)0x00ffU) << 8) | (((__u16)(__x) & (__u16)0xff00U) >> 8) )); }); }); } while (0);
}

static __inline__ __attribute__((always_inline)) __attribute__((__const__)) __u32 __fswab24(__u32 x)
{
        return ({ __u32 __tmp = (x) ; ({ __u32 __x = (__tmp); ((__u32)( ((__x & (__u32)0x000000ffUL) << 16) | (__x & (__u32)0x0000ff00UL) | ((__x & (__u32)0x00ff0000UL) >> 16) )); }); });
}
static __inline__ __attribute__((always_inline)) __u32 __swab24p(__u32 *x)
{
        return ({ __u32 __tmp = (*(x)) ; ({ __u32 __x = (__tmp); ((__u32)( ((__x & (__u32)0x000000ffUL) << 16) | (__x & (__u32)0x0000ff00UL) | ((__x & (__u32)0x00ff0000UL) >> 16) )); }); });
}
static __inline__ __attribute__((always_inline)) void __swab24s(__u32 *addr)
{
        do { *(addr) = ({ __u32 __tmp = (*((addr))) ; ({ __u32 __x = (__tmp); ((__u32)( ((__x & (__u32)0x000000ffUL) << 16) | (__x & (__u32)0x0000ff00UL) | ((__x & (__u32)0x00ff0000UL) >> 16) )); }); }); } while (0);
}

static __inline__ __attribute__((always_inline)) __attribute__((__const__)) __u32 __fswab32(__u32 x)
{
        return ({ __u32 __tmp = (x) ; ({ __u32 __x = (__tmp); ((__u32)( (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); }); });
}
static __inline__ __attribute__((always_inline)) __u32 __swab32p(__u32 *x)
{
        return ({ __u32 __tmp = (*(x)) ; ({ __u32 __x = (__tmp); ((__u32)( (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); }); });
}
static __inline__ __attribute__((always_inline)) void __swab32s(__u32 *addr)
{
        do { *(addr) = ({ __u32 __tmp = (*((addr))) ; ({ __u32 __x = (__tmp); ((__u32)( (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); }); }); } while (0);
}


static __inline__ __attribute__((always_inline)) __attribute__((__const__)) __u64 __fswab64(__u64 x)
{

        __u32 h = x >> 32;
        __u32 l = x & ((1ULL<<32)-1);
        return (((__u64)(__builtin_constant_p((__u32)(l)) ? ({ __u32 __x = ((l)); ((__u32)( (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); }) : __fswab32((l)))) << 32) | ((__u64)((__builtin_constant_p((__u32)(h)) ? ({ __u32 __x = ((h)); ((__u32)( (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); }) : __fswab32((h)))));



}
static __inline__ __attribute__((always_inline)) __u64 __swab64p(__u64 *x)
{
        return ({ __u64 __tmp = (*(x)) ; ({ __u64 __x = (__tmp); ((__u64)( (__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | (__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | (__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | (__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) << 8) | (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >> 8) | (__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | (__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | (__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); }); });
}
static __inline__ __attribute__((always_inline)) void __swab64s(__u64 *addr)
{
        do { *(addr) = ({ __u64 __tmp = (*((addr))) ; ({ __u64 __x = (__tmp); ((__u64)( (__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | (__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | (__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | (__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) << 8) | (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >> 8) | (__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | (__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | (__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); }); }); } while (0);
}



#define swab16 __swab16
#define swab24 __swab24
#define swab32 __swab32
#define swab64 __swab64
#define swab16p __swab16p
#define swab24p __swab24p
#define swab32p __swab32p
#define swab64p __swab64p
#define swab16s __swab16s
#define swab24s __swab24s
#define swab32s __swab32s
#define swab64s __swab64s
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/little_endian.h" 2

#define __constant_htonl(x) ___constant_swab32((x))
#define __constant_ntohl(x) ___constant_swab32((x))
#define __constant_htons(x) ___constant_swab16((x))
#define __constant_ntohs(x) ___constant_swab16((x))
#define __constant_cpu_to_le64(x) ((__u64)(x))
#define __constant_le64_to_cpu(x) ((__u64)(x))
#define __constant_cpu_to_le32(x) ((__u32)(x))
#define __constant_le32_to_cpu(x) ((__u32)(x))
#define __constant_cpu_to_le24(x) ((__u32)(x))
#define __constant_le24_to_cpu(x) ((__u32)(x))
#define __constant_cpu_to_le16(x) ((__u16)(x))
#define __constant_le16_to_cpu(x) ((__u16)(x))
#define __constant_cpu_to_be64(x) ___constant_swab64((x))
#define __constant_be64_to_cpu(x) ___constant_swab64((x))
#define __constant_cpu_to_be32(x) ___constant_swab32((x))
#define __constant_be32_to_cpu(x) ___constant_swab32((x))
#define __constant_cpu_to_be24(x) ___constant_swab24((x))
#define __constant_be24_to_cpu(x) ___constant_swab24((x))
#define __constant_cpu_to_be16(x) ___constant_swab16((x))
#define __constant_be16_to_cpu(x) ___constant_swab16((x))
#define __cpu_to_le64(x) ((__u64)(x))
#define __le64_to_cpu(x) ((__u64)(x))
#define __cpu_to_le32(x) ((__u32)(x))
#define __le32_to_cpu(x) ((__u32)(x))
#define __cpu_to_le24(x) ((__u32)(x))
#define __le24_to_cpu(x) ((__u32)(x))
#define __cpu_to_le16(x) ((__u16)(x))
#define __le16_to_cpu(x) ((__u16)(x))
#define __cpu_to_be64(x) __swab64((x))
#define __be64_to_cpu(x) __swab64((x))
#define __cpu_to_be32(x) __swab32((x))
#define __be32_to_cpu(x) __swab32((x))
#define __cpu_to_be24(x) __swab24((x))
#define __be24_to_cpu(x) __swab24((x))
#define __cpu_to_be16(x) __swab16((x))
#define __be16_to_cpu(x) __swab16((x))
#define __cpu_to_le64p(x) (*(__u64*)(x))
#define __le64_to_cpup(x) (*(__u64*)(x))
#define __cpu_to_le32p(x) (*(__u32*)(x))
#define __le32_to_cpup(x) (*(__u32*)(x))
#define __cpu_to_le24p(x) (*(__u32*)(x))
#define __le24_to_cpup(x) (*(__u32*)(x))
#define __cpu_to_le16p(x) (*(__u16*)(x))
#define __le16_to_cpup(x) (*(__u16*)(x))
#define __cpu_to_be64p(x) __swab64p((x))
#define __be64_to_cpup(x) __swab64p((x))
#define __cpu_to_be32p(x) __swab32p((x))
#define __be32_to_cpup(x) __swab32p((x))
#define __cpu_to_be24p(x) __swab24p((x))
#define __be24_to_cpup(x) __swab24p((x))
#define __cpu_to_be16p(x) __swab16p((x))
#define __be16_to_cpup(x) __swab16p((x))
#define __cpu_to_le64s(x) do {} while (0)
#define __le64_to_cpus(x) do {} while (0)
#define __cpu_to_le32s(x) do {} while (0)
#define __le32_to_cpus(x) do {} while (0)
#define __cpu_to_le24s(x) do {} while (0)
#define __le24_to_cpus(x) do {} while (0)
#define __cpu_to_le16s(x) do {} while (0)
#define __le16_to_cpus(x) do {} while (0)
#define __cpu_to_be64s(x) __swab64s((x))
#define __be64_to_cpus(x) __swab64s((x))
#define __cpu_to_be32s(x) __swab32s((x))
#define __be32_to_cpus(x) __swab32s((x))
#define __cpu_to_be24s(x) __swab24s((x))
#define __be24_to_cpus(x) __swab24s((x))
#define __cpu_to_be16s(x) __swab16s((x))
#define __be16_to_cpus(x) __swab16s((x))

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/generic.h" 1

#define _LINUX_BYTEORDER_GENERIC_H 
# 87 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/generic.h"
#define cpu_to_le64 __cpu_to_le64
#define le64_to_cpu __le64_to_cpu
#define cpu_to_le32 __cpu_to_le32
#define le32_to_cpu __le32_to_cpu
#define cpu_to_le16 __cpu_to_le16
#define le16_to_cpu __le16_to_cpu
#define cpu_to_be64 __cpu_to_be64
#define be64_to_cpu __be64_to_cpu
#define cpu_to_be32 __cpu_to_be32
#define be32_to_cpu __be32_to_cpu
#define cpu_to_be16 __cpu_to_be16
#define be16_to_cpu __be16_to_cpu
#define cpu_to_le64p __cpu_to_le64p
#define le64_to_cpup __le64_to_cpup
#define cpu_to_le32p __cpu_to_le32p
#define le32_to_cpup __le32_to_cpup
#define cpu_to_le16p __cpu_to_le16p
#define le16_to_cpup __le16_to_cpup
#define cpu_to_be64p __cpu_to_be64p
#define be64_to_cpup __be64_to_cpup
#define cpu_to_be32p __cpu_to_be32p
#define be32_to_cpup __be32_to_cpup
#define cpu_to_be16p __cpu_to_be16p
#define be16_to_cpup __be16_to_cpup
#define cpu_to_le64s __cpu_to_le64s
#define le64_to_cpus __le64_to_cpus
#define cpu_to_le32s __cpu_to_le32s
#define le32_to_cpus __le32_to_cpus
#define cpu_to_le16s __cpu_to_le16s
#define le16_to_cpus __le16_to_cpus
#define cpu_to_be64s __cpu_to_be64s
#define be64_to_cpus __be64_to_cpus
#define cpu_to_be32s __cpu_to_be32s
#define be32_to_cpus __be32_to_cpus
#define cpu_to_be16s __cpu_to_be16s
#define be16_to_cpus __be16_to_cpus
# 149 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/generic.h"
extern __u32 ntohl(__u32);
extern __u32 htonl(__u32);
extern unsigned short int ntohs(unsigned short int);
extern unsigned short int htons(unsigned short int);



#define ___htonl(x) __cpu_to_be32(x)
#define ___htons(x) __cpu_to_be16(x)
#define ___ntohl(x) __be32_to_cpu(x)
#define ___ntohs(x) __be16_to_cpu(x)

#define htonl(x) ___htonl(x)
#define ntohl(x) ___ntohl(x)
#define htons(x) ___htons(x)
#define ntohs(x) ___ntohs(x)
# 83 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/byteorder/little_endian.h" 2
# 26 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/byteorder.h" 2
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/kernel.h" 2



#define barrier() __asm__ __volatile__("": : :"memory")

#define INT_MAX ((int)(~0U>>1))
#define INT_MIN (-INT_MAX - 1)
#define UINT_MAX (~0U)
#define LONG_MAX ((long)(~0UL>>1))
#define LONG_MIN (-LONG_MAX - 1)
#define ULONG_MAX (~0UL)

#define STACK_MAGIC 0xdeadbeef

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

#define KERN_EMERG "<0>"
#define KERN_ALERT "<1>"
#define KERN_CRIT "<2>"
#define KERN_ERR "<3>"
#define KERN_WARNING "<4>"
#define KERN_NOTICE "<5>"
#define KERN_INFO "<6>"
#define KERN_DEBUG "<7>"

extern int console_printk[];

#define console_loglevel (console_printk[0])
#define default_message_loglevel (console_printk[1])
#define minimum_console_loglevel (console_printk[2])
#define default_console_loglevel (console_printk[3])

#define NORET_TYPE 
#define ATTRIB_NORET __attribute__((noreturn))
#define NORET_AND noreturn,





#define FASTCALL(x) x
#define fastcall 


struct completion;

extern struct notifier_block *panic_notifier_list;
 void panic(const char * fmt, ...)
        __attribute__ ((noreturn, format (printf, 1, 2)));
 void do_exit(long error_code)
        __attribute__((noreturn));
 void complete_and_exit(struct completion *, long)
        __attribute__((noreturn));
extern int abs(int);
extern unsigned long simple_strtoul(const char *,char **,unsigned int);
extern long simple_strtol(const char *,char **,unsigned int);
extern unsigned long long simple_strtoull(const char *,char **,unsigned int);
extern long long simple_strtoll(const char *,char **,unsigned int);
extern int sprintf(char * buf, const char * fmt, ...)
        __attribute__ ((format (printf, 2, 3)));
extern int vsprintf(char *buf, const char *, va_list)
        __attribute__ ((format (printf, 2, 0)));
extern int snprintf(char * buf, size_t size, const char * fmt, ...)
        __attribute__ ((format (printf, 3, 4)));
extern int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
        __attribute__ ((format (printf, 3, 0)));

extern int sscanf(const char *, const char *, ...)
        __attribute__ ((format (scanf, 2, 3)));
extern int vsscanf(const char *, const char *, va_list)
        __attribute__ ((format (scanf, 2, 0)));

extern int get_option(char **str, int *pint);
extern char *get_options(char *str, int nints, int *ints);
extern unsigned long long memparse(char *ptr, char **retptr);
extern void dev_probe_lock(void);
extern void dev_probe_unlock(void);

extern int session_of_pgrp(int pgrp);

 int printk(const char * fmt, ...)
        __attribute__ ((format (printf, 1, 2)));

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void console_silent(void)
{
        (console_printk[0]) = 0;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void console_verbose(void)
{
        if ((console_printk[0]))
                (console_printk[0]) = 15;
}

extern void bust_spinlocks(int yes);
extern int oops_in_progress;

extern int tainted;
extern const char *print_tainted(void);

extern void dump_stack(void);





#define pr_debug(fmt,arg...) do { } while (0)



#define pr_info(fmt,arg...) printk(KERN_INFO fmt, ##arg)






#define NIPQUAD(addr) ((unsigned char *)&addr)[0], ((unsigned char *)&addr)[1], ((unsigned char *)&addr)[2], ((unsigned char *)&addr)[3]






#define HIPQUAD(addr) ((unsigned char *)&addr)[3], ((unsigned char *)&addr)[2], ((unsigned char *)&addr)[1], ((unsigned char *)&addr)[0]
# 156 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/kernel.h"
#define min(x,y) ({ const typeof(x) _x = (x); const typeof(y) _y = (y); (void) (&_x == &_y); _x < _y ? _x : _y; })





#define max(x,y) ({ const typeof(x) _x = (x); const typeof(y) _y = (y); (void) (&_x == &_y); _x > _y ? _x : _y; })
# 174 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/kernel.h"
#define min_t(type,x,y) ({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })

#define max_t(type,x,y) ({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })


extern void __out_of_line_bug(int line) __attribute__((noreturn));
#define out_of_line_bug() __out_of_line_bug(__LINE__)



#define SI_LOAD_SHIFT 16
struct sysinfo {
        long uptime;
        unsigned long loads[3];
        unsigned long totalram;
        unsigned long freeram;
        unsigned long sharedram;
        unsigned long bufferram;
        unsigned long totalswap;
        unsigned long freeswap;
        unsigned short procs;
        unsigned short pad;
        unsigned long totalhigh;
        unsigned long freehigh;
        unsigned int mem_unit;
        char _f[20-2*sizeof(long)-sizeof(int)];
};

#define BUG_ON(condition) do { if (unlikely((condition)!=0)) BUG(); } while(0)

#define WARN_ON(condition) do { if (unlikely((condition)!=0)) { printk("Badness in %s at %s:%d\n", __FUNCTION__, __FILE__, __LINE__); dump_stack(); } } while (0)
# 26 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/addrspace.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/addrspace.h"
#define __ASM_MIPS_ADDRSPACE_H 
# 22 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/addrspace.h"
#define _ATYPE_ __PTRDIFF_TYPE__
#define _ATYPE32_ int
#define _ATYPE64_ long long
# 34 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/addrspace.h"
#define _ACAST32_ (_ATYPE_)(_ATYPE32_)
#define _ACAST64_ (_ATYPE64_)





#define KUSEG 0x00000000
#define KSEG0 0x80000000
#define KSEG1 0xa0000000
#define KSEG2 0xc0000000
#define KSEG3 0xe0000000

#define K0BASE KSEG0




#define KSEGX(a) ((_ACAST32_ (a)) & 0xe0000000)




#define CPHYSADDR(a) ((_ACAST32_ (a)) & 0x1fffffff)


#define PHYSADDR(a) CPHYSADDR(a)





#define KSEG0ADDR(a) (CPHYSADDR(a) | KSEG0)
#define KSEG1ADDR(a) (CPHYSADDR(a) | KSEG1)
#define KSEG2ADDR(a) (CPHYSADDR(a) | KSEG2)
#define KSEG3ADDR(a) (CPHYSADDR(a) | KSEG3)




#define XKUSEG 0x0000000000000000
#define XKSSEG 0x4000000000000000
#define XKPHYS 0x8000000000000000
#define XKSEG 0xc000000000000000
#define CKSEG0 0xffffffff80000000
#define CKSEG1 0xffffffffa0000000
#define CKSSEG 0xffffffffc0000000
#define CKSEG3 0xffffffffe0000000




#define K_CALG_COH_EXCL1_NOL2 0
#define K_CALG_COH_SHRL1_NOL2 1
#define K_CALG_UNCACHED 2
#define K_CALG_NONCOHERENT 3
#define K_CALG_COH_EXCL 4
#define K_CALG_COH_SHAREABLE 5
#define K_CALG_NOTUSED 6
#define K_CALG_UNCACHED_ACCEL 7

#define TO_PHYS_MASK 0xfffffffffULL




#define PHYS_TO_XKSEG_UNCACHED(p) PHYS_TO_XKPHYS(K_CALG_UNCACHED,(p))
#define PHYS_TO_XKSEG_CACHED(p) PHYS_TO_XKPHYS(K_CALG_COH_SHAREABLE,(p))
#define XKPHYS_TO_PHYS(p) ((p) & TO_PHYS_MASK)
#define PHYS_TO_XKPHYS(cm,a) (0x8000000000000000 | ((cm)<<59) | (a))
# 28 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ptrace.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ptrace.h"
#define _ASM_PTRACE_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/isadep.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/isadep.h"
#define __ASM_ISADEP_H 
# 29 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/isadep.h"
#define KU_MASK 0x18
#define KU_USER 0x10
#define KU_KERN 0x00
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ptrace.h" 2


#define FPR_BASE 32
#define PC 64
#define CAUSE 65
#define BADVADDR 66
#define MMHI 67
#define MMLO 68
#define FPC_CSR 69
#define FPC_EIR 70






struct pt_regs {

        unsigned long pad0[6];


        unsigned long regs[32];


        unsigned long cp0_status;
        unsigned long lo;
        unsigned long hi;
        unsigned long cp0_badvaddr;
        unsigned long cp0_cause;
        unsigned long cp0_epc;
};

#define __str2(x) #x
#define __str(x) __str2(x)

#define save_static_function(symbol) __asm__ ( ".globl\t" #symbol "\n\t" ".align\t2\n\t" ".type\t" #symbol ", @function\n\t" ".ent\t" #symbol ", 0\n" #symbol":\n\t" ".frame\t$29, 0, $31\n\t" "sw\t$16,"__str(PT_R16)"($29)\t\t\t# save_static_function\n\t" "sw\t$17,"__str(PT_R17)"($29)\n\t" "sw\t$18,"__str(PT_R18)"($29)\n\t" "sw\t$19,"__str(PT_R19)"($29)\n\t" "sw\t$20,"__str(PT_R20)"($29)\n\t" "sw\t$21,"__str(PT_R21)"($29)\n\t" "sw\t$22,"__str(PT_R22)"($29)\n\t" "sw\t$23,"__str(PT_R23)"($29)\n\t" "sw\t$30,"__str(PT_R30)"($29)\n\t" ".end\t" #symbol "\n\t" ".size\t" #symbol",. - " #symbol)
# 71 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ptrace.h"
#define static_unused static __attribute__((unused))
# 83 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ptrace.h"
#define PTRACE_SETOPTIONS 21


#define PTRACE_O_TRACESYSGOOD 0x00000001
# 98 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ptrace.h"
#define user_mode(regs) (((regs)->cp0_status & KU_MASK) == KU_USER)

#define instruction_pointer(regs) ((regs)->cp0_epc)

extern void show_regs(struct pt_regs *);
# 29 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h" 2

__asm__ (



        ".macro\t__sti\n\t"

        ".set\tpush\n\t"
        ".set\treorder\n\t"
        ".set\tnoat\n\t"
        "mfc0\t$1,$12\n\t"
        "ori\t$1,0x1f\n\t"
        "xori\t$1,0x1e\n\t"
        "mtc0\t$1,$12\n\t"
        ".set\tpop\n\t"
        ".endm");

extern __inline__ __attribute__((always_inline)) void



  __sti(void)

{
        __asm__ __volatile__(

                "__sti"



                :
                :
                : "memory");
}
# 71 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
__asm__ (



        ".macro\t__cli\n\t"

        ".set\tpush\n\t"
        ".set\tnoat\n\t"
        "mfc0\t$1,$12\n\t"
        "ori\t$1,1\n\t"
        "xori\t$1,1\n\t"
        ".set\tnoreorder\n\t"
        "mtc0\t$1,$12\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        ".set\tpop\n\t"
        ".endm");

extern __inline__ __attribute__((always_inline)) void



    __cli(void)

{
        __asm__ __volatile__(

                "__cli"



                :
                :
                : "memory");
}


#define hard_save_flags(x) do { __save_flags(x); } while(0)
#define hard_save_flags_and_cli(x) do { __save_and_cli(x); } while(0)
__asm__ (
        ".macro\t__save_flags flags\n\t"
        ".set\tpush\n\t"
        ".set\treorder\n\t"
        "mfc0\t\\flags, $12\n\t"
        ".set\tpop\n\t"
        ".endm");

#define __save_flags(x) __asm__ __volatile__( "__save_flags %0" : "=r" (x))




__asm__ (
        ".macro\t__save_and_cli result\n\t"
        ".set\tpush\n\t"
        ".set\treorder\n\t"
        ".set\tnoat\n\t"
        "mfc0\t\\result, $12\n\t"
        "ori\t$1, \\result, 1\n\t"
        "xori\t$1, 1\n\t"
        ".set\tnoreorder\n\t"
        "mtc0\t$1, $12\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        ".set\tpop\n\t"
        ".endm");

#define __save_and_cli(x) __asm__ __volatile__( "__save_and_cli\t%0" : "=r" (x) : : "memory")






__asm__ (
        ".macro\t__save_and_sti result\n\t"
        ".set\tpush\n\t"
        ".set\treorder\n\t"
        ".set\tnoat\n\t"
        "mfc0\t\\result, $12\n\t"
        "ori\t$1, \\result, 1\n\t"
        ".set\tnoreorder\n\t"
        "mtc0\t$1,$12\n\t"
        ".set\tpop\n\t"
        ".endm");
# 217 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
#define __save_and_sti(x) __asm__ __volatile__( "__save_and_sti\t%0" : "=r" (x) : : "memory")
# 233 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
__asm__(".macro\t__restore_flags flags\n\t"



        ".set\tnoreorder\n\t"
        ".set\tnoat\n\t"
        "mfc0\t$1, $12\n\t"
        "andi\t\\flags, 1\n\t"
        "ori\t$1, 1\n\t"
        "xori\t$1, 1\n\t"
        "or\t\\flags, $1\n\t"
        "mtc0\t\\flags, $12\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        ".set\tat\n\t"
        ".set\treorder\n\t"
        ".endm");
# 264 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
#define hard_restore_flags(flags) __restore_flags(flags)
#define __restore_flags(flags) do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0)
# 331 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
#define sti() __sti()
#define cli() __cli()
#define save_flags(x) __save_flags(x)
#define save_and_cli(x) __save_and_cli(x)
#define restore_flags(x) __restore_flags(x)
#define save_and_sti(x) __save_and_sti(x)




#define local_irq_save(x) __save_and_cli(x)
#define local_irq_set(x) __save_and_sti(x)
#define local_irq_restore(x) __restore_flags(x)
#define local_irq_disable() __cli()
#define local_irq_enable() __sti()


#define __sync() __asm__ __volatile__( ".set	push\n\t" ".set	noreorder\n\t" ".set	mips2\n\t" "sync\n\t" ".set	pop" : : : "memory")
# 362 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
#define __fast_iob() __asm__ __volatile__( ".set	push\n\t" ".set	noreorder\n\t" "lw	$0,%0\n\t" "nop\n\t" ".set	pop" : : "m" (*(int *)KSEG1) : "memory")
# 373 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
#define fast_wmb() __sync()
#define fast_rmb() __sync()
#define fast_mb() __sync()
#define fast_iob() do { __sync(); __fast_iob(); } while (0)
# 393 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
#define wmb() fast_wmb()
#define rmb() fast_rmb()
#define mb() fast_mb()
#define iob() fast_iob()
# 405 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
#define smp_mb() barrier()
#define smp_rmb() barrier()
#define smp_wmb() barrier()


#define set_mb(var,value) do { var = value; mb(); } while (0)


#define set_wmb(var,value) do { var = value; wmb(); } while (0)






extern void *resume(void *last, void *next);

#define prepare_to_switch() do { } while(0)

struct task_struct;

#define switch_to(prev,next,last) do { (last) = resume(prev, next); } while(0)
# 435 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
extern __inline__ __attribute__((always_inline)) unsigned long xchg_u32(volatile int * m, unsigned long val)
{

        unsigned long dummy;

        __asm__ __volatile__(
                ".set\tpush\t\t\t\t# xchg_u32\n\t"
                ".set\tnoreorder\n\t"
                ".set\tnomacro\n\t"
                "ll\t%0, %3\n"
                "1:\tmove\t%2, %z4\n\t"
                "sc\t%2, %1\n\t"
                "beqzl\t%2, 1b\n\t"
                " ll\t%0, %3\n\t"
                "sync\n\t"
                ".set\tpop"
                : "=&r" (val), "=m" (*m), "=&r" (dummy)
                : "R" (*m), "Jr" (val)
                : "memory");

        return val;
# 465 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/system.h"
}

#define xchg(ptr,x) ((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
#define tas(ptr) (xchg((ptr),1))

static __inline__ __attribute__((always_inline)) unsigned long
__xchg(unsigned long x, volatile void * ptr, int size)
{
        switch (size) {
                case 4:
                        return xchg_u32(ptr, x);
        }
        return x;
}

extern void *set_except_vector(int n, void *addr);
extern void per_cpu_trap_init(void);

extern void __die(const char *, struct pt_regs *, const char *file,
        const char *func, unsigned long line) __attribute__((noreturn));
extern void __die_if_kernel(const char *, struct pt_regs *, const char *file,
        const char *func, unsigned long line);

#define die(msg,regs) __die(msg, regs, __FILE__ ":", __FUNCTION__, __LINE__)

#define die_if_kernel(msg,regs) __die_if_kernel(msg, regs, __FILE__ ":", __FUNCTION__, __LINE__)
# 7 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/spinlock.h" 2





#define spin_lock_irqsave(lock,flags) do { local_irq_save(flags); spin_lock(lock); } while (0)
#define spin_lock_irq(lock) do { local_irq_disable(); spin_lock(lock); } while (0)
#define spin_lock_bh(lock) do { local_bh_disable(); spin_lock(lock); } while (0)

#define read_lock_irqsave(lock,flags) do { local_irq_save(flags); read_lock(lock); } while (0)
#define read_lock_irq(lock) do { local_irq_disable(); read_lock(lock); } while (0)
#define read_lock_bh(lock) do { local_bh_disable(); read_lock(lock); } while (0)

#define write_lock_irqsave(lock,flags) do { local_irq_save(flags); write_lock(lock); } while (0)
#define write_lock_irq(lock) do { local_irq_disable(); write_lock(lock); } while (0)
#define write_lock_bh(lock) do { local_bh_disable(); write_lock(lock); } while (0)

#define spin_unlock_irqrestore(lock,flags) do { spin_unlock(lock); local_irq_restore(flags); } while (0)
#define spin_unlock_irq(lock) do { spin_unlock(lock); local_irq_enable(); } while (0)
#define spin_unlock_bh(lock) do { spin_unlock(lock); local_bh_enable(); } while (0)

#define read_unlock_irqrestore(lock,flags) do { read_unlock(lock); local_irq_restore(flags); } while (0)
#define read_unlock_irq(lock) do { read_unlock(lock); local_irq_enable(); } while (0)
#define read_unlock_bh(lock) do { read_unlock(lock); local_bh_enable(); } while (0)

#define write_unlock_irqrestore(lock,flags) do { write_unlock(lock); local_irq_restore(flags); } while (0)
#define write_unlock_irq(lock) do { write_unlock(lock); local_irq_enable(); } while (0)
#define write_unlock_bh(lock) do { write_unlock(lock); local_bh_enable(); } while (0)
#define spin_trylock_bh(lock) ({ int __r; local_bh_disable(); __r = spin_trylock(lock); if (!__r) local_bh_enable(); __r; })






# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/stringify.h" 1

#define __LINUX_STRINGIFY_H 






#define __stringify_1(x) #x
#define __stringify(x) __stringify_1(x)
# 43 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/spinlock.h" 2

#define LOCK_SECTION_NAME ".text.lock." __stringify(KBUILD_BASENAME)


#define LOCK_SECTION_START(extra) ".subsection 1\n\t" extra ".ifndef " LOCK_SECTION_NAME "\n\t" LOCK_SECTION_NAME ":\n\t" ".endif\n\t"






#define LOCK_SECTION_END ".previous\n\t"
# 63 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/spinlock.h"
#define DEBUG_SPINLOCKS 0



#define atomic_dec_and_lock(atomic,lock) atomic_dec_and_test(atomic)
#define ATOMIC_DEC_AND_LOCK 
# 77 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/spinlock.h"
  typedef struct { } spinlock_t;
#define SPIN_LOCK_UNLOCKED (spinlock_t) { }





#define spin_lock_init(lock) do { } while(0)
#define spin_lock(lock) (void)(lock)
#define spin_is_locked(lock) (0)
#define spin_trylock(lock) ({1; })
#define spin_unlock_wait(lock) do { } while(0)
#define spin_unlock(lock) do { } while(0)
# 141 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/spinlock.h"
  typedef struct { } rwlock_t;
#define RW_LOCK_UNLOCKED (rwlock_t) { }





#define rwlock_init(lock) do { } while(0)
#define read_lock(lock) (void)(lock)
#define read_unlock(lock) (void)(lock)
#define write_lock(lock) (void)(lock)
#define write_unlock(lock) do { } while(0)
# 172 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/spinlock.h"
typedef struct {
    spinlock_t lock;
} spinlock_cacheline_t;
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/module.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h" 1

#define _LINUX_LIST_H 



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/prefetch.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/prefetch.h"
#define _LINUX_PREFETCH_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h"
#define _ASM_PROCESSOR_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/cache.h" 1

#define __LINUX_CACHE_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/cache.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/cache.h"
#define _ASM_CACHE_H 







#define L1_CACHE_BYTES 32


#define SMP_CACHE_BYTES L1_CACHE_BYTES
# 6 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/cache.h" 2


#define L1_CACHE_ALIGN(x) (((x)+(L1_CACHE_BYTES-1))&~(L1_CACHE_BYTES-1))







#define ____cacheline_aligned __attribute__((__aligned__(SMP_CACHE_BYTES)))






#define ____cacheline_aligned_in_smp 







#define __cacheline_aligned __attribute__((__aligned__(SMP_CACHE_BYTES), __section__(".data.cacheline_aligned")))
# 41 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/cache.h"
#define __cacheline_aligned_in_smp 
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/isadep.h" 1
# 17 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h" 2




#define current_text_addr() ({ __label__ _l; _l: &&_l;})


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/smp.h" 1

#define __LINUX_SMP_H 
# 80 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/smp.h"
#define smp_num_cpus 1
#define smp_processor_id() 0
#define hard_smp_processor_id() 0
#define smp_threads_ready 1
#define kernel_lock() 
#define cpu_logical_map(cpu) 0
#define cpu_number_map(cpu) 0
#define smp_call_function(func,info,retry,wait) ({ 0; })
#define cpu_online_map 1
# 25 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/threads.h" 1

#define _LINUX_THREADS_H 
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/threads.h"
#define NR_CPUS 1


#define MIN_THREADS_LEFT_FOR_ROOT 4




#define PID_MAX 0x8000
# 26 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/cachectl.h" 1






#define __ASM_MIPS_CACHECTL 




#define ICACHE (1<<0)
#define DCACHE (1<<1)
#define BCACHE (ICACHE|DCACHE)






#define CACHEABLE 0
#define UNCACHEABLE 1
# 28 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/cpu.h" 1







#define _ASM_CPU_H 
# 25 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/cpu.h"
#define PRID_COMP_LEGACY 0x000000
#define PRID_COMP_MIPS 0x010000
#define PRID_COMP_BROADCOM 0x020000
#define PRID_COMP_ALCHEMY 0x030000
#define PRID_COMP_SIBYTE 0x040000
#define PRID_COMP_SANDCRAFT 0x050000






#define PRID_IMP_R2000 0x0100
#define PRID_IMP_AU1_REV1 0x0100
#define PRID_IMP_AU1_REV2 0x0200
#define PRID_IMP_R3000 0x0200
#define PRID_IMP_R6000 0x0300
#define PRID_IMP_R4000 0x0400
#define PRID_IMP_R6000A 0x0600
#define PRID_IMP_R10000 0x0900
#define PRID_IMP_R4300 0x0b00
#define PRID_IMP_VR41XX 0x0c00
#define PRID_IMP_R12000 0x0e00
#define PRID_IMP_R8000 0x1000
#define PRID_IMP_R4600 0x2000
#define PRID_IMP_R4700 0x2100
#define PRID_IMP_TX39 0x2200
#define PRID_IMP_R4640 0x2200
#define PRID_IMP_R4650 0x2200
#define PRID_IMP_R5000 0x2300
#define PRID_IMP_TX49 0x2d00
#define PRID_IMP_SONIC 0x2400
#define PRID_IMP_MAGIC 0x2500
#define PRID_IMP_RM7000 0x2700
#define PRID_IMP_NEVADA 0x2800
#define PRID_IMP_RM9000 0x3400
#define PRID_IMP_R5432 0x5400
#define PRID_IMP_R5500 0x5500
#define PRID_IMP_4KC 0x8000
#define PRID_IMP_5KC 0x8100
#define PRID_IMP_20KC 0x8200
#define PRID_IMP_4KEC 0x8400
#define PRID_IMP_4KSC 0x8600
#define PRID_IMP_25KF 0x8800
#define PRID_IMP_24K 0x9300
#define PRID_IMP_GODSON1 0x4200
#define PRID_IMP_GODSON232 0x4220
#define PRID_IMP_GODSON2 0x6300

#define PRID_IMP_UNKNOWN 0xff00





#define PRID_IMP_SB1 0x0100





#define PRID_IMP_SR71000 0x0400






#define PRID_REV_TX4927 0x0022
#define PRID_REV_TX4937 0x0030
#define PRID_REV_R4400 0x0040
#define PRID_REV_R3000A 0x0030
#define PRID_REV_R3000 0x0020
#define PRID_REV_R2000A 0x0010
#define PRID_REV_TX3912 0x0010
#define PRID_REV_TX3922 0x0030
#define PRID_REV_TX3927 0x0040
#define PRID_REV_VR4111 0x0050
#define PRID_REV_VR4181 0x0050
#define PRID_REV_VR4121 0x0060
#define PRID_REV_VR4122 0x0070
#define PRID_REV_VR4181A 0x0070
#define PRID_REV_VR4130 0x0080
# 118 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/cpu.h"
#define FPIR_IMP_NONE 0x0000

#define CPU_UNKNOWN 0
#define CPU_R2000 1
#define CPU_R3000 2
#define CPU_R3000A 3
#define CPU_R3041 4
#define CPU_R3051 5
#define CPU_R3052 6
#define CPU_R3081 7
#define CPU_R3081E 8
#define CPU_R4000PC 9
#define CPU_R4000SC 10
#define CPU_R4000MC 11
#define CPU_R4200 12
#define CPU_R4400PC 13
#define CPU_R4400SC 14
#define CPU_R4400MC 15
#define CPU_R4600 16
#define CPU_R6000 17
#define CPU_R6000A 18
#define CPU_R8000 19
#define CPU_R10000 20
#define CPU_R12000 21
#define CPU_R4300 22
#define CPU_R4650 23
#define CPU_R4700 24
#define CPU_R5000 25
#define CPU_R5000A 26
#define CPU_R4640 27
#define CPU_NEVADA 28
#define CPU_RM7000 29
#define CPU_R5432 30
#define CPU_4KC 31
#define CPU_5KC 32
#define CPU_R4310 33
#define CPU_SB1 34
#define CPU_TX3912 35
#define CPU_TX3922 36
#define CPU_TX3927 37
#define CPU_AU1000 38
#define CPU_4KEC 39
#define CPU_4KSC 40
#define CPU_VR41XX 41
#define CPU_R5500 42
#define CPU_TX49XX 43
#define CPU_AU1500 44
#define CPU_20KC 45
#define CPU_VR4111 46
#define CPU_VR4121 47
#define CPU_VR4122 48
#define CPU_VR4131 49
#define CPU_VR4181 50
#define CPU_VR4181A 51
#define CPU_AU1100 52
#define CPU_SR71000 53
#define CPU_RM9000 54
#define CPU_25KF 55
#define CPU_VR4133 56
#define CPU_AU1550 57
#define CPU_24K 58
#define CPU_AU1200 59
#define CPU_GODSON1 60
#define CPU_GODSON2 61
#define CPU_GODSON232 62
#define CPU_LAST 62





#define MIPS_CPU_ISA_I 0x00000001
#define MIPS_CPU_ISA_II 0x00000002
#define MIPS_CPU_ISA_III 0x00008003
#define MIPS_CPU_ISA_IV 0x00008004
#define MIPS_CPU_ISA_V 0x00008005
#define MIPS_CPU_ISA_M32 0x00000020
#define MIPS_CPU_ISA_M64 0x00008040




#define MIPS_CPU_ISA_64BIT 0x00008000




#define MIPS_CPU_TLB 0x00000001

#define MIPS_CPU_4KEX 0x00000004
#define MIPS_CPU_4KTLB 0x00000008
#define MIPS_CPU_FPU 0x00000010
#define MIPS_CPU_32FPR 0x00000020
#define MIPS_CPU_COUNTER 0x00000040
#define MIPS_CPU_WATCH 0x00000080
#define MIPS_CPU_MIPS16 0x00000100
#define MIPS_CPU_DIVEC 0x00000200
#define MIPS_CPU_VCE 0x00000400
#define MIPS_CPU_CACHE_CDEX_P 0x00000800
#define MIPS_CPU_CACHE_CDEX_S 0x00001000
#define MIPS_CPU_MCHECK 0x00002000
#define MIPS_CPU_EJTAG 0x00004000
#define MIPS_CPU_NOFPUEX 0x00008000
#define MIPS_CPU_LLSC 0x00010000
#define MIPS_CPU_SUBSET_CACHES 0x00020000
#define MIPS_CPU_PREFETCH 0x00040000
# 29 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h" 1
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define _ASM_MIPSREGS_H 



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/hazards.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/hazards.h"
#define _ASM_HAZARDS_H 
# 44 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/hazards.h"
#define rm9000_tlb_hazard() do { } while (0)
# 19 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h" 2






#define __STR(x) #x


#define STR(x) __STR(x)
# 37 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define _ULCAST_ (unsigned long)





#define CP0_INDEX $0
#define CP0_RANDOM $1
#define CP0_ENTRYLO0 $2
#define CP0_ENTRYLO1 $3
#define CP0_CONF $3
#define CP0_CONTEXT $4
#define CP0_PAGEMASK $5
#define CP0_WIRED $6
#define CP0_INFO $7
#define CP0_BADVADDR $8
#define CP0_COUNT $9
#define CP0_ENTRYHI $10
#define CP0_COMPARE $11
#define CP0_STATUS $12
#define CP0_CAUSE $13
#define CP0_EPC $14
#define CP0_PRID $15
#define CP0_CONFIG $16
#define CP0_LLADDR $17
#define CP0_WATCHLO $18
#define CP0_WATCHHI $19
#define CP0_XCONTEXT $20
#define CP0_FRAMEMASK $21
#define CP0_DIAGNOSTIC $22
#define CP0_DEBUG $23
#define CP0_DEPC $24
#define CP0_PERFORMANCE $25
#define CP0_ECC $26
#define CP0_CACHEERR $27
#define CP0_TAGLO $28
#define CP0_TAGHI $29
#define CP0_ERROREPC $30
#define CP0_DESAVE $31







#define CP0_IBASE $0
#define CP0_IBOUND $1
#define CP0_DBASE $2
#define CP0_DBOUND $3
#define CP0_CALG $17
#define CP0_IWATCH $18
#define CP0_DWATCH $19




#define CP0_S1_DERRADDR0 $26
#define CP0_S1_DERRADDR1 $27
#define CP0_S1_INTCONTROL $20




#define CP0_TX39_CACHE $7




#define CP1_REVISION $0
#define CP1_STATUS $31
# 116 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define FPU_CSR_FLUSH 0x01000000
#define FPU_CSR_COND 0x00800000
#define FPU_CSR_COND0 0x00800000
#define FPU_CSR_COND1 0x02000000
#define FPU_CSR_COND2 0x04000000
#define FPU_CSR_COND3 0x08000000
#define FPU_CSR_COND4 0x10000000
#define FPU_CSR_COND5 0x20000000
#define FPU_CSR_COND6 0x40000000
#define FPU_CSR_COND7 0x80000000






#define FPU_CSR_ALL_X 0x0003f000
#define FPU_CSR_UNI_X 0x00020000
#define FPU_CSR_INV_X 0x00010000
#define FPU_CSR_DIV_X 0x00008000
#define FPU_CSR_OVF_X 0x00004000
#define FPU_CSR_UDF_X 0x00002000
#define FPU_CSR_INE_X 0x00001000

#define FPU_CSR_ALL_E 0x00000f80
#define FPU_CSR_INV_E 0x00000800
#define FPU_CSR_DIV_E 0x00000400
#define FPU_CSR_OVF_E 0x00000200
#define FPU_CSR_UDF_E 0x00000100
#define FPU_CSR_INE_E 0x00000080

#define FPU_CSR_ALL_S 0x0000007c
#define FPU_CSR_INV_S 0x00000040
#define FPU_CSR_DIV_S 0x00000020
#define FPU_CSR_OVF_S 0x00000010
#define FPU_CSR_UDF_S 0x00000008
#define FPU_CSR_INE_S 0x00000004


#define FPU_CSR_RN 0x0
#define FPU_CSR_RZ 0x1
#define FPU_CSR_RU 0x2
#define FPU_CSR_RD 0x3
# 176 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define PM_4K 0x00000000
#define PM_16K 0x00006000
#define PM_64K 0x0001e000
#define PM_256K 0x0007e000
#define PM_1M 0x001fe000
#define PM_4M 0x007fe000
#define PM_16M 0x01ffe000
#define PM_64M 0x07ffe000
#define PM_256M 0x1fffe000
# 194 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define PM_DEFAULT_MASK PM_16K
# 205 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define PL_4K 12
#define PL_16K 14
#define PL_64K 16
#define PL_256K 18
#define PL_1M 20
#define PL_4M 22
#define PL_16M 24
#define PL_64M 26
#define PL_256M 28




#define IE_SW0 (_ULCAST_(1) << 8)
#define IE_SW1 (_ULCAST_(1) << 9)
#define IE_IRQ0 (_ULCAST_(1) << 10)
#define IE_IRQ1 (_ULCAST_(1) << 11)
#define IE_IRQ2 (_ULCAST_(1) << 12)
#define IE_IRQ3 (_ULCAST_(1) << 13)
#define IE_IRQ4 (_ULCAST_(1) << 14)
#define IE_IRQ5 (_ULCAST_(1) << 15)




#define C_SW0 (_ULCAST_(1) << 8)
#define C_SW1 (_ULCAST_(1) << 9)
#define C_IRQ0 (_ULCAST_(1) << 10)
#define C_IRQ1 (_ULCAST_(1) << 11)
#define C_IRQ2 (_ULCAST_(1) << 12)
#define C_IRQ3 (_ULCAST_(1) << 13)
#define C_IRQ4 (_ULCAST_(1) << 14)
#define C_IRQ5 (_ULCAST_(1) << 15)




#define ST0_IE 0x00000001
#define ST0_EXL 0x00000002
#define ST0_ERL 0x00000004
#define ST0_KSU 0x00000018
#define KSU_USER 0x00000010
#define KSU_SUPERVISOR 0x00000008
#define KSU_KERNEL 0x00000000
#define ST0_UX 0x00000020
#define ST0_SX 0x00000040
#define ST0_KX 0x00000080
#define ST0_DE 0x00010000
#define ST0_CE 0x00020000




#define ST0_IEC 0x00000001
#define ST0_KUC 0x00000002
#define ST0_IEP 0x00000004
#define ST0_KUP 0x00000008
#define ST0_IEO 0x00000010
#define ST0_KUO 0x00000020

#define ST0_ISC 0x00010000
#define ST0_SWC 0x00020000
#define ST0_CM 0x00080000




#define ST0_UM (_ULCAST_(1) << 4)
#define ST0_IL (_ULCAST_(1) << 23)
#define ST0_DL (_ULCAST_(1) << 24)




#define TX39_CONF_ICS_SHIFT 19
#define TX39_CONF_ICS_MASK 0x00380000
#define TX39_CONF_ICS_1KB 0x00000000
#define TX39_CONF_ICS_2KB 0x00080000
#define TX39_CONF_ICS_4KB 0x00100000
#define TX39_CONF_ICS_8KB 0x00180000
#define TX39_CONF_ICS_16KB 0x00200000

#define TX39_CONF_DCS_SHIFT 16
#define TX39_CONF_DCS_MASK 0x00070000
#define TX39_CONF_DCS_1KB 0x00000000
#define TX39_CONF_DCS_2KB 0x00010000
#define TX39_CONF_DCS_4KB 0x00020000
#define TX39_CONF_DCS_8KB 0x00030000
#define TX39_CONF_DCS_16KB 0x00040000

#define TX39_CONF_CWFON 0x00004000
#define TX39_CONF_WBON 0x00002000
#define TX39_CONF_RF_SHIFT 10
#define TX39_CONF_RF_MASK 0x00000c00
#define TX39_CONF_DOZE 0x00000200
#define TX39_CONF_HALT 0x00000100
#define TX39_CONF_LOCK 0x00000080
#define TX39_CONF_ICE 0x00000020
#define TX39_CONF_DCE 0x00000010
#define TX39_CONF_IRSIZE_SHIFT 2
#define TX39_CONF_IRSIZE_MASK 0x0000000c
#define TX39_CONF_DRSIZE_SHIFT 0
#define TX39_CONF_DRSIZE_MASK 0x00000003




#define ST0_IM 0x0000ff00
#define STATUSB_IP0 8
#define STATUSF_IP0 (_ULCAST_(1) << 8)
#define STATUSB_IP1 9
#define STATUSF_IP1 (_ULCAST_(1) << 9)
#define STATUSB_IP2 10
#define STATUSF_IP2 (_ULCAST_(1) << 10)
#define STATUSB_IP3 11
#define STATUSF_IP3 (_ULCAST_(1) << 11)
#define STATUSB_IP4 12
#define STATUSF_IP4 (_ULCAST_(1) << 12)
#define STATUSB_IP5 13
#define STATUSF_IP5 (_ULCAST_(1) << 13)
#define STATUSB_IP6 14
#define STATUSF_IP6 (_ULCAST_(1) << 14)
#define STATUSB_IP7 15
#define STATUSF_IP7 (_ULCAST_(1) << 15)
#define STATUSB_IP8 0
#define STATUSF_IP8 (_ULCAST_(1) << 0)
#define STATUSB_IP9 1
#define STATUSF_IP9 (_ULCAST_(1) << 1)
#define STATUSB_IP10 2
#define STATUSF_IP10 (_ULCAST_(1) << 2)
#define STATUSB_IP11 3
#define STATUSF_IP11 (_ULCAST_(1) << 3)
#define STATUSB_IP12 4
#define STATUSF_IP12 (_ULCAST_(1) << 4)
#define STATUSB_IP13 5
#define STATUSF_IP13 (_ULCAST_(1) << 5)
#define STATUSB_IP14 6
#define STATUSF_IP14 (_ULCAST_(1) << 6)
#define STATUSB_IP15 7
#define STATUSF_IP15 (_ULCAST_(1) << 7)
#define ST0_CH 0x00040000
#define ST0_SR 0x00100000
#define ST0_TS 0x00200000
#define ST0_BEV 0x00400000
#define ST0_RE 0x02000000
#define ST0_FR 0x04000000
#define ST0_CU 0xf0000000
#define ST0_CU0 0x10000000
#define ST0_CU1 0x20000000
#define ST0_CU2 0x40000000
#define ST0_CU3 0x80000000
#define ST0_XX 0x80000000






#define CAUSEB_EXCCODE 2
#define CAUSEF_EXCCODE (_ULCAST_(31) << 2)
#define CAUSEB_IP 8
#define CAUSEF_IP (_ULCAST_(255) << 8)
#define CAUSEB_IP0 8
#define CAUSEF_IP0 (_ULCAST_(1) << 8)
#define CAUSEB_IP1 9
#define CAUSEF_IP1 (_ULCAST_(1) << 9)
#define CAUSEB_IP2 10
#define CAUSEF_IP2 (_ULCAST_(1) << 10)
#define CAUSEB_IP3 11
#define CAUSEF_IP3 (_ULCAST_(1) << 11)
#define CAUSEB_IP4 12
#define CAUSEF_IP4 (_ULCAST_(1) << 12)
#define CAUSEB_IP5 13
#define CAUSEF_IP5 (_ULCAST_(1) << 13)
#define CAUSEB_IP6 14
#define CAUSEF_IP6 (_ULCAST_(1) << 14)
#define CAUSEB_IP7 15
#define CAUSEF_IP7 (_ULCAST_(1) << 15)
#define CAUSEB_IV 23
#define CAUSEF_IV (_ULCAST_(1) << 23)
#define CAUSEB_CE 28
#define CAUSEF_CE (_ULCAST_(3) << 28)
#define CAUSEB_BD 31
#define CAUSEF_BD (_ULCAST_(1) << 31)





#define CONF_CM_CACHABLE_NO_WA 0
#define CONF_CM_CACHABLE_WA 1
#define CONF_CM_UNCACHED 2
#define CONF_CM_CACHABLE_NONCOHERENT 3
#define CONF_CM_CACHABLE_CE 4
#define CONF_CM_CACHABLE_COW 5
#define CONF_CM_CACHABLE_CUW 6
#define CONF_CM_CACHABLE_ACCELERATED 7
#define CONF_CM_CMASK 7
#define CONF_BE (_ULCAST_(1) << 15)


#define CONF_CU (_ULCAST_(1) << 3)
#define CONF_DB (_ULCAST_(1) << 4)
#define CONF_IB (_ULCAST_(1) << 5)
#define CONF_DC (_ULCAST_(7) << 6)
#define CONF_IC (_ULCAST_(7) << 9)
#define CONF_EB (_ULCAST_(1) << 13)
#define CONF_EM (_ULCAST_(1) << 14)
#define CONF_SM (_ULCAST_(1) << 16)
#define CONF_SC (_ULCAST_(1) << 17)
#define CONF_EW (_ULCAST_(3) << 18)
#define CONF_EP (_ULCAST_(15)<< 24)
#define CONF_EC (_ULCAST_(7) << 28)
#define CONF_CM (_ULCAST_(1) << 31)


#define R4K_CONF_SW (_ULCAST_(1) << 20)
#define R4K_CONF_SS (_ULCAST_(1) << 21)
#define R4K_CONF_SB (_ULCAST_(3) << 22)


#define R5K_CONF_SE (_ULCAST_(1) << 12)
#define R5K_CONF_SS (_ULCAST_(3) << 20)


#define R10K_CONF_DN (_ULCAST_(3) << 3)
#define R10K_CONF_CT (_ULCAST_(1) << 5)
#define R10K_CONF_PE (_ULCAST_(1) << 6)
#define R10K_CONF_PM (_ULCAST_(3) << 7)
#define R10K_CONF_EC (_ULCAST_(15)<< 9)
#define R10K_CONF_SB (_ULCAST_(1) << 13)
#define R10K_CONF_SK (_ULCAST_(1) << 14)
#define R10K_CONF_SS (_ULCAST_(7) << 16)
#define R10K_CONF_SC (_ULCAST_(7) << 19)
#define R10K_CONF_DC (_ULCAST_(7) << 26)
#define R10K_CONF_IC (_ULCAST_(7) << 29)


#define VR41_CONF_CS (_ULCAST_(1) << 12)
#define VR41_CONF_M16 (_ULCAST_(1) << 20)
#define VR41_CONF_AD (_ULCAST_(1) << 23)


#define R30XX_CONF_FDM (_ULCAST_(1) << 19)
#define R30XX_CONF_REV (_ULCAST_(1) << 22)
#define R30XX_CONF_AC (_ULCAST_(1) << 23)
#define R30XX_CONF_RF (_ULCAST_(1) << 24)
#define R30XX_CONF_HALT (_ULCAST_(1) << 25)
#define R30XX_CONF_FPINT (_ULCAST_(7) << 26)
#define R30XX_CONF_DBR (_ULCAST_(1) << 29)
#define R30XX_CONF_SB (_ULCAST_(1) << 30)
#define R30XX_CONF_LOCK (_ULCAST_(1) << 31)


#define TX49_CONF_DC (_ULCAST_(1) << 16)
#define TX49_CONF_IC (_ULCAST_(1) << 17)
#define TX49_CONF_HALT (_ULCAST_(1) << 18)
#define TX49_CONF_CWFON (_ULCAST_(1) << 27)


#define MIPS_CONF_MT (_ULCAST_(7) << 7)
#define MIPS_CONF_AR (_ULCAST_(7) << 10)
#define MIPS_CONF_AT (_ULCAST_(3) << 13)
#define MIPS_CONF_M (_ULCAST_(1) << 31)
# 481 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define CE0_CYCLES 0
#define CE0_INSN_ISSUED 1
#define CE0_LPSC_ISSUED 2
#define CE0_S_ISSUED 3
#define CE0_SC_ISSUED 4
#define CE0_SC_FAILED 5
#define CE0_BRANCH_DECODED 6
#define CE0_QW_WB_SECONDARY 7
#define CE0_CORRECTED_ECC_ERRORS 8
#define CE0_ICACHE_MISSES 9
#define CE0_SCACHE_I_MISSES 10
#define CE0_SCACHE_I_WAY_MISSPREDICTED 11
#define CE0_EXT_INTERVENTIONS_REQ 12
#define CE0_EXT_INVALIDATE_REQ 13
#define CE0_VIRTUAL_COHERENCY_COND 14
#define CE0_INSN_GRADUATED 15




#define CE1_CYCLES 0
#define CE1_INSN_GRADUATED 1
#define CE1_LPSC_GRADUATED 2
#define CE1_S_GRADUATED 3
#define CE1_SC_GRADUATED 4
#define CE1_FP_INSN_GRADUATED 5
#define CE1_QW_WB_PRIMARY 6
#define CE1_TLB_REFILL 7
#define CE1_BRANCH_MISSPREDICTED 8
#define CE1_DCACHE_MISS 9
#define CE1_SCACHE_D_MISSES 10
#define CE1_SCACHE_D_WAY_MISSPREDICTED 11
#define CE1_EXT_INTERVENTION_HITS 12
#define CE1_EXT_INVALIDATE_REQ 13
#define CE1_SP_HINT_TO_CEXCL_SC_BLOCKS 14
#define CE1_SP_HINT_TO_SHARED_SC_BLOCKS 15




#define CEB_USER 8
#define CEB_SUPERVISOR 4
#define CEB_KERNEL 2
#define CEB_EXL 1






#define read_r10k_perf_cntr(counter) ({ unsigned int __res; __asm__ __volatile__( "mfpc\t%0, "STR(counter) : "=r" (__res)); __res;})






#define write_r10k_perf_cntr(counter,val) __asm__ __volatile__( "mtpc\t%0, "STR(counter) : : "r" (val));




#define read_r10k_perf_cntl(counter) ({ unsigned int __res; __asm__ __volatile__( "mfps\t%0, "STR(counter) : "=r" (__res)); __res;})






#define write_r10k_perf_cntl(counter,val) __asm__ __volatile__( "mtps\t%0, "STR(counter) : : "r" (val));
# 559 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define __read_32bit_c0_register(source,sel) ({ int __res; if (sel == 0) __asm__ __volatile__( "mfc0\t%0, " #source "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " #source ", " #sel "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; })
# 574 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define __read_64bit_c0_register(source,sel) ({ unsigned long __res; if (sel == 0) __asm__ __volatile__( ".set\tmips3\n\t" "dmfc0\t%0, " #source "\n\t" ".set\tmips0" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips64\n\t" "dmfc0\t%0, " #source ", " #sel "\n\t" ".set\tmips0" : "=r" (__res)); __res; })
# 591 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define __write_32bit_c0_register(register,sel,value) do { if (sel == 0) __asm__ __volatile__( "mtc0\t%z0, " #register "\n\t" : : "Jr" (value)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " #register ", " #sel "\n\t" ".set\tmips0" : : "Jr" (value)); } while (0)
# 605 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define __write_64bit_c0_register(register,sel,value) do { if (sel == 0) __asm__ __volatile__( ".set\tmips3\n\t" "dmtc0\t%z0, " #register "\n\t" ".set\tmips0" : : "Jr" (value)); else __asm__ __volatile__( ".set\tmips64\n\t" "dmtc0\t%z0, " #register ", " #sel "\n\t" ".set\tmips0" : : "Jr" (value)); } while (0)
# 621 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define __read_ulong_c0_register(reg,sel) ((sizeof(unsigned long) == 4) ? __read_32bit_c0_register(reg, sel) : __read_64bit_c0_register(reg, sel))




#define __write_ulong_c0_register(reg,sel,val) do { if (sizeof(unsigned long) == 4) __write_32bit_c0_register(reg, sel, val); else __write_64bit_c0_register(reg, sel, val); } while (0)
# 637 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define __read_32bit_c0_ctrl_register(source) ({ int __res; __asm__ __volatile__( "cfc0\t%0, " #source "\n\t" : "=r" (__res)); __res; })







#define __write_32bit_c0_ctrl_register(register,value) do { __asm__ __volatile__( "ctc0\t%z0, " #register "\n\t" : : "Jr" ((unsigned int)value)); } while (0)
# 656 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define __read_64bit_c0_split(source,sel) ({ unsigned long long val; unsigned long flags; local_irq_save(flags); if (sel == 0) __asm__ __volatile__( ".set\tmips64\n\t" "dmfc0\t%M0, " #source "\n\t" "dsll\t%L0, %M0, 32\n\t" "dsrl\t%M0, %M0, 32\n\t" "dsrl\t%L0, %L0, 32\n\t" ".set\tmips0" : "=r" (val)); else __asm__ __volatile__( ".set\tmips64\n\t" "dmfc0\t%M0, " #source ", " #sel "\n\t" "dsll\t%L0, %M0, 32\n\t" "dsrl\t%M0, %M0, 32\n\t" "dsrl\t%L0, %L0, 32\n\t" ".set\tmips0" : "=r" (val)); local_irq_restore(flags); val; })
# 685 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define __write_64bit_c0_split(source,sel,val) do { unsigned long flags; local_irq_save(flags); if (sel == 0) __asm__ __volatile__( ".set\tmips64\n\t" "dsll\t%L0, %L0, 32\n\t" "dsrl\t%L0, %L0, 32\n\t" "dsll\t%M0, %M0, 32\n\t" "or\t%L0, %L0, %M0\n\t" "dmtc0\t%L0, " #source "\n\t" ".set\tmips0" : : "r" (val)); else __asm__ __volatile__( ".set\tmips64\n\t" "dsll\t%L0, %L0, 32\n\t" "dsrl\t%L0, %L0, 32\n\t" "dsll\t%M0, %M0, 32\n\t" "or\t%L0, %L0, %M0\n\t" "dmtc0\t%L0, " #source ", " #sel "\n\t" ".set\tmips0" : : "r" (val)); local_irq_restore(flags); } while (0)
# 713 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
#define read_c0_index() __read_32bit_c0_register($0, 0)
#define write_c0_index(val) __write_32bit_c0_register($0, 0, val)

#define read_c0_entrylo0() __read_ulong_c0_register($2, 0)
#define write_c0_entrylo0(val) __write_ulong_c0_register($2, 0, val)

#define read_c0_entrylo1() __read_ulong_c0_register($3, 0)
#define write_c0_entrylo1(val) __write_ulong_c0_register($3, 0, val)

#define read_c0_conf() __read_32bit_c0_register($3, 0)
#define write_c0_conf(val) __write_32bit_c0_register($3, 0, val)

#define read_c0_context() __read_ulong_c0_register($4, 0)
#define write_c0_context(val) __write_ulong_c0_register($4, 0, val)

#define read_c0_pagemask() __read_32bit_c0_register($5, 0)
#define write_c0_pagemask(val) __write_32bit_c0_register($5, 0, val)

#define read_c0_wired() __read_32bit_c0_register($6, 0)
#define write_c0_wired(val) __write_32bit_c0_register($6, 0, val)

#define read_c0_info() __read_32bit_c0_register($7, 0)

#define read_c0_cache() __read_32bit_c0_register($7, 0)
#define write_c0_cache(val) __write_32bit_c0_register($7, 0, val)

#define read_c0_count() __read_32bit_c0_register($9, 0)
#define write_c0_count(val) __write_32bit_c0_register($9, 0, val)

#define read_c0_entryhi() __read_ulong_c0_register($10, 0)
#define write_c0_entryhi(val) __write_ulong_c0_register($10, 0, val)

#define read_c0_compare() __read_32bit_c0_register($11, 0)
#define write_c0_compare(val) __write_32bit_c0_register($11, 0, val)

#define read_c0_status() __read_32bit_c0_register($12, 0)
#define write_c0_status(val) __write_32bit_c0_register($12, 0, val)

#define read_c0_cause() __read_32bit_c0_register($13, 0)
#define write_c0_cause(val) __write_32bit_c0_register($13, 0, val)

#define read_c0_prid() __read_32bit_c0_register($15, 0)

#define read_c0_config() __read_32bit_c0_register($16, 0)
#define read_c0_config1() __read_32bit_c0_register($16, 1)
#define read_c0_config2() __read_32bit_c0_register($16, 2)
#define read_c0_config3() __read_32bit_c0_register($16, 3)
#define write_c0_config(val) __write_32bit_c0_register($16, 0, val)
#define write_c0_config1(val) __write_32bit_c0_register($16, 1, val)
#define write_c0_config2(val) __write_32bit_c0_register($16, 2, val)
#define write_c0_config3(val) __write_32bit_c0_register($16, 3, val)




#define read_c0_watchlo0() __read_ulong_c0_register($18, 0)
#define read_c0_watchlo1() __read_ulong_c0_register($18, 1)
#define read_c0_watchlo2() __read_ulong_c0_register($18, 2)
#define read_c0_watchlo3() __read_ulong_c0_register($18, 3)
#define read_c0_watchlo4() __read_ulong_c0_register($18, 4)
#define read_c0_watchlo5() __read_ulong_c0_register($18, 5)
#define read_c0_watchlo6() __read_ulong_c0_register($18, 6)
#define read_c0_watchlo7() __read_ulong_c0_register($18, 7)
#define write_c0_watchlo0(val) __write_ulong_c0_register($18, 0, val)
#define write_c0_watchlo1(val) __write_ulong_c0_register($18, 1, val)
#define write_c0_watchlo2(val) __write_ulong_c0_register($18, 2, val)
#define write_c0_watchlo3(val) __write_ulong_c0_register($18, 3, val)
#define write_c0_watchlo4(val) __write_ulong_c0_register($18, 4, val)
#define write_c0_watchlo5(val) __write_ulong_c0_register($18, 5, val)
#define write_c0_watchlo6(val) __write_ulong_c0_register($18, 6, val)
#define write_c0_watchlo7(val) __write_ulong_c0_register($18, 7, val)




#define read_c0_watchhi0() __read_32bit_c0_register($19, 0)
#define read_c0_watchhi1() __read_32bit_c0_register($19, 1)
#define read_c0_watchhi2() __read_32bit_c0_register($19, 2)
#define read_c0_watchhi3() __read_32bit_c0_register($19, 3)
#define read_c0_watchhi4() __read_32bit_c0_register($19, 4)
#define read_c0_watchhi5() __read_32bit_c0_register($19, 5)
#define read_c0_watchhi6() __read_32bit_c0_register($19, 6)
#define read_c0_watchhi7() __read_32bit_c0_register($19, 7)

#define write_c0_watchhi0(val) __write_32bit_c0_register($19, 0, val)
#define write_c0_watchhi1(val) __write_32bit_c0_register($19, 1, val)
#define write_c0_watchhi2(val) __write_32bit_c0_register($19, 2, val)
#define write_c0_watchhi3(val) __write_32bit_c0_register($19, 3, val)
#define write_c0_watchhi4(val) __write_32bit_c0_register($19, 4, val)
#define write_c0_watchhi5(val) __write_32bit_c0_register($19, 5, val)
#define write_c0_watchhi6(val) __write_32bit_c0_register($19, 6, val)
#define write_c0_watchhi7(val) __write_32bit_c0_register($19, 7, val)

#define read_c0_xcontext() __read_ulong_c0_register($20, 0)
#define write_c0_xcontext(val) __write_ulong_c0_register($20, 0, val)

#define read_c0_intcontrol() __read_32bit_c0_ctrl_register($20)
#define write_c0_intcontrol(val) __write_32bit_c0_ctrl_register($20, val)

#define read_c0_framemask() __read_32bit_c0_register($21, 0)
#define write_c0_framemask(val) __write_32bit_c0_register($21, 0, val)

#define read_c0_diag() __read_32bit_c0_register($22, 0)
#define write_c0_diag(val) __write_32bit_c0_register($22, 0, val)

#define read_c0_diag1() __read_32bit_c0_register($22, 1)
#define write_c0_diag1(val) __write_32bit_c0_register($22, 1, val)

#define read_c0_diag2() __read_32bit_c0_register($22, 2)
#define write_c0_diag2(val) __write_32bit_c0_register($22, 2, val)

#define read_c0_diag3() __read_32bit_c0_register($22, 3)
#define write_c0_diag3(val) __write_32bit_c0_register($22, 3, val)

#define read_c0_diag4() __read_32bit_c0_register($22, 4)
#define write_c0_diag4(val) __write_32bit_c0_register($22, 4, val)

#define read_c0_diag5() __read_32bit_c0_register($22, 5)
#define write_c0_diag5(val) __write_32bit_c0_register($22, 5, val)

#define read_c0_debug() __read_32bit_c0_register($23, 0)
#define write_c0_debug(val) __write_32bit_c0_register($23, 0, val)

#define read_c0_depc() __read_ulong_c0_register($24, 0)
#define write_c0_depc(val) __write_ulong_c0_register($24, 0, val)

#define read_c0_ecc() __read_32bit_c0_register($26, 0)
#define write_c0_ecc(val) __write_32bit_c0_register($26, 0, val)

#define read_c0_derraddr0() __read_ulong_c0_register($26, 1)
#define write_c0_derraddr0(val) __write_ulong_c0_register($26, 1, val)

#define read_c0_cacheerr() __read_32bit_c0_register($27, 0)

#define read_c0_derraddr1() __read_ulong_c0_register($27, 1)
#define write_c0_derraddr1(val) __write_ulong_c0_register($27, 1, val)

#define read_c0_taglo() __read_32bit_c0_register($28, 0)
#define write_c0_taglo(val) __write_32bit_c0_register($28, 0, val)

#define read_c0_taghi() __read_32bit_c0_register($29, 0)
#define write_c0_taghi(val) __write_32bit_c0_register($29, 0, val)

#define read_c0_errorepc() __read_ulong_c0_register($30, 0)
#define write_c0_errorepc(val) __write_ulong_c0_register($30, 0, val)




#define read_32bit_cp1_register(source) ({ int __res; __asm__ __volatile__( ".set\tpush\n\t" ".set\treorder\n\t" "cfc1\t%0,"STR(source)"\n\t" ".set\tpop" : "=r" (__res)); __res;})
# 875 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void tlb_probe(void)
{
        do { } while (0);
        __asm__ __volatile__(
                ".set noreorder\n\t"
                "tlbp\n\t"
                ".set reorder");
        do { } while (0);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void tlb_read(void)
{
        do { } while (0);
        __asm__ __volatile__(
                ".set noreorder\n\t"
                "tlbr\n\t"
                ".set reorder");
        do { } while (0);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void tlb_write_indexed(void)
{
        do { } while (0);
        __asm__ __volatile__(
                ".set noreorder\n\t"
                "tlbwi\n\t"
                ".set reorder");
        do { } while (0);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void tlb_write_random(void)
{
        do { } while (0);
        __asm__ __volatile__(
                ".set noreorder\n\t"
                "tlbwr\n\t"
                ".set reorder");
        do { } while (0);
}




#define __BUILD_SET_C0(name) static inline unsigned int set_c0_ ##name(unsigned int set) { unsigned int res; res = read_c0_ ##name(); res |= set; write_c0_ ##name(res); return res; } static inline unsigned int clear_c0_ ##name(unsigned int clear) { unsigned int res; res = read_c0_ ##name(); res &= ~clear; write_c0_ ##name(res); return res; } static inline unsigned int change_c0_ ##name(unsigned int change, unsigned int new) { unsigned int res; res = read_c0_ ##name(); res &= ~change; res |= (new & change); write_c0_ ##name(res); return res; }
# 956 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mipsregs.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int set_c0_status(unsigned int set) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$12" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$12" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res |= set; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$12" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$12" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int clear_c0_status(unsigned int clear) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$12" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$12" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~clear; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$12" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$12" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int change_c0_status(unsigned int change, unsigned int new) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$12" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$12" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~change; res |= (new & change); do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$12" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$12" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; }
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int set_c0_cause(unsigned int set) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$13" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$13" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res |= set; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$13" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$13" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int clear_c0_cause(unsigned int clear) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$13" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$13" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~clear; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$13" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$13" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int change_c0_cause(unsigned int change, unsigned int new) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$13" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$13" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~change; res |= (new & change); do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$13" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$13" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; }
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int set_c0_config(unsigned int set) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$16" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$16" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res |= set; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$16" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$16" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int clear_c0_config(unsigned int clear) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$16" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$16" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~clear; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$16" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$16" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int change_c0_config(unsigned int change, unsigned int new) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$16" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$16" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~change; res |= (new & change); do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$16" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$16" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; }
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int set_c0_intcontrol(unsigned int set) { unsigned int res; res = ({ int __res; __asm__ __volatile__( "cfc0\t%0, " "$20" "\n\t" : "=r" (__res)); __res; }); res |= set; do { __asm__ __volatile__( "ctc0\t%z0, " "$20" "\n\t" : : "Jr" ((unsigned int)res)); } while (0); return res; } static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int clear_c0_intcontrol(unsigned int clear) { unsigned int res; res = ({ int __res; __asm__ __volatile__( "cfc0\t%0, " "$20" "\n\t" : "=r" (__res)); __res; }); res &= ~clear; do { __asm__ __volatile__( "ctc0\t%z0, " "$20" "\n\t" : : "Jr" ((unsigned int)res)); } while (0); return res; } static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int change_c0_intcontrol(unsigned int change, unsigned int new) { unsigned int res; res = ({ int __res; __asm__ __volatile__( "cfc0\t%0, " "$20" "\n\t" : "=r" (__res)); __res; }); res &= ~change; res |= (new & change); do { __asm__ __volatile__( "ctc0\t%z0, " "$20" "\n\t" : : "Jr" ((unsigned int)res)); } while (0); return res; }
# 30 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/reg.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/reg.h"
#define __ASM_MIPS_REG_H 






#define EF_REG0 6
#define EF_REG1 7
#define EF_REG2 8
#define EF_REG3 9
#define EF_REG4 10
#define EF_REG5 11
#define EF_REG6 12
#define EF_REG7 13
#define EF_REG8 14
#define EF_REG9 15
#define EF_REG10 16
#define EF_REG11 17
#define EF_REG12 18
#define EF_REG13 19
#define EF_REG14 20
#define EF_REG15 21
#define EF_REG16 22
#define EF_REG17 23
#define EF_REG18 24
#define EF_REG19 25
#define EF_REG20 26
#define EF_REG21 27
#define EF_REG22 28
#define EF_REG23 29
#define EF_REG24 30
#define EF_REG25 31



#define EF_REG28 34
#define EF_REG29 35
#define EF_REG30 36
#define EF_REG31 37




#define EF_LO 38
#define EF_HI 39

#define EF_CP0_EPC 40
#define EF_CP0_BADVADDR 41
#define EF_CP0_STATUS 42
#define EF_CP0_CAUSE 43

#define EF_SIZE 180
# 31 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h" 2





struct cache_desc {
        unsigned short linesz;
        unsigned short ways;
        unsigned short sets;
        unsigned int waysize;
        unsigned int waybit;
        unsigned int flags;
};




#define MIPS_CACHE_NOT_PRESENT 0x00000001
#define MIPS_CACHE_VTAG 0x00000002
#define MIPS_CACHE_ALIASES 0x00000004
#define MIPS_CACHE_IC_F_DC 0x00000008

struct cpuinfo_mips {
        unsigned long udelay_val;
        unsigned long *pgd_quick;
        unsigned long *pte_quick;
        unsigned long pgtable_cache_sz;
        unsigned long asid_cache;



        unsigned long options;
        unsigned int processor_id;
        unsigned int fpu_id;
        unsigned int cputype;
        int isa_level;
        int tlbsize;
        struct cache_desc icache;
        struct cache_desc dcache;
        struct cache_desc scache;
        struct cache_desc tcache;
} __attribute__((aligned(32)));





#define cpu_has_tlb (cpu_data[0].options & MIPS_CPU_TLB)
#define cpu_has_4kex (cpu_data[0].options & MIPS_CPU_4KEX)
#define cpu_has_4ktlb (cpu_data[0].options & MIPS_CPU_4KTLB)
#define cpu_has_fpu (cpu_data[0].options & MIPS_CPU_FPU)
#define cpu_has_32fpr (cpu_data[0].options & MIPS_CPU_32FPR)
#define cpu_has_counter (cpu_data[0].options & MIPS_CPU_COUNTER)
#define cpu_has_watch (cpu_data[0].options & MIPS_CPU_WATCH)
#define cpu_has_mips16 (cpu_data[0].options & MIPS_CPU_MIPS16)
#define cpu_has_divec (cpu_data[0].options & MIPS_CPU_DIVEC)
#define cpu_has_vce (cpu_data[0].options & MIPS_CPU_VCE)
#define cpu_has_cache_cdex_p (cpu_data[0].options & MIPS_CPU_CACHE_CDEX_P)
#define cpu_has_cache_cdex_s (cpu_data[0].options & MIPS_CPU_CACHE_CDEX_S)
#define cpu_has_prefetch (cpu_data[0].options & MIPS_CPU_PREFETCH)
#define cpu_has_mcheck (cpu_data[0].options & MIPS_CPU_MCHECK)
#define cpu_has_ejtag (cpu_data[0].options & MIPS_CPU_EJTAG)
#define cpu_has_nofpuex (cpu_data[0].options & MIPS_CPU_NOFPUEX)
#define cpu_has_llsc (cpu_data[0].options & MIPS_CPU_LLSC)
#define cpu_has_vtag_icache (cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
#define cpu_has_dc_aliases (cpu_data[0].dcache.flags & MIPS_CACHE_ALIASES)
#define cpu_has_ic_fills_f_dc (cpu_data[0].dcache.flags & MIPS_CACHE_IC_F_DC)
#define cpu_has_64bits (cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
#define cpu_has_64bit_zero_reg (cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
#define cpu_has_64bit_gp_regs 0
#define cpu_has_64bit_addresses 0
#define cpu_has_subset_pcaches (cpu_data[0].options & MIPS_CPU_SUBSET_CACHES)

#define cpu_dcache_line_size() current_cpu_data.dcache.linesz
#define cpu_icache_line_size() current_cpu_data.icache.linesz
#define cpu_scache_line_size() current_cpu_data.scache.linesz

extern struct cpuinfo_mips cpu_data[];
#define current_cpu_data cpu_data[smp_processor_id()]

extern void cpu_probe(void);
extern void cpu_report(void);




extern void (*cpu_wait)(void);

extern unsigned int vced_count, vcei_count;







#define EISA_bus (0)


#define MCA_bus 0
#define MCA_bus__is_a_macro 







#define TASK_SIZE 0x7fff8000UL




#define TASK_UNMAPPED_BASE (TASK_SIZE / 3)




#define IO_BITMAP_SIZE 32

#define NUM_FPU_REGS 32

struct mips_fpu_hard_struct {
        double fp_regs[32];
        unsigned int control;
};







typedef u64 fpureg_t;
struct mips_fpu_soft_struct {
        fpureg_t regs[32];
        unsigned int sr;
};

union mips_fpu_union {
        struct mips_fpu_hard_struct hard;
        struct mips_fpu_soft_struct soft;
};

#define INIT_FPU { {{0,},} }



typedef struct {
        unsigned long seg;
} mm_segment_t;




struct thread_struct {

        unsigned long reg16;
        unsigned long reg17, reg18, reg19, reg20, reg21, reg22, reg23;
        unsigned long reg29, reg30, reg31;


        unsigned long cp0_status;


        union mips_fpu_union fpu;


        unsigned long cp0_badvaddr;
        unsigned long cp0_baduaddr;
        unsigned long error_code;
        unsigned long trap_no;
#define MF_FIXADE 1
#define MF_LOGADE 2
        unsigned long mflags;
        mm_segment_t current_ds;
        unsigned long irix_trampoline;
        unsigned long irix_oldctx;
};



#define INIT_THREAD { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, INIT_FPU, 0, 0, 0, 0, MF_FIXADE, { 0 }, 0, 0 }
# 239 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h"
#define KERNEL_STACK_SIZE 0x2000




#define release_thread(thread) do { } while(0)

extern int arch_kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);


#define copy_segments(p,mm) do { } while(0)
#define release_segments(mm) do { } while(0)

struct mips_frame_info {
        int frame_offset;
        int pc_offset;
};
extern struct mips_frame_info schedule_frame;



static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long thread_saved_pc(struct thread_struct *t)
{
        extern void ret_from_fork(void);


        if (t->reg31 == (unsigned long) ret_from_fork)
                return t->reg31;

        if (schedule_frame.pc_offset < 0)
                return 0;
        return ((unsigned long *)t->reg29)[schedule_frame.pc_offset];
}




extern void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp);

struct task_struct;
unsigned long get_wchan(struct task_struct *p);

#define __PT_REG(reg) ((long)&((struct pt_regs *)0)->reg - sizeof(struct pt_regs))
#define __KSTK_TOS(tsk) ((unsigned long)(tsk) + KERNEL_STACK_SIZE - 32)
#define KSTK_EIP(tsk) (*(unsigned long *)(__KSTK_TOS(tsk) + __PT_REG(cp0_epc)))
#define KSTK_ESP(tsk) (*(unsigned long *)(__KSTK_TOS(tsk) + __PT_REG(regs[29])))
#define KSTK_STATUS(tsk) (*(unsigned long *)(__KSTK_TOS(tsk) + __PT_REG(cp0_status)))





#define THREAD_ORDER (PAGE_SHIFT >= 14 ? 0 : 1)
#define THREAD_SIZE (PAGE_SIZE << THREAD_ORDER)
#define THREAD_MASK (THREAD_SIZE - 1UL)
#define alloc_task_struct() ((struct task_struct *) __get_free_pages(GFP_KERNEL,1))

#define free_task_struct(p) free_pages((unsigned long)(p),1)
#define get_task_struct(tsk) atomic_inc(&virt_to_page(tsk)->count)

#define init_task (init_task_union.task)
#define init_stack (init_task_union.stack)

#define cpu_relax() barrier()
# 319 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/processor.h"
#define return_address() ({__asm__ __volatile__("":::"$31");__builtin_return_address(0);})
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/prefetch.h" 2
# 42 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/prefetch.h"
#define ARCH_HAS_PREFETCH 
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void prefetch(const void *x) {;}



#define ARCH_HAS_PREFETCHW 
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void prefetchw(const void *x) {;}



#define ARCH_HAS_SPINLOCK_PREFETCH 
#define spin_lock_prefetch(x) prefetchw(x)



#define PREFETCH_STRIDE (4*L1_CACHE_BYTES)
# 7 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h" 2
# 18 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h"
struct list_head {
        struct list_head *next, *prev;
};

#define LIST_HEAD_INIT(name) { &(name), &(name) }

#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)


#define INIT_LIST_HEAD(ptr) do { (ptr)->next = (ptr); (ptr)->prev = (ptr); } while (0)
# 37 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __list_add(struct list_head *new,
                              struct list_head *prev,
                              struct list_head *next)
{
        next->prev = new;
        new->next = next;
        new->prev = prev;
        prev->next = new;
}
# 55 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void list_add(struct list_head *new, struct list_head *head)
{
        __list_add(new, head, head->next);
}
# 68 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void list_add_tail(struct list_head *new, struct list_head *head)
{
        __list_add(new, head->prev, head);
}
# 80 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __list_del(struct list_head *prev, struct list_head *next)
{
        next->prev = prev;
        prev->next = next;
}






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void list_del(struct list_head *entry)
{
        __list_del(entry->prev, entry->next);
        entry->next = (void *) 0;
        entry->prev = (void *) 0;
}





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void list_del_init(struct list_head *entry)
{
        __list_del(entry->prev, entry->next);
        do { (entry)->next = (entry); (entry)->prev = (entry); } while (0);
}






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void list_move(struct list_head *list, struct list_head *head)
{
        __list_del(list->prev, list->next);
        list_add(list, head);
}






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void list_move_tail(struct list_head *list,
                                  struct list_head *head)
{
        __list_del(list->prev, list->next);
        list_add_tail(list, head);
}





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int list_empty(struct list_head *head)
{
        return head->next == head;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __list_splice(struct list_head *list,
                                 struct list_head *head)
{
        struct list_head *first = list->next;
        struct list_head *last = list->prev;
        struct list_head *at = head->next;

        first->prev = head;
        head->next = first;

        last->next = at;
        at->prev = last;
}






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void list_splice(struct list_head *list, struct list_head *head)
{
        if (!list_empty(list))
                __list_splice(list, head);
}
# 172 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void list_splice_init(struct list_head *list,
                                    struct list_head *head)
{
        if (!list_empty(list)) {
                __list_splice(list, head);
                do { (list)->next = (list); (list)->prev = (list); } while (0);
        }
}







#define list_entry(ptr,type,member) ((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))







#define list_for_each(pos,head) for (pos = (head)->next, prefetch(pos->next); pos != (head); pos = pos->next, prefetch(pos->next))







#define list_for_each_prev(pos,head) for (pos = (head)->prev, prefetch(pos->prev); pos != (head); pos = pos->prev, prefetch(pos->prev))
# 213 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h"
#define list_for_each_safe(pos,n,head) for (pos = (head)->next, n = pos->next; pos != (head); pos = n, n = pos->next)
# 223 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h"
#define list_for_each_entry(pos,head,member) for (pos = list_entry((head)->next, typeof(*pos), member), prefetch(pos->member.next); &pos->member != (head); pos = list_entry(pos->member.next, typeof(*pos), member), prefetch(pos->member.next))
# 237 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h"
#define list_for_each_entry_safe(pos,n,head,member) for (pos = list_entry((head)->next, typeof(*pos), member), n = list_entry(pos->member.next, typeof(*pos), member); &pos->member != (head); pos = n, n = list_entry(n->member.next, typeof(*n), member))
# 250 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/list.h"
#define list_for_each_entry_continue(pos,head,member) for (pos = list_entry(pos->member.next, typeof(*pos), member), prefetch(pos->member.next); &pos->member != (head); pos = list_entry(pos->member.next, typeof(*pos), member), prefetch(pos->member.next))
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/module.h" 2
# 26 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/module.h"
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h" 1
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h"
#define __ASM_ATOMIC_H 



typedef struct { volatile int counter; } atomic_t;


#define ATOMIC_INIT(i) { (i) }
# 31 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h"
#define atomic_read(v) ((v)->counter)
# 41 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h"
#define atomic_set(v,i) ((v)->counter = (i))
# 127 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h"
static __inline__ __attribute__((always_inline)) void atomic_add(int i, atomic_t * v)
{
        unsigned long temp;

        __asm__ __volatile__(
                "1:   ll      %0, %1      # atomic_add\n"
                "     addu    %0, %2                  \n"
                "     sc      %0, %1                  \n"
                "     beqz    %0, 1b                  \n"
                : "=&r" (temp), "=m" (v->counter)
                : "Ir" (i), "m" (v->counter));
}
# 148 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h"
static __inline__ __attribute__((always_inline)) void atomic_sub(int i, atomic_t * v)
{
        unsigned long temp;

        __asm__ __volatile__(
                "1:   ll      %0, %1      # atomic_sub\n"
                "     subu    %0, %2                  \n"
                "     sc      %0, %1                  \n"
                "     beqz    %0, 1b                  \n"
                : "=&r" (temp), "=m" (v->counter)
                : "Ir" (i), "m" (v->counter));
}




static __inline__ __attribute__((always_inline)) int atomic_add_return(int i, atomic_t * v)
{
        unsigned long temp, result;

        __asm__ __volatile__(
                ".set push               # atomic_add_return\n"
                ".set noreorder                             \n"
                "1:   ll      %1, %2                        \n"
                "     addu    %0, %1, %3                    \n"
                "     sc      %0, %2                        \n"
                "     beqz    %0, 1b                        \n"
                "     addu    %0, %1, %3                    \n"
                "     sync                                  \n"
                ".set pop                                   \n"
                : "=&r" (result), "=&r" (temp), "=m" (v->counter)
                : "Ir" (i), "m" (v->counter)
                : "memory");

        return result;
}

static __inline__ __attribute__((always_inline)) int atomic_sub_return(int i, atomic_t * v)
{
        unsigned long temp, result;

        __asm__ __volatile__(
                ".set push                                   \n"
                ".set noreorder           # atomic_sub_return\n"
                "1:   ll    %1, %2                           \n"
                "     subu  %0, %1, %3                       \n"
                "     sc    %0, %2                           \n"
                "     beqz  %0, 1b                           \n"
                "     subu  %0, %1, %3                       \n"
                "     sync                                   \n"
                ".set pop                                    \n"
                : "=&r" (result), "=&r" (temp), "=m" (v->counter)
                : "Ir" (i), "m" (v->counter)
                : "memory");

        return result;
}


#define atomic_dec_return(v) atomic_sub_return(1,(v))
#define atomic_inc_return(v) atomic_add_return(1,(v))
# 220 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h"
#define atomic_sub_and_test(i,v) (atomic_sub_return((i), (v)) == 0)
# 231 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h"
#define atomic_inc_and_test(v) (atomic_inc_return(v) == 0)
# 242 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h"
#define atomic_dec_and_test(v) (atomic_sub_return(1, (v)) == 0)
# 251 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h"
#define atomic_inc(v) atomic_add(1,(v))
# 260 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h"
#define atomic_dec(v) atomic_sub(1,(v))
# 272 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/atomic.h"
#define atomic_add_negative(i,v) (atomic_add_return(i, (v)) < 0)


#define smp_mb__before_atomic_dec() smp_mb()
#define smp_mb__after_atomic_dec() smp_mb()
#define smp_mb__before_atomic_inc() smp_mb()
#define smp_mb__after_atomic_inc() smp_mb()
# 27 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/module.h" 2


struct exception_table_entry;


struct kernel_sym
{
        unsigned long value;
        char name[60];
};

struct module_symbol
{
        unsigned long value;
        const char *name;
};

struct module_ref
{
        struct module *dep;
        struct module *ref;
        struct module_ref *next_ref;
};


struct module_persist;

struct module
{
        unsigned long size_of_struct;
        struct module *next;
        const char *name;
        unsigned long size;

        union
        {
                atomic_t usecount;
                long pad;
        } uc;

        unsigned long flags;

        unsigned nsyms;
        unsigned ndeps;

        struct module_symbol *syms;
        struct module_ref *deps;
        struct module_ref *refs;
        int (*init)(void);
        void (*cleanup)(void);
        const struct exception_table_entry *ex_table_start;
        const struct exception_table_entry *ex_table_end;






        const struct module_persist *persist_start;
        const struct module_persist *persist_end;
        int (*can_unload)(void);
        int runsize;
        const char *kallsyms_start;
        const char *kallsyms_end;
        const char *archdata_start;
        const char *archdata_end;
        const char *kernel_data;
};

struct module_info
{
        unsigned long addr;
        unsigned long size;
        unsigned long flags;
        long usecount;
};



#define MOD_UNINITIALIZED 0
#define MOD_RUNNING 1
#define MOD_DELETED 2
#define MOD_AUTOCLEAN 4
#define MOD_VISITED 8
#define MOD_USED_ONCE 16
#define MOD_JUST_FREED 32
#define MOD_INITIALIZING 64



#define QM_MODULES 1
#define QM_DEPS 2
#define QM_REFS 3
#define QM_SYMBOLS 4
#define QM_INFO 5


#define MOD_CAN_QUERY(mod) (((mod)->flags & (MOD_RUNNING | MOD_INITIALIZING)) && !((mod)->flags & MOD_DELETED))





#define mod_member_present(mod,member) ((unsigned long)(&((struct module *)0L)->member + 1) <= (mod)->size_of_struct)







#define mod_archdata_member_present(mod,type,member) (((unsigned long)(&((type *)0L)->member) + sizeof(((type *)0L)->member)) <= ((mod)->archdata_end - (mod)->archdata_start))






#define mod_bound(p,n,m) ((unsigned long)(p) >= ((unsigned long)(m) + ((m)->size_of_struct)) && (unsigned long)((p)+(n)) <= (unsigned long)(m) + (m)->size)




#define GET_USE_COUNT(module) (atomic_read(&(module)->uc.usecount))



#define __MOD_INC_USE_COUNT(mod) (atomic_inc(&(mod)->uc.usecount), (mod)->flags |= MOD_VISITED|MOD_USED_ONCE)

#define __MOD_DEC_USE_COUNT(mod) (atomic_dec(&(mod)->uc.usecount), (mod)->flags |= MOD_VISITED)

#define __MOD_IN_USE(mod) (mod_member_present((mod), can_unload) && (mod)->can_unload ? (mod)->can_unload() : atomic_read(&(mod)->uc.usecount))





#define __MODULE_STRING_1(x) #x
#define __MODULE_STRING(x) __MODULE_STRING_1(x)
# 183 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/module.h"
#define HAVE_INTER_MODULE 
extern void inter_module_register(const char *, struct module *, const void *);
extern void inter_module_unregister(const char *);
extern const void *inter_module_get(const char *);
extern const void *inter_module_get_request(const char *, const char *);
extern void inter_module_put(const char *);

struct inter_module_entry {
        struct list_head list;
        const char *im_name;
        struct module *owner;
        const void *userdata;
};

extern int try_inc_mod_count(struct module *mod);
# 309 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/module.h"
#define MODULE_AUTHOR(name) 
#define MODULE_LICENSE(license) 
#define MODULE_DESCRIPTION(desc) 
#define MODULE_SUPPORTED_DEVICE(name) 
#define MODULE_PARM(var,type) 
#define MODULE_PARM_DESC(var,desc) 






#define MODULE_GENERIC_TABLE(gtype,name) static const struct gtype ##_id * __module_ ##gtype ##_table __attribute_used__ __attribute__ ((__section__(".data.exit"))) = name





#define THIS_MODULE NULL
#define MOD_INC_USE_COUNT do { } while (0)
#define MOD_DEC_USE_COUNT do { } while (0)
#define MOD_IN_USE 1

extern struct module *module_list;





#define MODULE_DEVICE_TABLE(type,name) MODULE_GENERIC_TABLE(type ##_device,name)
# 370 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/module.h"
#define __EXPORT_SYMBOL(sym,str) error this_object_must_be_defined_as_export_objs_in_the_Makefile
#define EXPORT_SYMBOL(var) error this_object_must_be_defined_as_export_objs_in_the_Makefile
#define EXPORT_SYMBOL_NOVERS(var) error this_object_must_be_defined_as_export_objs_in_the_Makefile
#define EXPORT_SYMBOL_GPL(var) error this_object_must_be_defined_as_export_objs_in_the_Makefile
# 407 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/module.h"
#define EXPORT_NO_SYMBOLS 



#define SET_MODULE_OWNER(some_struct) do { (some_struct)->owner = THIS_MODULE; } while (0)
# 180 "drivers/char/serial.c" 2





# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serial.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serial.h"
#define _LINUX_SERIAL_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/page.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/page.h"
#define __ASM_PAGE_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/break.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/break.h"
#define __ASM_BREAK_H 







#define BRK_USERBP 0
#define BRK_KERNELBP 1
#define BRK_ABORT 2
#define BRK_BD_TAKEN 3
#define BRK_BD_NOTTAKEN 4
#define BRK_SSTEPBP 5
#define BRK_OVERFLOW 6
#define BRK_DIVZERO 7
#define BRK_RANGE 8
#define BRK_STACKOVERFLOW 9
#define BRK_NORLD 10
#define _BRK_THREADBP 11
#define BRK_MULOVF 1023
#define BRK_BUG 512
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/page.h" 2
# 25 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/page.h"
#define PAGE_SHIFT 14




#define PAGE_SIZE (1L << PAGE_SHIFT)
#define PAGE_MASK (~(PAGE_SIZE-1))



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/cacheflush.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/cacheflush.h"
#define __ASM_CACHEFLUSH_H 



struct mm_struct;
struct vm_area_struct;
struct page;
# 33 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/cacheflush.h"
extern void (*_flush_cache_all)(void);
extern void (*___flush_cache_all)(void);
extern void (*_flush_cache_mm)(struct mm_struct *mm);
extern void (*_flush_cache_range)(struct mm_struct *mm, unsigned long start,
        unsigned long end);
extern void (*_flush_cache_page)(struct vm_area_struct *vma,
        unsigned long page);
extern void flush_dcache_page(struct page * page);
extern void (*_flush_icache_range)(unsigned long start, unsigned long end);
extern void (*_flush_icache_page)(struct vm_area_struct *vma,
        struct page *page);

extern void (*_flush_cache_sigtramp)(unsigned long addr);
extern void (*_flush_icache_all)(void);
extern void (*_flush_data_cache_page)(unsigned long addr);

#define flush_cache_all() _flush_cache_all()
#define __flush_cache_all() ___flush_cache_all()
#define flush_cache_mm(mm) _flush_cache_mm(mm)
#define flush_cache_range(mm,start,end) _flush_cache_range(mm,start,end)
#define flush_cache_page(vma,page) _flush_cache_page(vma, page)
#define flush_page_to_ram(page) do { } while (0)

#define flush_icache_range(start,end) _flush_icache_range(start,end)
#define flush_icache_user_range(vma,page,addr,len) _flush_icache_page((vma), (page))

#define flush_icache_page(vma,page) _flush_icache_page(vma, page)

#define flush_cache_sigtramp(addr) _flush_cache_sigtramp(addr)
#define flush_data_cache_page(addr) _flush_data_cache_page(addr)



#define flush_icache_all() do { } while(0)
# 36 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/page.h" 2

#define BUG() do { __asm__ __volatile__("break %0" : : "i" (BRK_BUG)); } while (0)




#define PAGE_BUG(page) do { BUG(); } while (0)

extern void clear_page(void * page);
extern void copy_page(void * to, void * from);

extern unsigned long shm_align_mask;

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long pages_do_alias(unsigned long addr1,
        unsigned long addr2)
{
        return (addr1 ^ addr2) & shm_align_mask;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void clear_user_page(void *page, unsigned long vaddr)
{
        unsigned long kaddr = (unsigned long) page;

        clear_page(page);
        if (pages_do_alias(kaddr, vaddr))
                _flush_data_cache_page(kaddr);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void copy_user_page(void * to, void * from, unsigned long vaddr)
{
        unsigned long kto = (unsigned long) to;

        copy_page(to, from);
        if (pages_do_alias(kto, vaddr))
                _flush_data_cache_page(kto);
}
# 87 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/page.h"
typedef struct { unsigned long pte_low; } pte_t;
#define pte_val(x) ((x).pte_low)
#define __pte(x) ((pte_t) { (x) } )


typedef struct { unsigned long pmd; } pmd_t;
typedef struct { unsigned long pgd; } pgd_t;
typedef struct { unsigned long pgprot; } pgprot_t;

#define pmd_val(x) ((x).pmd)
#define pgd_val(x) ((x).pgd)
#define pgprot_val(x) ((x).pgprot)

#define ptep_buddy(x) ((pte_t *)((unsigned long)(x) ^ sizeof(pte_t)))

#define __pmd(x) ((pmd_t) { (x) } )
#define __pgd(x) ((pgd_t) { (x) } )
#define __pgprot(x) ((pgprot_t) { (x) } )


static __inline__ __attribute__((always_inline)) int get_order(unsigned long size)
{
        int order;

        size = (size-1) >> (14 -1);
        order = -1;
        do {
                size >>= 1;
                order++;
        } while (size);
        return order;
}




#define PAGE_ALIGN(addr) (((addr) + PAGE_SIZE - 1) & PAGE_MASK)





#define PAGE_OFFSET 0x80000000UL
#define UNCAC_BASE 0xa0000000UL

#define __pa(x) ((unsigned long) (x) - PAGE_OFFSET)
#define __va(x) ((void *)((unsigned long) (x) + PAGE_OFFSET))
#define virt_to_page(kaddr) (mem_map + (__pa(kaddr) >> PAGE_SHIFT))
#define VALID_PAGE(page) ((page - mem_map) < max_mapnr)

#define VM_DATA_DEFAULT_FLAGS (VM_READ | VM_WRITE | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)


#define UNCAC_ADDR(addr) ((addr) - PAGE_OFFSET + UNCAC_BASE)
#define CAC_ADDR(addr) ((addr) - UNCAC_BASE + PAGE_OFFSET)




#define HIGHMEM_START 0x20000000UL
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serial.h" 2





struct async_icount {
        __u32 cts, dsr, rng, dcd, tx, rx;
        __u32 frame, parity, overrun, brk;
        __u32 buf_overrun;
};




#define SERIAL_XMIT_SIZE PAGE_SIZE



struct serial_struct {
        int type;
        int line;
        unsigned int port;
        int irq;
        int flags;
        int xmit_fifo_size;
        int custom_divisor;
        int baud_base;
        unsigned short close_delay;
        char io_type;
        char reserved_char[1];
        int hub6;
        unsigned short closing_wait;
        unsigned short closing_wait2;
        unsigned char *iomem_base;
        unsigned short iomem_reg_shift;
        unsigned int port_high;
        int reserved[1];
};





#define ASYNC_CLOSING_WAIT_INF 0
#define ASYNC_CLOSING_WAIT_NONE 65535




#define PORT_UNKNOWN 0
#define PORT_8250 1
#define PORT_16450 2
#define PORT_16550 3
#define PORT_16550A 4
#define PORT_CIRRUS 5
#define PORT_16650 6
#define PORT_16650V2 7
#define PORT_16750 8
#define PORT_STARTECH 9
#define PORT_16C950 10
#define PORT_16654 11
#define PORT_16850 12
#define PORT_RSA 13
#define PORT_MAX 13

#define SERIAL_IO_PORT 0
#define SERIAL_IO_HUB6 1
#define SERIAL_IO_MEM 2

struct serial_uart_config {
        char *name;
        int dfl_xmit_fifo_size;
        int flags;
};

#define UART_CLEAR_FIFO 0x01
#define UART_USE_FIFO 0x02
#define UART_STARTECH 0x04




#define ASYNC_HUP_NOTIFY 0x0001

#define ASYNC_FOURPORT 0x0002
#define ASYNC_SAK 0x0004
#define ASYNC_SPLIT_TERMIOS 0x0008

#define ASYNC_SPD_MASK 0x1030
#define ASYNC_SPD_HI 0x0010

#define ASYNC_SPD_VHI 0x0020
#define ASYNC_SPD_CUST 0x0030

#define ASYNC_SKIP_TEST 0x0040
#define ASYNC_AUTO_IRQ 0x0080
#define ASYNC_SESSION_LOCKOUT 0x0100
#define ASYNC_PGRP_LOCKOUT 0x0200
#define ASYNC_CALLOUT_NOHUP 0x0400

#define ASYNC_HARDPPS_CD 0x0800

#define ASYNC_SPD_SHI 0x1000
#define ASYNC_SPD_WARP 0x1010

#define ASYNC_LOW_LATENCY 0x2000

#define ASYNC_BUGGY_UART 0x4000


#define ASYNC_AUTOPROBE 0x8000

#define ASYNC_FLAGS 0x7FFF
#define ASYNC_USR_MASK 0x3430



#define ASYNC_INITIALIZED 0x80000000
#define ASYNC_CALLOUT_ACTIVE 0x40000000
#define ASYNC_NORMAL_ACTIVE 0x20000000
#define ASYNC_BOOT_AUTOCONF 0x10000000
#define ASYNC_CLOSING 0x08000000
#define ASYNC_CTS_FLOW 0x04000000
#define ASYNC_CHECK_CD 0x02000000
#define ASYNC_SHARE_IRQ 0x01000000

#define ASYNC_CONS_FLOW 0x00800000

#define ASYNC_BOOT_ONLYMCA 0x00400000
#define ASYNC_INTERNAL_FLAGS 0xFFC00000




struct serial_multiport_struct {
        int irq;
        int port1;
        unsigned char mask1, match1;
        int port2;
        unsigned char mask2, match2;
        int port3;
        unsigned char mask3, match3;
        int port4;
        unsigned char mask4, match4;
        int port_monitor;
        int reserved[32];
};





struct serial_icounter_struct {
        int cts, dsr, rng, dcd;
        int rx, tx;
        int frame, overrun, parity, brk;
        int buf_overrun;
        int reserved[9];
};




extern int register_serial(struct serial_struct *req);
extern void unregister_serial(int line);


extern int early_serial_setup(struct serial_struct *req);


#define HCDP_SERIAL_CONSOLE_PORT 4
# 186 "drivers/char/serial.c" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serialP.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serialP.h"
#define _LINUX_SERIALP_H 
# 23 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serialP.h"
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/termios.h" 1

#define _LINUX_TERMIOS_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/termios.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/termios.h"
#define _ASM_TERMIOS_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/termbits.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/termbits.h"
#define _ASM_TERMBITS_H 



typedef unsigned char cc_t;
typedef unsigned long speed_t;
typedef unsigned long tcflag_t;





#define NCCS 23
struct termios {
        tcflag_t c_iflag;
        tcflag_t c_oflag;
        tcflag_t c_cflag;
        tcflag_t c_lflag;



        cc_t c_line;
        cc_t c_cc[23];
};


#define VINTR 0
#define VQUIT 1
#define VERASE 2
#define VKILL 3
#define VMIN 4
#define VTIME 5
#define VEOL2 6
#define VSWTC 7
#define VSWTCH VSWTC
#define VSTART 8
#define VSTOP 9
#define VSUSP 10






#define VREPRINT 12
#define VDISCARD 13
#define VWERASE 14
#define VLNEXT 15
#define VEOF 16
#define VEOL 17


#define IGNBRK 0000001
#define BRKINT 0000002
#define IGNPAR 0000004
#define PARMRK 0000010
#define INPCK 0000020
#define ISTRIP 0000040
#define INLCR 0000100
#define IGNCR 0000200
#define ICRNL 0000400
#define IUCLC 0001000
#define IXON 0002000
#define IXANY 0004000
#define IXOFF 0010000
#define IMAXBEL 0020000


#define OPOST 0000001
#define OLCUC 0000002
#define ONLCR 0000004
#define OCRNL 0000010
#define ONOCR 0000020
#define ONLRET 0000040
#define OFILL 0000100
#define OFDEL 0000200
#define NLDLY 0000400
#define NL0 0000000
#define NL1 0000400
#define CRDLY 0003000
#define CR0 0000000
#define CR1 0001000
#define CR2 0002000
#define CR3 0003000
#define TABDLY 0014000
#define TAB0 0000000
#define TAB1 0004000
#define TAB2 0010000
#define TAB3 0014000
#define XTABS 0014000
#define BSDLY 0020000
#define BS0 0000000
#define BS1 0020000
#define VTDLY 0040000
#define VT0 0000000
#define VT1 0040000
#define FFDLY 0100000
#define FF0 0000000
#define FF1 0100000






#define CBAUD 0010017
#define B0 0000000
#define B50 0000001
#define B75 0000002
#define B110 0000003
#define B134 0000004
#define B150 0000005
#define B200 0000006
#define B300 0000007
#define B600 0000010
#define B1200 0000011
#define B1800 0000012
#define B2400 0000013
#define B4800 0000014
#define B9600 0000015
#define B19200 0000016
#define B38400 0000017
#define EXTA B19200
#define EXTB B38400
#define CSIZE 0000060
#define CS5 0000000
#define CS6 0000020
#define CS7 0000040
#define CS8 0000060
#define CSTOPB 0000100
#define CREAD 0000200
#define PARENB 0000400
#define PARODD 0001000
#define HUPCL 0002000
#define CLOCAL 0004000
#define CBAUDEX 0010000
#define B57600 0010001
#define B115200 0010002
#define B230400 0010003
#define B460800 0010004
#define B500000 0010005
#define B576000 0010006
#define B921600 0010007
#define B1000000 0010010
#define B1152000 0010011
#define B1500000 0010012
#define B2000000 0010013
#define B2500000 0010014
#define B3000000 0010015
#define B3500000 0010016
#define B4000000 0010017
#define CIBAUD 002003600000
#define CMSPAR 010000000000
#define CRTSCTS 020000000000


#define ISIG 0000001
#define ICANON 0000002
#define XCASE 0000004
#define ECHO 0000010
#define ECHOE 0000020
#define ECHOK 0000040
#define ECHONL 0000100
#define NOFLSH 0000200
#define IEXTEN 0000400
#define ECHOCTL 0001000
#define ECHOPRT 0002000
#define ECHOKE 0004000
#define FLUSHO 0020000
#define PENDIN 0040000
#define TOSTOP 0100000
#define ITOSTOP TOSTOP


#define TIOCSER_TEMT 0x01


#define TCOOFF 0
#define TCOON 1
#define TCIOFF 2
#define TCION 3


#define TCIFLUSH 0
#define TCOFLUSH 1
#define TCIOFLUSH 2


#define TCSANOW TCSETS
#define TCSADRAIN TCSETSW
#define TCSAFLUSH TCSETSF
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/termios.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ioctls.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ioctls.h"
#define __ASM_IOCTLS_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ioctl.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ioctl.h"
#define __ASM_MIPS_IOCTL_H 
# 27 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ioctl.h"
#define _IOC_NRBITS 8
#define _IOC_TYPEBITS 8
#define _IOC_SIZEBITS 13
#define _IOC_DIRBITS 3

#define _IOC_NRMASK ((1 << _IOC_NRBITS)-1)
#define _IOC_TYPEMASK ((1 << _IOC_TYPEBITS)-1)
#define _IOC_SIZEMASK ((1 << _IOC_SIZEBITS)-1)
#define _IOC_DIRMASK ((1 << _IOC_DIRBITS)-1)

#define _IOC_NRSHIFT 0
#define _IOC_TYPESHIFT (_IOC_NRSHIFT+_IOC_NRBITS)
#define _IOC_SIZESHIFT (_IOC_TYPESHIFT+_IOC_TYPEBITS)
#define _IOC_DIRSHIFT (_IOC_SIZESHIFT+_IOC_SIZEBITS)






#define _IOC_NONE 1U
#define _IOC_READ 2U
#define _IOC_WRITE 4U




#define _IOC_VOID 0x20000000
#define _IOC_OUT 0x40000000
#define _IOC_IN 0x80000000
#define _IOC_INOUT (IOC_IN|IOC_OUT)

#define _IOC(dir,type,nr,size) (((dir) << _IOC_DIRSHIFT) | ((type) << _IOC_TYPESHIFT) | ((nr) << _IOC_NRSHIFT) | ((size) << _IOC_SIZESHIFT))






#define _IO(type,nr) _IOC(_IOC_NONE,(type),(nr),0)
#define _IOR(type,nr,size) _IOC(_IOC_READ,(type),(nr),sizeof(size))
#define _IOW(type,nr,size) _IOC(_IOC_WRITE,(type),(nr),sizeof(size))
#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))


#define _IOC_DIR(nr) (((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
#define _IOC_TYPE(nr) (((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
#define _IOC_NR(nr) (((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
#define _IOC_SIZE(nr) (((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)



#define IOC_IN (_IOC_WRITE << _IOC_DIRSHIFT)
#define IOC_OUT (_IOC_READ << _IOC_DIRSHIFT)
#define IOC_INOUT ((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
#define IOCSIZE_MASK (_IOC_SIZEMASK << _IOC_SIZESHIFT)
#define IOCSIZE_SHIFT (_IOC_SIZESHIFT)
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ioctls.h" 2

#define TCGETA 0x5401
#define TCSETA 0x5402
#define TCSETAW 0x5403
#define TCSETAF 0x5404

#define TCSBRK 0x5405
#define TCXONC 0x5406
#define TCFLSH 0x5407

#define TCGETS 0x540d
#define TCSETS 0x540e
#define TCSETSW 0x540f
#define TCSETSF 0x5410

#define TIOCEXCL 0x740d
#define TIOCNXCL 0x740e
#define TIOCOUTQ 0x7472
#define TIOCSTI 0x5472
#define TIOCMGET 0x741d
#define TIOCMBIS 0x741b
#define TIOCMBIC 0x741c
#define TIOCMSET 0x741a
#define TIOCPKT 0x5470
#define TIOCPKT_DATA 0x00
#define TIOCPKT_FLUSHREAD 0x01
#define TIOCPKT_FLUSHWRITE 0x02
#define TIOCPKT_STOP 0x04
#define TIOCPKT_START 0x08
#define TIOCPKT_NOSTOP 0x10
#define TIOCPKT_DOSTOP 0x20

#define TIOCSWINSZ _IOW('t', 103, struct winsize)
#define TIOCGWINSZ _IOR('t', 104, struct winsize)
#define TIOCNOTTY 0x5471
#define TIOCSETD 0x7401
#define TIOCGETD 0x7400

#define FIOCLEX 0x6601
#define FIONCLEX 0x6602
#define FIOASYNC 0x667d
#define FIONBIO 0x667e
#define FIOQSIZE 0x667f

#define TIOCGLTC 0x7474
#define TIOCSLTC 0x7475
#define TIOCSPGRP _IOW('t', 118, int)
#define TIOCGPGRP _IOR('t', 119, int)
#define TIOCCONS _IOW('t', 120, int)

#define FIONREAD 0x467f
#define TIOCINQ FIONREAD

#define TIOCGETP 0x7408
#define TIOCSETP 0x7409
#define TIOCSETN 0x740a
# 78 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ioctls.h"
#define TIOCSCTTY 0x5480
#define TIOCGSOFTCAR 0x5481
#define TIOCSSOFTCAR 0x5482
#define TIOCLINUX 0x5483
#define TIOCGSERIAL 0x5484
#define TIOCSSERIAL 0x5485

#define TCSBRKP 0x5486
#define TIOCTTYGSTRUCT 0x5487
#define TIOCSBRK 0x5427
#define TIOCCBRK 0x5428
#define TIOCGSID 0x7416
#define TIOCGPTN _IOR('T',0x30, unsigned int)
#define TIOCSPTLCK _IOW('T',0x31, int)

#define TIOCSERCONFIG 0x5488
#define TIOCSERGWILD 0x5489
#define TIOCSERSWILD 0x548a
#define TIOCGLCKTRMIOS 0x548b
#define TIOCSLCKTRMIOS 0x548c
#define TIOCSERGSTRUCT 0x548d
#define TIOCSERGETLSR 0x548e
#define TIOCSERGETMULTI 0x548f
#define TIOCSERSETMULTI 0x5490
#define TIOCMIWAIT 0x5491
#define TIOCGICOUNT 0x5492
#define TIOCGHAYESESP 0x5493
#define TIOCSHAYESESP 0x5494
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/termios.h" 2

struct sgttyb {
        char sg_ispeed;
        char sg_ospeed;
        char sg_erase;
        char sg_kill;
        int sg_flags;
};

struct tchars {
        char t_intrc;
        char t_quitc;
        char t_startc;
        char t_stopc;
        char t_eofc;
        char t_brkc;
};

struct ltchars {
        char t_suspc;
        char t_dsuspc;
        char t_rprntc;
        char t_flushc;
        char t_werasc;
        char t_lnextc;
};




struct winsize {
        unsigned short ws_row;
        unsigned short ws_col;
        unsigned short ws_xpixel;
        unsigned short ws_ypixel;
};

#define NCC 8
struct termio {
        unsigned short c_iflag;
        unsigned short c_oflag;
        unsigned short c_cflag;
        unsigned short c_lflag;
        char c_line;
        unsigned char c_cc[23];
};
# 68 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/termios.h"
#define INIT_C_CC "\003\034\177\025\1\0\0\0\021\023\032\0\022\017\027\026\004\0"



#define TIOCM_LE 0x001
#define TIOCM_DTR 0x002
#define TIOCM_RTS 0x004
#define TIOCM_ST 0x010
#define TIOCM_SR 0x020
#define TIOCM_CTS 0x040
#define TIOCM_CAR 0x100
#define TIOCM_CD TIOCM_CAR
#define TIOCM_RNG 0x200
#define TIOCM_RI TIOCM_RNG
#define TIOCM_DSR 0x400
#define TIOCM_OUT1 0x2000
#define TIOCM_OUT2 0x4000
#define TIOCM_LOOP 0x8000

#define TIOCM_MODEM_BITS TIOCM_OUT2


#define N_TTY 0
#define N_SLIP 1
#define N_MOUSE 2
#define N_PPP 3
#define N_STRIP 4
#define N_AX25 5
#define N_X25 6
#define N_6PACK 7
#define N_MASC 8
#define N_R3964 9
#define N_PROFIBUS_FDL 10
#define N_IRDA 11
#define N_SMSBLOCK 12
#define N_HDLC 13
#define N_SYNC_PPP 14
#define N_HCI 15



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/string.h" 1

#define _LINUX_STRING_H_ 
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/string.h"
extern char * ___strtok;
extern char * strpbrk(const char *,const char *);
extern char * strtok(char *,const char *);
extern char * strsep(char **,const char *);
extern __kernel_size_t strspn(const char *,const char *);





# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/string.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/string.h"
#define __ASM_STRING_H 



#define __HAVE_ARCH_STRCPY 
static __inline__ __attribute__((always_inline)) char *strcpy(char *__dest, __const__ char *__src)
{
  char *__xdest = __dest;

  __asm__ __volatile__(
        ".set\tnoreorder\n\t"
        ".set\tnoat\n"
        "1:\tlbu\t$1,(%1)\n\t"
        "addiu\t%1,1\n\t"
        "sb\t$1,(%0)\n\t"
        "bnez\t$1,1b\n\t"
        "addiu\t%0,1\n\t"
        ".set\tat\n\t"
        ".set\treorder"
        : "=r" (__dest), "=r" (__src)
        : "0" (__dest), "1" (__src)
        : "memory");

  return __xdest;
}

#define __HAVE_ARCH_STRNCPY 
static __inline__ __attribute__((always_inline)) char *strncpy(char *__dest, __const__ char *__src, size_t __n)
{
  char *__xdest = __dest;

  if (__n == 0)
    return __xdest;

  __asm__ __volatile__(
        ".set\tnoreorder\n\t"
        ".set\tnoat\n"
        "1:\tlbu\t$1,(%1)\n\t"
        "subu\t%2,1\n\t"
        "sb\t$1,(%0)\n\t"
        "beqz\t$1,2f\n\t"
        "addiu\t%0,1\n\t"
        "bnez\t%2,1b\n\t"
        "addiu\t%1,1\n"
        "2:\n\t"
        ".set\tat\n\t"
        ".set\treorder"
        : "=r" (__dest), "=r" (__src), "=r" (__n)
        : "0" (__dest), "1" (__src), "2" (__n)
        : "memory");

  return __xdest;
}

#define __HAVE_ARCH_STRCMP 
static __inline__ __attribute__((always_inline)) int strcmp(__const__ char *__cs, __const__ char *__ct)
{
  int __res;

  __asm__ __volatile__(
        ".set\tnoreorder\n\t"
        ".set\tnoat\n\t"
        "lbu\t%2,(%0)\n"
        "1:\tlbu\t$1,(%1)\n\t"
        "addiu\t%0,1\n\t"
        "bne\t$1,%2,2f\n\t"
        "addiu\t%1,1\n\t"
        "bnez\t%2,1b\n\t"
        "lbu\t%2,(%0)\n\t"



        "move\t%2,$1\n"
        "2:\tsubu\t%2,$1\n"
        "3:\t.set\tat\n\t"
        ".set\treorder"
        : "=r" (__cs), "=r" (__ct), "=r" (__res)
        : "0" (__cs), "1" (__ct));

  return __res;
}

#define __HAVE_ARCH_STRNCMP 
static __inline__ __attribute__((always_inline)) int
strncmp(__const__ char *__cs, __const__ char *__ct, size_t __count)
{
        int __res;

        __asm__ __volatile__(
        ".set\tnoreorder\n\t"
        ".set\tnoat\n"
        "1:\tlbu\t%3,(%0)\n\t"
        "beqz\t%2,2f\n\t"
        "lbu\t$1,(%1)\n\t"
        "subu\t%2,1\n\t"
        "bne\t$1,%3,3f\n\t"
        "addiu\t%0,1\n\t"
        "bnez\t%3,1b\n\t"
        "addiu\t%1,1\n"
        "2:\n\t"



        "move\t%3,$1\n"
        "3:\tsubu\t%3,$1\n\t"
        ".set\tat\n\t"
        ".set\treorder"
        : "=r" (__cs), "=r" (__ct), "=r" (__count), "=r" (__res)
        : "0" (__cs), "1" (__ct), "2" (__count));

        return __res;
}

#define __HAVE_ARCH_MEMSET 
extern void *memset(void *__s, int __c, size_t __count);

#define __HAVE_ARCH_MEMCPY 
extern void *memcpy(void *__to, __const__ void *__from, size_t __n);

#define __HAVE_ARCH_MEMMOVE 
extern void *memmove(void *__dest, __const__ void *__src, size_t __n);


#define __HAVE_ARCH_BCOPY 

#define __HAVE_ARCH_MEMSCAN 
static __inline__ __attribute__((always_inline)) void *memscan(void *__addr, int __c, size_t __size)
{
        char *__end = (char *)__addr + __size;
        unsigned char __uc = (unsigned char) __c;

        __asm__(".set\tpush\n\t"
                ".set\tnoat\n\t"
                ".set\treorder\n\t"
                "1:\tbeq\t%0,%1,2f\n\t"
                "addiu\t%0,1\n\t"
                "lbu\t$1,-1(%0)\n\t"
                "bne\t$1,%z4,1b\n"
                "2:\t.set\tpop"
                : "=r" (__addr), "=r" (__end)
                : "0" (__addr), "1" (__end), "Jr" (__uc));

        return __addr;
}
# 27 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/string.h" 2
# 35 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/string.h"
extern char * strcat(char *, const char *);


extern char * strncat(char *, const char *, __kernel_size_t);
# 47 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/string.h"
extern int strnicmp(const char *, const char *, __kernel_size_t);


extern char * strchr(const char *,int);


extern char * strrchr(const char *,int);


extern char * strstr(const char *,const char *);


extern __kernel_size_t strlen(const char *);


extern __kernel_size_t strnlen(const char *,__kernel_size_t);
# 78 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/string.h"
extern int memcmp(const void *,const void *,__kernel_size_t);


extern void * memchr(const void *,int,__kernel_size_t);
# 110 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/termios.h" 2




#define user_termio_to_kernel_termios(termios,termio) ({ unsigned short tmp; get_user(tmp, &(termio)->c_iflag); (termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; get_user(tmp, &(termio)->c_oflag); (termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; get_user(tmp, &(termio)->c_cflag); (termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; get_user(tmp, &(termio)->c_lflag); (termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; get_user((termios)->c_line, &(termio)->c_line); copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); })
# 132 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/termios.h"
#define kernel_termios_to_user_termio(termio,termios) ({ put_user((termios)->c_iflag, &(termio)->c_iflag); put_user((termios)->c_oflag, &(termio)->c_oflag); put_user((termios)->c_cflag, &(termio)->c_cflag); put_user((termios)->c_lflag, &(termio)->c_lflag); put_user((termios)->c_line, &(termio)->c_line); copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); })
# 142 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/termios.h"
#define user_termios_to_kernel_termios(k,u) copy_from_user(k, u, sizeof(struct termios))
#define kernel_termios_to_user_termios(u,k) copy_to_user(u, k, sizeof(struct termios))
# 6 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/termios.h" 2
# 24 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serialP.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tqueue.h" 1
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tqueue.h"
#define _LINUX_TQUEUE_H 



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
#define _ASM_BITOPS_H 






#define SZLONG_LOG 5
#define SZLONG_MASK 31UL
# 32 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
#define smp_mb__before_clear_bit() smp_mb()
#define smp_mb__after_clear_bit() smp_mb()





#define __bi_flags unsigned long flags
#define __bi_cli() local_irq_disable()
#define __bi_save_flags(x) local_save_flags(x)
#define __bi_local_irq_save(x) local_irq_save(x)
#define __bi_local_irq_restore(x) local_irq_restore(x)
# 69 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) void set_bit(int nr, volatile void *addr)
{
        unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
        unsigned long temp;

        __asm__ __volatile__(
                "1:\tll\t%0, %1\t\t# set_bit\n\t"
                "or\t%0, %2\n\t"
                "sc\t%0, %1\n\t"
                "beqz\t%0, 1b"
                : "=&r" (temp), "=m" (*m)
                : "ir" (1UL << (nr & 0x1f)), "m" (*m));
}
# 92 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) void __set_bit(int nr, volatile void * addr)
{
        unsigned long * m = ((unsigned long *) addr) + (nr >> 5);

        *m |= 1UL << (nr & 31);
}
# 109 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) void clear_bit(int nr, volatile void *addr)
{
        unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
        unsigned long temp;

        __asm__ __volatile__(
                "1:\tll\t%0, %1\t\t# clear_bit\n\t"
                "and\t%0, %2\n\t"
                "sc\t%0, %1\n\t"
                "beqz\t%0, 1b\n\t"
                : "=&r" (temp), "=m" (*m)
                : "ir" (~(1UL << (nr & 0x1f))), "m" (*m));
}
# 132 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) void change_bit(int nr, volatile void *addr)
{
        unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
        unsigned long temp;

        __asm__ __volatile__(
                "1:\tll\t%0, %1\t\t# change_bit\n\t"
                "xor\t%0, %2\n\t"
                "sc\t%0, %1\n\t"
                "beqz\t%0, 1b"
                : "=&r" (temp), "=m" (*m)
                : "ir" (1UL << (nr & 0x1f)), "m" (*m));
}
# 155 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) void __change_bit(int nr, volatile void * addr)
{
        unsigned long * m = ((unsigned long *) addr) + (nr >> 5);

        *m ^= 1UL << (nr & 31);
}
# 170 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) int test_and_set_bit(int nr, volatile void *addr)
{
        unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
        unsigned long temp;
        int res;

        __asm__ __volatile__(
                ".set\tnoreorder\t\t# test_and_set_bit\n"
                "1:\tll\t%0, %1\n\t"
                "or\t%2, %0, %3\n\t"
                "sc\t%2, %1\n\t"
                "beqz\t%2, 1b\n\t"
                " and\t%2, %0, %3\n\t"



                ".set\treorder"
                : "=&r" (temp), "=m" (*m), "=&r" (res)
                : "r" (1UL << (nr & 0x1f)), "m" (*m)
                : "memory");

        return res != 0;
}
# 203 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) int __test_and_set_bit(int nr, volatile void * addr)
{
        volatile unsigned long *a = addr;
        unsigned long mask;
        int retval;

        a += nr >> 5;
        mask = 1 << (nr & 0x1f);
        retval = (mask & *a) != 0;
        *a |= mask;

        return retval;
}
# 225 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) int test_and_clear_bit(int nr, volatile void *addr)
{
        unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
        unsigned long temp, res;

        __asm__ __volatile__(
                ".set\tnoreorder\t\t# test_and_clear_bit\n"
                "1:\tll\t%0, %1\n\t"
                "or\t%2, %0, %3\n\t"
                "xor\t%2, %3\n\t"
                "sc\t%2, %1\n\t"
                "beqz\t%2, 1b\n\t"
                " and\t%2, %0, %3\n\t"



                ".set\treorder"
                : "=&r" (temp), "=m" (*m), "=&r" (res)
                : "r" (1UL << (nr & 0x1f)), "m" (*m)
                : "memory");

        return res != 0;
}
# 258 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) int __test_and_clear_bit(int nr, volatile void * addr)
{
        volatile unsigned long *a = addr;
        unsigned long mask, retval;

        a += nr >> 5;
        mask = 1 << (nr & 0x1f);
        retval = (mask & *a) != 0;
        *a &= ~mask;

        return retval;
}
# 279 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) int test_and_change_bit(int nr, volatile void *addr)
{
        unsigned long *m = ((unsigned long *) addr) + (nr >> 5);
        unsigned long temp, res;

        __asm__ __volatile__(
                ".set\tnoreorder\t\t# test_and_change_bit\n"
                "1:\tll\t%0, %1\n\t"
                "xor\t%2, %0, %3\n\t"
                "sc\t%2, %1\n\t"
                "beqz\t%2, 1b\n\t"
                " and\t%2, %0, %3\n\t"



                ".set\treorder"
                : "=&r" (temp), "=m" (*m), "=&r" (res)
                : "r" (1UL << (nr & 0x1f)), "m" (*m)
                : "memory");

        return res != 0;
}
# 311 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) int __test_and_change_bit(int nr, volatile void * addr)
{
        volatile unsigned long *a = addr;
        unsigned long mask;
        int retval;

        a += nr >> 5;
        mask = 1 << (nr & 0x1f);
        retval = (mask & *a) != 0;
        *a ^= mask;

        return retval;
}
# 585 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int test_bit(int nr, volatile void *addr)
{
        return 1UL & (((const volatile unsigned long *) addr)[nr >> 5] >> (nr & 31UL));
}







static __inline__ __attribute__((always_inline)) unsigned long ffz(unsigned long word)
{
        int b = 0, s;

        word = ~word;
        s = 16; if (word << 16 != 0) s = 0; b += s; word >>= s;
        s = 8; if (word << 24 != 0) s = 0; b += s; word >>= s;
        s = 4; if (word << 28 != 0) s = 0; b += s; word >>= s;
        s = 2; if (word << 30 != 0) s = 0; b += s; word >>= s;
        s = 1; if (word << 31 != 0) s = 0; b += s;

        return b;
}
# 620 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
#define ffs(x) generic_ffs(x)







static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) long find_next_zero_bit(void *addr, unsigned long size,
        unsigned long offset)
{
        unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
        unsigned long result = offset & ~31UL;
        unsigned long tmp;

        if (offset >= size)
                return size;
        size -= result;
        offset &= 31UL;
        if (offset) {
                tmp = *(p++);
                tmp |= ~0UL >> (32-offset);
                if (size < 32)
                        goto found_first;
                if (~tmp)
                        goto found_middle;
                size -= 32;
                result += 32;
        }
        while (size & ~31UL) {
                if (~(tmp = *(p++)))
                        goto found_middle;
                result += 32;
                size -= 32;
        }
        if (!size)
                return result;
        tmp = *p;

found_first:
        tmp |= ~0UL << size;
        if (tmp == ~0UL)
                return result + size;
found_middle:
        return result + ffz(tmp);
}

#define find_first_zero_bit(addr,size) find_next_zero_bit((addr), (size), 0)
# 682 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
#define find_first_zero_bit(addr,size) find_next_zero_bit((addr), (size), 0)
# 693 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/bitops.h"
#define hweight32(x) generic_hweight32(x)
#define hweight16(x) generic_hweight16(x)
#define hweight8(x) generic_hweight8(x)


static __inline__ __attribute__((always_inline)) int __test_and_set_le_bit(int nr, void * addr)
{
        unsigned char *ADDR = (unsigned char *) addr;
        int mask, retval;

        ADDR += nr >> 3;
        mask = 1 << (nr & 0x07);
        retval = (mask & *ADDR) != 0;
        *ADDR |= mask;

        return retval;
}

static __inline__ __attribute__((always_inline)) int __test_and_clear_le_bit(int nr, void * addr)
{
        unsigned char *ADDR = (unsigned char *) addr;
        int mask, retval;

        ADDR += nr >> 3;
        mask = 1 << (nr & 0x07);
        retval = (mask & *ADDR) != 0;
        *ADDR &= ~mask;

        return retval;
}

static __inline__ __attribute__((always_inline)) int test_le_bit(int nr, const void * addr)
{
        const unsigned char *ADDR = (const unsigned char *) addr;
        int mask;

        ADDR += nr >> 3;
        mask = 1 << (nr & 0x07);

        return ((mask & *ADDR) != 0);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long ext2_ffz(unsigned int word)
{
        int b = 0, s;

        word = ~word;
        s = 16; if (word << 16 != 0) s = 0; b += s; word >>= s;
        s = 8; if (word << 24 != 0) s = 0; b += s; word >>= s;
        s = 4; if (word << 28 != 0) s = 0; b += s; word >>= s;
        s = 2; if (word << 30 != 0) s = 0; b += s; word >>= s;
        s = 1; if (word << 31 != 0) s = 0; b += s;

        return b;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long find_next_zero_le_bit(void *addr,
        unsigned long size, unsigned long offset)
{
        unsigned int *p = ((unsigned int *) addr) + (offset >> 5);
        unsigned int result = offset & ~31;
        unsigned int tmp;

        if (offset >= size)
                return size;

        size -= result;
        offset &= 31;
        if (offset) {
                tmp = (*(__u32*)(p++));
                tmp |= ~0U >> (32-offset);
                if (size < 32)
                        goto found_first;
                if (tmp != ~0U)
                        goto found_middle;
                size -= 32;
                result += 32;
        }
        while (size >= 32) {
                if ((tmp = (*(__u32*)(p++))) != ~0U)
                        goto found_middle;
                result += 32;
                size -= 32;
        }
        if (!size)
                return result;

        tmp = (*(__u32*)(p));
found_first:
        tmp |= ~0 << size;
        if (tmp == ~0U)
                return result + size;

found_middle:
        return result + ext2_ffz(tmp);
}

#define find_first_zero_le_bit(addr,size) find_next_zero_le_bit((addr), (size), 0)


#define ext2_set_bit __test_and_set_le_bit
#define ext2_clear_bit __test_and_clear_le_bit
#define ext2_test_bit test_le_bit
#define ext2_find_first_zero_bit find_first_zero_le_bit
#define ext2_find_next_zero_bit find_next_zero_le_bit







#define minix_test_and_set_bit(nr,addr) test_and_set_bit(nr,addr)
#define minix_set_bit(nr,addr) set_bit(nr,addr)
#define minix_test_and_clear_bit(nr,addr) test_and_clear_bit(nr,addr)
#define minix_test_bit(nr,addr) test_bit(nr,addr)
#define minix_find_first_zero_bit(addr,size) find_first_zero_bit(addr,size)
# 19 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tqueue.h" 2
# 38 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tqueue.h"
struct tq_struct {
        struct list_head list;
        unsigned long sync;
        void (*routine)(void *);
        void *data;
};




#define PREPARE_TQUEUE(_tq,_routine,_data) do { (_tq)->routine = _routine; (_tq)->data = _data; } while (0)
# 57 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tqueue.h"
#define INIT_TQUEUE(_tq,_routine,_data) do { INIT_LIST_HEAD(&(_tq)->list); (_tq)->sync = 0; PREPARE_TQUEUE((_tq), (_routine), (_data)); } while (0)






typedef struct list_head task_queue;

#define DECLARE_TASK_QUEUE(q) LIST_HEAD(q)
#define TQ_ACTIVE(q) (!list_empty(&q))

extern task_queue tq_timer, tq_immediate, tq_disk;
# 94 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tqueue.h"
extern spinlock_t tqueue_lock;





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int queue_task(struct tq_struct *bh_pointer, task_queue *bh_list)
{
        int ret = 0;
        if (!test_and_set_bit(0,&bh_pointer->sync)) {
                unsigned long flags;
                do { __asm__ __volatile__( "__save_and_cli\t%0" : "=r" (flags) : : "memory"); (void)(&tqueue_lock); } while (0);
                list_add_tail(&bh_pointer->list, bh_list);
                do { do { } while(0); do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0); } while (0);
                ret = 1;
        }
        return ret;
}





extern void __run_task_queue(task_queue *list);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void run_task_queue(task_queue *list)
{
        if ((!list_empty(&*list)))
                __run_task_queue(list);
}
# 25 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serialP.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/circ_buf.h" 1

#define _LINUX_CIRC_BUF_H 1

struct circ_buf {
        char *buf;
        int head;
        int tail;
};


#define CIRC_CNT(head,tail,size) (((head) - (tail)) & ((size)-1))




#define CIRC_SPACE(head,tail,size) CIRC_CNT((tail),((head)+1),(size))




#define CIRC_CNT_TO_END(head,tail,size) ({int end = (size) - (tail); int n = ((head) + end) & ((size)-1); n < end ? n : end;})





#define CIRC_SPACE_TO_END(head,tail,size) ({int end = (size) - 1 - (head); int n = (end + (tail)) & ((size)-1); n <= end ? n : end+1;})
# 26 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serialP.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/wait.h" 1

#define _LINUX_WAIT_H 

#define WNOHANG 0x00000001
#define WUNTRACED 0x00000002

#define __WNOTHREAD 0x20000000
#define __WALL 0x40000000
#define __WCLONE 0x80000000
# 28 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/wait.h"
#define WAITQUEUE_DEBUG 0


struct __wait_queue {
        unsigned int flags;
#define WQ_FLAG_EXCLUSIVE 0x01
        struct task_struct * task;
        struct list_head task_list;




};
typedef struct __wait_queue wait_queue_t;







#define USE_RW_WAIT_QUEUE_SPINLOCK 0
# 64 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/wait.h"
#define wq_lock_t spinlock_t
#define WAITQUEUE_RW_LOCK_UNLOCKED SPIN_LOCK_UNLOCKED

#define wq_read_lock spin_lock
#define wq_read_lock_irqsave spin_lock_irqsave
#define wq_read_unlock spin_unlock
#define wq_read_unlock_irqrestore spin_unlock_irqrestore
#define wq_write_lock_irq spin_lock_irq
#define wq_write_lock_irqsave spin_lock_irqsave
#define wq_write_unlock_irqrestore spin_unlock_irqrestore
#define wq_write_unlock spin_unlock


struct __wait_queue_head {
        spinlock_t lock;
        struct list_head task_list;




};
typedef struct __wait_queue_head wait_queue_head_t;
# 120 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/wait.h"
#define WQ_BUG() 
#define CHECK_MAGIC(x) 
#define CHECK_MAGIC_WQHEAD(x) 
#define WQ_CHECK_LIST_HEAD(list) 
#define WQ_NOTE_WAKER(tsk) 
# 135 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/wait.h"
#define __WAITQUEUE_DEBUG_INIT(name) 
#define __WAITQUEUE_HEAD_DEBUG_INIT(name) 


#define __WAITQUEUE_INITIALIZER(name,tsk) { task: tsk, task_list: { NULL, NULL }, __WAITQUEUE_DEBUG_INIT(name)}




#define DECLARE_WAITQUEUE(name,tsk) wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)


#define __WAIT_QUEUE_HEAD_INITIALIZER(name) { lock: WAITQUEUE_RW_LOCK_UNLOCKED, task_list: { &(name).task_list, &(name).task_list }, __WAITQUEUE_HEAD_DEBUG_INIT(name)}




#define DECLARE_WAIT_QUEUE_HEAD(name) wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void init_waitqueue_head(wait_queue_head_t *q)
{




        q->lock = (spinlock_t) { };
        do { (&q->task_list)->next = (&q->task_list); (&q->task_list)->prev = (&q->task_list); } while (0);




}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void init_waitqueue_entry(wait_queue_t *q, struct task_struct *p)
{




        q->flags = 0;
        q->task = p;



}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int waitqueue_active(wait_queue_head_t *q)
{






        return !list_empty(&q->task_list);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __add_wait_queue(wait_queue_head_t *head, wait_queue_t *new)
{
# 203 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/wait.h"
        list_add(&new->task_list, &head->task_list);
}




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __add_wait_queue_tail(wait_queue_head_t *head,
                                                wait_queue_t *new)
{
# 220 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/wait.h"
        list_add_tail(&new->task_list, &head->task_list);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __remove_wait_queue(wait_queue_head_t *head,
                                                        wait_queue_t *old)
{





        list_del(&old->task_list);
}
# 27 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serialP.h" 2






struct serial_state {
        int magic;
        int baud_base;
        unsigned long port;
        int irq;
        int flags;
        int hub6;
        int type;
        int line;
        int revision;
        int xmit_fifo_size;
        int custom_divisor;
        int count;
        u8 *iomem_base;
        u16 iomem_reg_shift;
        unsigned short close_delay;
        unsigned short closing_wait;
        struct async_icount icount;
        struct termios normal_termios;
        struct termios callout_termios;
        int io_type;
        struct async_struct *info;
        struct pci_dev *dev;
};

struct async_struct {
        int magic;
        unsigned long port;
        int hub6;
        int flags;
        int xmit_fifo_size;
        struct serial_state *state;
        struct tty_struct *tty;
        int read_status_mask;
        int ignore_status_mask;
        int timeout;
        int quot;
        int x_char;
        int close_delay;
        unsigned short closing_wait;
        unsigned short closing_wait2;
        int IER;
        int MCR;
        int LCR;
        int ACR;
        unsigned long event;
        unsigned long last_active;
        int line;
        int blocked_open;
        long session;
        long pgrp;
        struct circ_buf xmit;
        spinlock_t xmit_lock;
        u8 *iomem_base;
        u16 iomem_reg_shift;
        int io_type;
        struct tq_struct tqueue;

        wait_queue_head_t open_wait;
        wait_queue_head_t close_wait;
        wait_queue_head_t delta_msr_wait;





        struct async_struct *next_port;
        struct async_struct *prev_port;
};

#define CONFIGURED_SERIAL_PORT(info) ((info)->port || ((info)->iomem_base))

#define SERIAL_MAGIC 0x5301
#define SSTATE_MAGIC 0x5302





#define RS_EVENT_WRITE_WAKEUP 0




struct rs_multiport_struct {
        int port1;
        unsigned char mask1, match1;
        int port2;
        unsigned char mask2, match2;
        int port3;
        unsigned char mask3, match3;
        int port4;
        unsigned char mask4, match4;
        int port_monitor;
};
# 137 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serialP.h"
#define ALPHA_KLUDGE_MCR 0





struct pci_dev;
struct pci_board {
        int flags;
        int num_ports;
        int base_baud;
        int uart_offset;
        int reg_shift;
        int (*init_fn)(struct pci_dev *dev, struct pci_board *board,
                        int enable);
        int first_uart_offset;
};

struct pci_board_inst {
        struct pci_board board;
        struct pci_dev *dev;
};

extern int pci_siig10x_fn(struct pci_dev *dev, struct pci_board *board, int enable);
extern int pci_siig20x_fn(struct pci_dev *dev, struct pci_board *board, int enable);


#define PCI_ANY_ID (~0)


#define SPCI_FL_BASE_MASK 0x0007
#define SPCI_FL_BASE0 0x0000
#define SPCI_FL_BASE1 0x0001
#define SPCI_FL_BASE2 0x0002
#define SPCI_FL_BASE3 0x0003
#define SPCI_FL_BASE4 0x0004
#define SPCI_FL_GET_BASE(x) (x & SPCI_FL_BASE_MASK)

#define SPCI_FL_IRQ_MASK (0x0007 << 4)
#define SPCI_FL_IRQBASE0 (0x0000 << 4)
#define SPCI_FL_IRQBASE1 (0x0001 << 4)
#define SPCI_FL_IRQBASE2 (0x0002 << 4)
#define SPCI_FL_IRQBASE3 (0x0003 << 4)
#define SPCI_FL_IRQBASE4 (0x0004 << 4)
#define SPCI_FL_GET_IRQBASE(x) ((x & SPCI_FL_IRQ_MASK) >> 4)



#define SPCI_FL_BASE_TABLE 0x0100


#define SPCI_FL_IRQ_TABLE 0x0200


#define SPCI_FL_IRQRESOURCE 0x0400


#define SPCI_FL_REGION_SZ_CAP 0x0800


#define SPCI_FL_NO_SHIRQ 0x1000


#define SPCI_FL_ISPNP 0x2000

#define SPCI_FL_PNPDEFAULT (SPCI_FL_IRQRESOURCE|SPCI_FL_ISPNP)
# 187 "drivers/char/serial.c" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serial_reg.h" 1
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/serial_reg.h"
#define _LINUX_SERIAL_REG_H 

#define UART_RX 0
#define UART_TX 0
#define UART_DLL 0
#define UART_TRG 0




#define UART_DLM 1
#define UART_IER 1
#define UART_FCTR 1


#define UART_IIR 2
#define UART_FCR 2
#define UART_EFR 2


#define UART_LCR 3
#define UART_MCR 4
#define UART_LSR 5
#define UART_MSR 6
#define UART_SCR 7
#define UART_EMSR 7







#define UART_FCR_ENABLE_FIFO 0x01
#define UART_FCR_CLEAR_RCVR 0x02
#define UART_FCR_CLEAR_XMIT 0x04
#define UART_FCR_DMA_SELECT 0x08
#define UART_FCR_TRIGGER_MASK 0xC0
#define UART_FCR_TRIGGER_1 0x00
#define UART_FCR_TRIGGER_4 0x40
#define UART_FCR_TRIGGER_8 0x80
#define UART_FCR_TRIGGER_14 0xC0

#define UART_FCR6_R_TRIGGER_8 0x00
#define UART_FCR6_R_TRIGGER_16 0x40
#define UART_FCR6_R_TRIGGER_24 0x80
#define UART_FCR6_R_TRIGGER_28 0xC0
#define UART_FCR6_T_TRIGGER_16 0x00
#define UART_FCR6_T_TRIGGER_8 0x10
#define UART_FCR6_T_TRIGGER_24 0x20
#define UART_FCR6_T_TRIGGER_30 0x30

#define UART_FCR7_64BYTE 0x20







#define UART_LCR_DLAB 0x80
#define UART_LCR_SBC 0x40
#define UART_LCR_SPAR 0x20
#define UART_LCR_EPAR 0x10
#define UART_LCR_PARITY 0x08
#define UART_LCR_STOP 0x04
#define UART_LCR_WLEN5 0x00
#define UART_LCR_WLEN6 0x01
#define UART_LCR_WLEN7 0x02
#define UART_LCR_WLEN8 0x03




#define UART_LSR_TEMT 0x40
#define UART_LSR_THRE 0x20
#define UART_LSR_BI 0x10
#define UART_LSR_FE 0x08
#define UART_LSR_PE 0x04
#define UART_LSR_OE 0x02
#define UART_LSR_DR 0x01




#define UART_IIR_NO_INT 0x01
#define UART_IIR_ID 0x06

#define UART_IIR_MSI 0x00
#define UART_IIR_THRI 0x02
#define UART_IIR_RDI 0x04
#define UART_IIR_RLSI 0x06




#define UART_IER_MSI 0x08
#define UART_IER_RLSI 0x04
#define UART_IER_THRI 0x02
#define UART_IER_RDI 0x01




#define UART_IERX_SLEEP 0x10




#define UART_MCR_LOOP 0x10
#define UART_MCR_OUT2 0x08
#define UART_MCR_OUT1 0x04
#define UART_MCR_RTS 0x02
#define UART_MCR_DTR 0x01




#define UART_MSR_DCD 0x80
#define UART_MSR_RI 0x40
#define UART_MSR_DSR 0x20
#define UART_MSR_CTS 0x10
#define UART_MSR_DDCD 0x08
#define UART_MSR_TERI 0x04
#define UART_MSR_DDSR 0x02
#define UART_MSR_DCTS 0x01
#define UART_MSR_ANY_DELTA 0x0F





#define UART_EFR_CTS 0x80
#define UART_EFR_RTS 0x40
#define UART_EFR_SCD 0x20
#define UART_EFR_ECB 0x10







#define UART_ASR 0x01
#define UART_RFL 0x03
#define UART_TFL 0x04
#define UART_ICR 0x05


#define UART_ACR 0x00
#define UART_CPR 0x01
#define UART_TCR 0x02
#define UART_CKS 0x03
#define UART_TTL 0x04
#define UART_RTL 0x05
#define UART_FCL 0x06
#define UART_FCH 0x07
#define UART_ID1 0x08
#define UART_ID2 0x09
#define UART_ID3 0x0A
#define UART_REV 0x0B
#define UART_CSR 0x0C
#define UART_NMR 0x0D
#define UART_CTR 0xFF




#define UART_ACR_RXDIS 0x01
#define UART_ACR_TXDIS 0x02
#define UART_ACR_DSRFC 0x04
#define UART_ACR_TLENB 0x20
#define UART_ACR_ICRRD 0x40
#define UART_ACR_ASREN 0x80






#define UART_FCTR_RTS_NODELAY 0x00
#define UART_FCTR_RTS_4DELAY 0x01
#define UART_FCTR_RTS_6DELAY 0x02
#define UART_FCTR_RTS_8DELAY 0x03
#define UART_FCTR_IRDA 0x04
#define UART_FCTR_TX_INT 0x08
#define UART_FCTR_TRGA 0x00
#define UART_FCTR_TRGB 0x10
#define UART_FCTR_TRGC 0x20
#define UART_FCTR_TRGD 0x30
#define UART_FCTR_SCR_SWAP 0x40
#define UART_FCTR_RX 0x00
#define UART_FCTR_TX 0x80






#define UART_EMSR_FIFO_COUNT 0x01
#define UART_EMSR_ALT_COUNT 0x02






#define UART_TRG_1 0x01
#define UART_TRG_4 0x04
#define UART_TRG_8 0x08
#define UART_TRG_16 0x10
#define UART_TRG_32 0x20
#define UART_TRG_64 0x40
#define UART_TRG_96 0x60
#define UART_TRG_120 0x78
#define UART_TRG_128 0x80







#define UART_RSA_BASE (-8)

#define UART_RSA_MSR ((UART_RSA_BASE) + 0)

#define UART_RSA_MSR_SWAP (1 << 0)
#define UART_RSA_MSR_FIFO (1 << 2)
#define UART_RSA_MSR_FLOW (1 << 3)
#define UART_RSA_MSR_ITYP (1 << 4)

#define UART_RSA_IER ((UART_RSA_BASE) + 1)

#define UART_RSA_IER_Rx_FIFO_H (1 << 0)
#define UART_RSA_IER_Tx_FIFO_H (1 << 1)
#define UART_RSA_IER_Tx_FIFO_E (1 << 2)
#define UART_RSA_IER_Rx_TOUT (1 << 3)
#define UART_RSA_IER_TIMER (1 << 4)

#define UART_RSA_SRR ((UART_RSA_BASE) + 2)

#define UART_RSA_SRR_Tx_FIFO_NEMP (1 << 0)
#define UART_RSA_SRR_Tx_FIFO_NHFL (1 << 1)
#define UART_RSA_SRR_Tx_FIFO_NFUL (1 << 2)
#define UART_RSA_SRR_Rx_FIFO_NEMP (1 << 3)
#define UART_RSA_SRR_Rx_FIFO_NHFL (1 << 4)
#define UART_RSA_SRR_Rx_FIFO_NFUL (1 << 5)
#define UART_RSA_SRR_Rx_TOUT (1 << 6)
#define UART_RSA_SRR_TIMER (1 << 7)

#define UART_RSA_FRR ((UART_RSA_BASE) + 2)

#define UART_RSA_TIVSR ((UART_RSA_BASE) + 3)

#define UART_RSA_TCR ((UART_RSA_BASE) + 4)

#define UART_RSA_TCR_SWITCH (1 << 0)





#define SERIAL_RSA_BAUD_BASE (921600)
#define SERIAL_RSA_BAUD_BASE_LO (SERIAL_RSA_BAUD_BASE / 8)
# 188 "drivers/char/serial.c" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define _ASM_SERIAL_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/jazz.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/jazz.h"
#define __ASM_JAZZ_H 
# 19 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/jazz.h"
#define JAZZ_LOCAL_IO_SPACE 0xe0000000
# 28 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/jazz.h"
#define PICA_ASIC_REVISION 0xe0000008
# 45 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/jazz.h"
#define PICA_LED 0xe000f000
# 54 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/jazz.h"
#define LED_DOT 0x01
#define LED_SPACE 0x00
#define LED_0 0xfc
#define LED_1 0x60
#define LED_2 0xda
#define LED_3 0xf2
#define LED_4 0x66
#define LED_5 0xb6
#define LED_6 0xbe
#define LED_7 0xe0
#define LED_8 0xfe
#define LED_9 0xf6
#define LED_A 0xee
#define LED_b 0x3e
#define LED_C 0x9c
#define LED_d 0x7a
#define LED_E 0x9e
#define LED_F 0x8e



static __inline__ __attribute__((always_inline)) void pica_set_led(unsigned int bits)
{
        volatile unsigned int *led_register = (unsigned int *) 0xe000f000;

        *led_register = bits;
}






#define JAZZ_ETHERNET_BASE 0xe0001000




#define JAZZ_SCSI_BASE 0xe0002000






#define JAZZ_KEYBOARD_ADDRESS 0xe0005000
#define JAZZ_KEYBOARD_DATA 0xe0005000
#define JAZZ_KEYBOARD_COMMAND 0xe0005001



typedef struct {
        unsigned char data;
        unsigned char command;
} jazz_keyboard_hardware;

typedef struct {
        unsigned char pad0[3];
        unsigned char data;
        unsigned char pad1[3];
        unsigned char command;
} mips_keyboard_hardware;




#define keyboard_hardware jazz_keyboard_hardware






#define MIPS_KEYBOARD_ADDRESS 0xb9005000
#define MIPS_KEYBOARD_DATA 0xb9005003
#define MIPS_KEYBOARD_COMMAND 0xb9005007




#define JAZZ_SERIAL1_BASE (unsigned int)0xe0006000
#define JAZZ_SERIAL2_BASE (unsigned int)0xe0007000
#define JAZZ_PARALLEL_BASE (unsigned int)0xe0008000




#define JAZZ_DUMMY_DEVICE 0xe000d000







#define JAZZ_TIMER_INTERVAL 0xe0000228
#define JAZZ_TIMER_REGISTER 0xe0000230






typedef struct {
        unsigned int bank2 : 3;
        unsigned int bank1 : 3;
        unsigned int mem_bus_width : 1;
        unsigned int reserved2 : 1;
        unsigned int page_mode : 1;
        unsigned int reserved1 : 23;
} dram_configuration;
# 177 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/jazz.h"
#define PICA_DRAM_CONFIG 0xe00fffe0




#define JAZZ_IO_IRQ_SOURCE 0xe0010000
#define JAZZ_IO_IRQ_ENABLE 0xe0010002




#define JAZZ_IE_PARALLEL (1 << 0)
#define JAZZ_IE_FLOPPY (1 << 1)
#define JAZZ_IE_SOUND (1 << 2)
#define JAZZ_IE_VIDEO (1 << 3)
#define JAZZ_IE_ETHERNET (1 << 4)
#define JAZZ_IE_SCSI (1 << 5)
#define JAZZ_IE_KEYBOARD (1 << 6)
#define JAZZ_IE_MOUSE (1 << 7)
#define JAZZ_IE_SERIAL1 (1 << 8)
#define JAZZ_IE_SERIAL2 (1 << 9)







#define JAZZ_PARALLEL_IRQ 16
#define JAZZ_FLOPPY_IRQ 6
#define JAZZ_SOUND_IRQ 18
#define JAZZ_VIDEO_IRQ 19
#define JAZZ_ETHERNET_IRQ 20
#define JAZZ_SCSI_IRQ 21
#define JAZZ_KEYBOARD_IRQ 22
#define JAZZ_MOUSE_IRQ 23
#define JAZZ_SERIAL1_IRQ 24
#define JAZZ_SERIAL2_IRQ 25

#define JAZZ_TIMER_IRQ 31







#define JAZZ_SCSI_DMA 0
#define JAZZ_FLOPPY_DMA 1
#define JAZZ_AUDIOL_DMA 2
#define JAZZ_AUDIOR_DMA 3





#define JAZZ_R4030_CONFIG 0xE0000000
#define JAZZ_R4030_REVISION 0xE0000008
#define JAZZ_R4030_INV_ADDR 0xE0000010

#define JAZZ_R4030_TRSTBL_BASE 0xE0000018
#define JAZZ_R4030_TRSTBL_LIM 0xE0000020
#define JAZZ_R4030_TRSTBL_INV 0xE0000028

#define JAZZ_R4030_CACHE_MTNC 0xE0000030
#define JAZZ_R4030_R_FAIL_ADDR 0xE0000038
#define JAZZ_R4030_M_FAIL_ADDR 0xE0000040

#define JAZZ_R4030_CACHE_PTAG 0xE0000048
#define JAZZ_R4030_CACHE_LTAG 0xE0000050
#define JAZZ_R4030_CACHE_BMASK 0xE0000058
#define JAZZ_R4030_CACHE_BWIN 0xE0000060
# 258 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/jazz.h"
#define JAZZ_R4030_REM_SPEED 0xE0000070

#define JAZZ_R4030_IRQ_ENABLE 0xE00000E8
#define JAZZ_R4030_INVAL_ADDR 0xE0000010
#define JAZZ_R4030_IRQ_SOURCE 0xE0000200
#define JAZZ_R4030_I386_ERROR 0xE0000208




#define JAZZ_EISA_IRQ_ACK 0xE0000238






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void r4030_delay(void)
{
__asm__ __volatile__(
        ".set\tnoreorder\n\t"
        "nop\n\t"
        "nop\n\t"
        "nop\n\t"
        "nop\n\t"
        ".set\treorder");
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned short r4030_read_reg16(unsigned addr)
{
        unsigned short ret = *((volatile unsigned short *)addr);
        r4030_delay();
        return ret;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int r4030_read_reg32(unsigned addr)
{
        unsigned int ret = *((volatile unsigned int *)addr);
        r4030_delay();
        return ret;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void r4030_write_reg16(unsigned addr, unsigned val)
{
        *((volatile unsigned short *)addr) = val;
        r4030_delay();
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void r4030_write_reg32(unsigned addr, unsigned val)
{
        *((volatile unsigned int *)addr) = val;
        r4030_delay();
}



#define JAZZ_FDC_BASE 0xe0003000
#define JAZZ_RTC_BASE 0xe0004000
#define JAZZ_PORT_BASE 0xe2000000

#define JAZZ_EISA_BASE 0xe3000000
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h" 2
# 22 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define BASE_BAUD ( 1843200 / 16 )




#define JAZZ_BASE_BAUD ( 8000000 / 16 )
# 38 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
#define STD_COM4_FLAGS ASYNC_BOOT_AUTOCONF



#define FOURPORT_FLAGS ASYNC_FOURPORT
#define ACCENT_FLAGS 0
#define BOCA_FLAGS 0
#define HUB6_FLAGS 0
#define RS_TABLE_SIZE 64
# 66 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define C_P(card,port) (((card)<<6|(port)<<3) + 1)
# 77 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define JAZZ_SERIAL_PORT_DEFNS 
# 87 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define ATLAS_SERIAL_PORT_DEFNS 
# 97 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define SEAD_SERIAL_PORT_DEFNS 
# 107 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define COBALT_SERIAL_PORT_DEFNS 
# 116 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define GODSON_SIM_SERIAL_PORT_DEFNS 
# 135 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define EV96100_SERIAL_PORT_DEFNS 
# 154 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define ITE_SERIAL_PORT_DEFNS 
# 167 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define IVR_SERIAL_PORT_DEFNS 
# 221 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define AU1000_SERIAL_PORT_DEFNS 
# 232 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define TXX927_SERIAL_PORT_DEFNS 
# 262 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#undef BASE_BAUD
#define BASE_BAUD (5*25000000/2/16)

#define STD_SERIAL_PORT_DEFNS { .baud_base=BASE_BAUD, .iomem_base=0xb2e40000,.irq=2,.flags=STD_COM_FLAGS,.iomem_reg_shift=2, .io_type=SERIAL_IO_MEM},
# 279 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define EXTRA_SERIAL_PORT_DEFNS { 0, BASE_BAUD, 0x1A0, 9, FOURPORT_FLAGS }, { 0, BASE_BAUD, 0x1A8, 9, FOURPORT_FLAGS }, { 0, BASE_BAUD, 0x1B0, 9, FOURPORT_FLAGS }, { 0, BASE_BAUD, 0x1B8, 9, FOURPORT_FLAGS }, { 0, BASE_BAUD, 0x2A0, 5, FOURPORT_FLAGS }, { 0, BASE_BAUD, 0x2A8, 5, FOURPORT_FLAGS }, { 0, BASE_BAUD, 0x2B0, 5, FOURPORT_FLAGS }, { 0, BASE_BAUD, 0x2B8, 5, FOURPORT_FLAGS }, { 0, BASE_BAUD, 0x330, 4, ACCENT_FLAGS }, { 0, BASE_BAUD, 0x338, 4, ACCENT_FLAGS }, { 0, BASE_BAUD, 0x000, 0, 0 }, { 0, BASE_BAUD, 0x000, 0, 0 }, { 0, BASE_BAUD, 0x100, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x108, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x110, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x118, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x120, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x128, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x130, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x138, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x140, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x148, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x150, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x158, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x160, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x168, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x170, 12, BOCA_FLAGS }, { 0, BASE_BAUD, 0x178, 12, BOCA_FLAGS },
# 335 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define HUB6_SERIAL_PORT_DFNS 
# 347 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define MCA_SERIAL_PORT_DFNS 
# 364 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define MOMENCO_OCELOT_SERIAL_PORT_DEFNS 
# 385 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define MOMENCO_OCELOT_G_SERIAL_PORT_DEFNS 
# 406 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define MOMENCO_OCELOT_C_SERIAL_PORT_DEFNS 
# 424 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define PMC_STRETCH_SERIAL_PORT_DEFNS 
# 442 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define MOMENCO_JAGUAR_ATX_SERIAL_PORT_DEFNS 
# 460 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define TITAN_SERIAL_PORT_DEFNS 
# 498 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define IP27_SERIAL_PORT_DEFNS 
# 511 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/serial.h"
#define DDB5477_SERIAL_PORT_DEFNS 


#define SERIAL_PORT_DFNS ATLAS_SERIAL_PORT_DEFNS AU1000_SERIAL_PORT_DEFNS COBALT_SERIAL_PORT_DEFNS DDB5477_SERIAL_PORT_DEFNS EV96100_SERIAL_PORT_DEFNS EXTRA_SERIAL_PORT_DEFNS HUB6_SERIAL_PORT_DFNS ITE_SERIAL_PORT_DEFNS IVR_SERIAL_PORT_DEFNS JAZZ_SERIAL_PORT_DEFNS MOMENCO_OCELOT_SERIAL_PORT_DEFNS MOMENCO_OCELOT_G_SERIAL_PORT_DEFNS MOMENCO_OCELOT_C_SERIAL_PORT_DEFNS MOMENCO_JAGUAR_ATX_SERIAL_PORT_DEFNS PMC_STRETCH_SERIAL_PORT_DEFNS SEAD_SERIAL_PORT_DEFNS STD_SERIAL_PORT_DEFNS TITAN_SERIAL_PORT_DEFNS TXX927_SERIAL_PORT_DEFNS
# 189 "drivers/char/serial.c" 2
#define LOCAL_VERSTRING ""


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/errno.h" 1

#define _LINUX_ERRNO_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/errno.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/errno.h"
#define _ASM_ERRNO_H 




#define EPERM 1
#define ENOENT 2
#define ESRCH 3
#define EINTR 4
#define EIO 5
#define ENXIO 6
#define E2BIG 7
#define ENOEXEC 8
#define EBADF 9
#define ECHILD 10
#define EAGAIN 11
#define ENOMEM 12
#define EACCES 13
#define EFAULT 14
#define ENOTBLK 15
#define EBUSY 16
#define EEXIST 17
#define EXDEV 18
#define ENODEV 19
#define ENOTDIR 20
#define EISDIR 21
#define EINVAL 22
#define ENFILE 23
#define EMFILE 24
#define ENOTTY 25
#define ETXTBSY 26
#define EFBIG 27
#define ENOSPC 28
#define ESPIPE 29
#define EROFS 30
#define EMLINK 31
#define EPIPE 32
#define EDOM 33
#define ERANGE 34
#define ENOMSG 35
#define EIDRM 36
#define ECHRNG 37
#define EL2NSYNC 38
#define EL3HLT 39
#define EL3RST 40
#define ELNRNG 41
#define EUNATCH 42
#define ENOCSI 43
#define EL2HLT 44
#define EDEADLK 45
#define ENOLCK 46
#define EBADE 50
#define EBADR 51
#define EXFULL 52
#define ENOANO 53
#define EBADRQC 54
#define EBADSLT 55
#define EDEADLOCK 56
#define EBFONT 59
#define ENOSTR 60
#define ENODATA 61
#define ETIME 62
#define ENOSR 63
#define ENONET 64
#define ENOPKG 65
#define EREMOTE 66
#define ENOLINK 67
#define EADV 68
#define ESRMNT 69
#define ECOMM 70
#define EPROTO 71
#define EDOTDOT 73
#define EMULTIHOP 74
#define EBADMSG 77
#define ENAMETOOLONG 78
#define EOVERFLOW 79
#define ENOTUNIQ 80
#define EBADFD 81
#define EREMCHG 82
#define ELIBACC 83
#define ELIBBAD 84
#define ELIBSCN 85
#define ELIBMAX 86
#define ELIBEXEC 87
#define EILSEQ 88
#define ENOSYS 89
#define ELOOP 90
#define ERESTART 91
#define ESTRPIPE 92
#define ENOTEMPTY 93
#define EUSERS 94
#define ENOTSOCK 95
#define EDESTADDRREQ 96
#define EMSGSIZE 97
#define EPROTOTYPE 98
#define ENOPROTOOPT 99
#define EPROTONOSUPPORT 120
#define ESOCKTNOSUPPORT 121
#define EOPNOTSUPP 122
#define EPFNOSUPPORT 123
#define EAFNOSUPPORT 124
#define EADDRINUSE 125
#define EADDRNOTAVAIL 126
#define ENETDOWN 127
#define ENETUNREACH 128
#define ENETRESET 129
#define ECONNABORTED 130
#define ECONNRESET 131
#define ENOBUFS 132
#define EISCONN 133
#define ENOTCONN 134
#define EUCLEAN 135
#define ENOTNAM 137
#define ENAVAIL 138
#define EISNAM 139
#define EREMOTEIO 140
#define EINIT 141
#define EREMDEV 142
#define ESHUTDOWN 143
#define ETOOMANYREFS 144
#define ETIMEDOUT 145
#define ECONNREFUSED 146
#define EHOSTDOWN 147
#define EHOSTUNREACH 148
#define EWOULDBLOCK EAGAIN
#define EALREADY 149
#define EINPROGRESS 150
#define ESTALE 151
#define ECANCELED 158




#define ENOMEDIUM 159
#define EMEDIUMTYPE 160

#define EDQUOT 1133




#define EMAXERRNO 1133
# 5 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/errno.h" 2




#define ERESTARTSYS 512
#define ERESTARTNOINTR 513
#define ERESTARTNOHAND 514
#define ENOIOCTLCMD 515


#define EBADHANDLE 521
#define ENOTSYNC 522
#define EBADCOOKIE 523
#define ENOTSUPP 524
#define ETOOSMALL 525
#define ESERVERFAULT 526
#define EBADTYPE 527
#define EJUKEBOX 528
# 193 "drivers/char/serial.c" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/signal.h" 1

#define _LINUX_SIGNAL_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/signal.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/signal.h"
#define _ASM_SIGNAL_H 




#define _NSIG 128
#define _NSIG_BPW 32
#define _NSIG_WORDS (_NSIG / _NSIG_BPW)

typedef struct {
        unsigned long sig[(128 / 32)];
} sigset_t;

typedef unsigned long old_sigset_t;

#define SIGHUP 1
#define SIGINT 2
#define SIGQUIT 3
#define SIGILL 4
#define SIGTRAP 5
#define SIGIOT 6
#define SIGABRT SIGIOT
#define SIGEMT 7
#define SIGFPE 8
#define SIGKILL 9
#define SIGBUS 10
#define SIGSEGV 11
#define SIGSYS 12
#define SIGPIPE 13
#define SIGALRM 14
#define SIGTERM 15
#define SIGUSR1 16
#define SIGUSR2 17
#define SIGCHLD 18
#define SIGCLD SIGCHLD
#define SIGPWR 19
#define SIGWINCH 20
#define SIGURG 21
#define SIGIO 22
#define SIGPOLL SIGIO
#define SIGSTOP 23
#define SIGTSTP 24
#define SIGCONT 25
#define SIGTTIN 26
#define SIGTTOU 27
#define SIGVTALRM 28
#define SIGPROF 29
#define SIGXCPU 30
#define SIGXFSZ 31


#define SIGRTMIN 32
#define SIGRTMAX (_NSIG-1)
# 78 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/signal.h"
#define SA_ONSTACK 0x08000000
#define SA_RESETHAND 0x80000000
#define SA_RESTART 0x10000000
#define SA_SIGINFO 0x00000008
#define SA_NODEFER 0x40000000
#define SA_NOCLDWAIT 0x00010000
#define SA_NOCLDSTOP 0x00000001

#define SA_NOMASK SA_NODEFER
#define SA_ONESHOT SA_RESETHAND
#define SA_INTERRUPT 0x20000000

#define SA_RESTORER 0x04000000




#define SS_ONSTACK 1
#define SS_DISABLE 2

#define MINSIGSTKSZ 2048
#define SIGSTKSZ 8192
# 110 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/signal.h"
#define SA_PROBE SA_ONESHOT
#define SA_SAMPLE_RANDOM SA_RESTART
#define SA_SHIRQ 0x02000000



#define SIG_BLOCK 1
#define SIG_UNBLOCK 2
#define SIG_SETMASK 3
#define SIG_SETMASK32 256



typedef void (*__sighandler_t)(int);


#define SIG_DFL ((__sighandler_t)0)
#define SIG_IGN ((__sighandler_t)1)
#define SIG_ERR ((__sighandler_t)-1)

struct sigaction {
        unsigned int sa_flags;
        __sighandler_t sa_handler;
        sigset_t sa_mask;
};

struct k_sigaction {
        struct sigaction sa;



};


typedef struct sigaltstack {
        void *ss_sp;
        size_t ss_size;
        int ss_flags;
} stack_t;


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/sigcontext.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/sigcontext.h"
#define _ASM_SIGCONTEXT_H 





struct sigcontext {
        unsigned int sc_regmask;
        unsigned int sc_status;
        unsigned long long sc_pc;
        unsigned long long sc_regs[32];
        unsigned long long sc_fpregs[32];
        unsigned int sc_ownedfp;
        unsigned int sc_fpc_csr;
        unsigned int sc_fpc_eir;
        unsigned int sc_used_math;
        unsigned int sc_ssflags;
        unsigned long long sc_mdhi;
        unsigned long long sc_mdlo;

        unsigned int sc_cause;
        unsigned int sc_badvaddr;

        unsigned long sc_sigset[4];
};
# 152 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/signal.h" 2







#define BRK_USERBP 0
#define BRK_KERNELBP 1
#define BRK_ABORT 2
#define BRK_BD_TAKEN 3
#define BRK_BD_NOTTAKEN 4
#define BRK_SSTEPBP 5
#define BRK_OVERFLOW 6
#define BRK_DIVZERO 7
#define BRK_RANGE 8
#define BRK_STACKOVERFLOW 9
#define BRK_NORLD 10
#define _BRK_THREADBP 11
#define BRK_MULOVF 1023
# 5 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/signal.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/siginfo.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/siginfo.h"
#define _ASM_SIGINFO_H 






typedef union sigval {
        int sival_int;
        void *sival_ptr;
} sigval_t;




#define SI_MAX_SIZE 128

#define SI_PAD_SIZE ((SI_MAX_SIZE/sizeof(int)) - 3)





typedef struct siginfo {
        int si_signo;
        int si_code;
        int si_errno;
        int __pad0[128 / sizeof(int) - ((128/sizeof(int)) - 3) - 3];

        union {
                int _pad[((128/sizeof(int)) - 3)];


                struct {
                        pid_t _pid;
                        uid_t _uid;
                } _kill;


                struct {
                        pid_t _pid;
                        uid_t _uid;
                        int _status;
                        clock_t _utime;
                        clock_t _stime;
                } _sigchld;


                struct {
                        pid_t _pid;
                        clock_t _utime;
                        int _status;
                        clock_t _stime;
                } _irix_sigchld;


                struct {
                        void *_addr;
                } _sigfault;


                struct {
                        long _band;
                        int _fd;
                } _sigpoll;


                struct {
                        unsigned int _timer1;
                        unsigned int _timer2;
                } _timer;


                struct {
                        pid_t _pid;
                        uid_t _uid;
                        sigval_t _sigval;
                } _rt;

        } _sifields;
} siginfo_t;




#define si_pid _sifields._kill._pid
#define si_uid _sifields._kill._uid
#define si_status _sifields._sigchld._status
#define si_utime _sifields._sigchld._utime
#define si_stime _sifields._sigchld._stime
#define si_value _sifields._rt._sigval
#define si_int _sifields._rt._sigval.sival_int
#define si_ptr _sifields._rt._sigval.sival_ptr
#define si_addr _sifields._sigfault._addr
#define si_band _sifields._sigpoll._band
#define si_fd _sifields._sigpoll._fd


#define __SI_MASK 0xffff0000
#define __SI_KILL (0 << 16)
#define __SI_TIMER (1 << 16)
#define __SI_POLL (2 << 16)
#define __SI_FAULT (3 << 16)
#define __SI_CHLD (4 << 16)
#define __SI_RT (5 << 16)
#define __SI_CODE(T,N) ((T) << 16 | ((N) & 0xffff))
# 130 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/siginfo.h"
#define SI_USER 0
#define SI_KERNEL 0x80
#define SI_QUEUE -1
#define SI_ASYNCIO -2
#define SI_TIMER __SI_CODE(__SI_TIMER,-3)
#define SI_MESGQ -4
#define SI_SIGIO -5
#define SI_TKILL -6

#define SI_FROMUSER(siptr) ((siptr)->si_code <= 0)
#define SI_FROMKERNEL(siptr) ((siptr)->si_code > 0)




#define ILL_ILLOPC (__SI_FAULT|1)
#define ILL_ILLOPN (__SI_FAULT|2)
#define ILL_ILLADR (__SI_FAULT|3)
#define ILL_ILLTRP (__SI_FAULT|4)
#define ILL_PRVOPC (__SI_FAULT|5)
#define ILL_PRVREG (__SI_FAULT|6)
#define ILL_COPROC (__SI_FAULT|7)
#define ILL_BADSTK (__SI_FAULT|8)
#define NSIGILL 8




#define FPE_INTDIV (__SI_FAULT|1)
#define FPE_INTOVF (__SI_FAULT|2)
#define FPE_FLTDIV (__SI_FAULT|3)
#define FPE_FLTOVF (__SI_FAULT|4)
#define FPE_FLTUND (__SI_FAULT|5)
#define FPE_FLTRES (__SI_FAULT|6)
#define FPE_FLTINV (__SI_FAULT|7)
#define FPE_FLTSUB (__SI_FAULT|8)
#define NSIGFPE 8




#define SEGV_MAPERR (__SI_FAULT|1)
#define SEGV_ACCERR (__SI_FAULT|2)
#define NSIGSEGV 2




#define BUS_ADRALN (__SI_FAULT|1)
#define BUS_ADRERR (__SI_FAULT|2)
#define BUS_OBJERR (__SI_FAULT|3)
#define NSIGBUS 3




#define TRAP_BRKPT (__SI_FAULT|1)
#define TRAP_TRACE (__SI_FAULT|2)
#define NSIGTRAP 2




#define CLD_EXITED (__SI_CHLD|1)
#define CLD_KILLED (__SI_CHLD|2)
#define CLD_DUMPED (__SI_CHLD|3)
#define CLD_TRAPPED (__SI_CHLD|4)
#define CLD_STOPPED (__SI_CHLD|5)
#define CLD_CONTINUED (__SI_CHLD|6)
#define NSIGCHLD 6




#define POLL_IN (__SI_POLL|1)
#define POLL_OUT (__SI_POLL|2)
#define POLL_MSG (__SI_POLL|3)
#define POLL_ERR (__SI_POLL|4)
#define POLL_PRI (__SI_POLL|5)
#define POLL_HUP (__SI_POLL|6)
#define NSIGPOLL 6
# 220 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/siginfo.h"
#define SIGEV_SIGNAL 0
#define SIGEV_NONE 1
#define SIGEV_THREAD 2

#define SIGEV_MAX_SIZE 64
#define SIGEV_HEAD_SIZE (sizeof(long) + 2*sizeof(int))
#define SIGEV_PAD_SIZE ((SIGEV_MAX_SIZE-SIGEV_HEAD_SIZE) / sizeof(int))

typedef struct sigevent {
        sigval_t sigev_value;
        int sigev_signo;
        int sigev_notify;
        union {
                int _pad[((64 -(sizeof(long) + 2*sizeof(int))) / sizeof(int))];

                struct {
                        void (*_function)(sigval_t);
                        void *_attribute;
                } _sigev_thread;
        } _sigev_un;
} sigevent_t;

#define sigev_notify_function _sigev_un._sigev_thread._function
#define sigev_notify_attributes _sigev_un._sigev_thread._attribute




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void copy_siginfo(siginfo_t *to, siginfo_t *from)
{
        if (from->si_code < 0)
                memcpy(to, from, sizeof(siginfo_t));
        else

                memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
}

extern int copy_siginfo_to_user(siginfo_t *to, siginfo_t *from);
# 6 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/signal.h" 2






struct sigqueue {
        struct sigqueue *next;
        siginfo_t info;
};

struct sigpending {
        struct sigqueue *head, **tail;
        sigset_t signal;
};
# 31 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/signal.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void sigaddset(sigset_t *set, int _sig)
{
        unsigned long sig = _sig - 1;
        if ((128 / 32) == 1)
                set->sig[0] |= 1UL << sig;
        else
                set->sig[sig / 32] |= 1UL << (sig % 32);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void sigdelset(sigset_t *set, int _sig)
{
        unsigned long sig = _sig - 1;
        if ((128 / 32) == 1)
                set->sig[0] &= ~(1UL << sig);
        else
                set->sig[sig / 32] &= ~(1UL << (sig % 32));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int sigismember(sigset_t *set, int _sig)
{
        unsigned long sig = _sig - 1;
        if ((128 / 32) == 1)
                return 1 & (set->sig[0] >> sig);
        else
                return 1 & (set->sig[sig / 32] >> (sig % 32));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int sigfindinword(unsigned long word)
{
        return ffz(~word);
}

#define sigmask(sig) (1UL << ((sig) - 1))






#define _SIG_SET_BINOP(name,op) static inline void name(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < _NSIG_WORDS/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = op(a0, b0); r->sig[4*i+1] = op(a1, b1); r->sig[4*i+2] = op(a2, b2); r->sig[4*i+3] = op(a3, b3); } switch (_NSIG_WORDS % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = op(a0, b0); r->sig[4*i+1] = op(a1, b1); r->sig[4*i+2] = op(a2, b2); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = op(a0, b0); r->sig[4*i+1] = op(a1, b1); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = op(a0, b0); break; } }
# 107 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/signal.h"
#define _sig_or(x,y) ((x) | (y))
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void sigorsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (128 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); r->sig[4*i+2] = ((a2) | (b2)); r->sig[4*i+3] = ((a3) | (b3)); } switch ((128 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); r->sig[4*i+2] = ((a2) | (b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) | (b0)); r->sig[4*i+1] = ((a1) | (b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) | (b0)); break; } }

#define _sig_and(x,y) ((x) & (y))
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void sigandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (128 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); r->sig[4*i+2] = ((a2) & (b2)); r->sig[4*i+3] = ((a3) & (b3)); } switch ((128 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); r->sig[4*i+2] = ((a2) & (b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) & (b0)); r->sig[4*i+1] = ((a1) & (b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) & (b0)); break; } }

#define _sig_nand(x,y) ((x) & ~(y))
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void signandsets(sigset_t *r, const sigset_t *a, const sigset_t *b) { unsigned long a0, a1, a2, a3, b0, b1, b2, b3; unsigned long i; for (i = 0; i < (128 / 32)/4; ++i) { a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); r->sig[4*i+2] = ((a2) & ~(b2)); r->sig[4*i+3] = ((a3) & ~(b3)); } switch ((128 / 32) % 4) { case 3: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); r->sig[4*i+2] = ((a2) & ~(b2)); break; case 2: a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; r->sig[4*i+0] = ((a0) & ~(b0)); r->sig[4*i+1] = ((a1) & ~(b1)); break; case 1: a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0]; r->sig[4*i+0] = ((a0) & ~(b0)); break; } }

#undef _SIG_SET_BINOP
#undef _sig_or
#undef _sig_and
#undef _sig_nand

#define _SIG_SET_OP(name,op) static inline void name(sigset_t *set) { unsigned long i; for (i = 0; i < _NSIG_WORDS/4; ++i) { set->sig[4*i+0] = op(set->sig[4*i+0]); set->sig[4*i+1] = op(set->sig[4*i+1]); set->sig[4*i+2] = op(set->sig[4*i+2]); set->sig[4*i+3] = op(set->sig[4*i+3]); } switch (_NSIG_WORDS % 4) { case 3: set->sig[4*i+2] = op(set->sig[4*i+2]); case 2: set->sig[4*i+1] = op(set->sig[4*i+1]); case 1: set->sig[4*i+0] = op(set->sig[4*i+0]); } }
# 139 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/signal.h"
#define _sig_not(x) (~(x))
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void signotset(sigset_t *set) { unsigned long i; for (i = 0; i < (128 / 32)/4; ++i) { set->sig[4*i+0] = (~(set->sig[4*i+0])); set->sig[4*i+1] = (~(set->sig[4*i+1])); set->sig[4*i+2] = (~(set->sig[4*i+2])); set->sig[4*i+3] = (~(set->sig[4*i+3])); } switch ((128 / 32) % 4) { case 3: set->sig[4*i+2] = (~(set->sig[4*i+2])); case 2: set->sig[4*i+1] = (~(set->sig[4*i+1])); case 1: set->sig[4*i+0] = (~(set->sig[4*i+0])); } }

#undef _SIG_SET_OP
#undef _sig_not

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void sigemptyset(sigset_t *set)
{
        switch ((128 / 32)) {
        default:
                memset(set, 0, sizeof(sigset_t));
                break;
        case 2: set->sig[1] = 0;
        case 1: set->sig[0] = 0;
                break;
        }
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void sigfillset(sigset_t *set)
{
        switch ((128 / 32)) {
        default:
                memset(set, -1, sizeof(sigset_t));
                break;
        case 2: set->sig[1] = (unsigned long)-1;
        case 1: set->sig[0] = (unsigned long)-1;
                break;
        }
}

extern char * render_sigset_t(sigset_t *set, char *buffer);



static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void sigaddsetmask(sigset_t *set, unsigned long mask)
{
        set->sig[0] |= mask;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void sigdelsetmask(sigset_t *set, unsigned long mask)
{
        set->sig[0] &= ~mask;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int sigtestsetmask(sigset_t *set, unsigned long mask)
{
        return (set->sig[0] & mask) != 0;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void siginitset(sigset_t *set, unsigned long mask)
{
        set->sig[0] = mask;
        switch ((128 / 32)) {
        default:
                memset(&set->sig[1], 0, sizeof(long)*((128 / 32)-1));
                break;
        case 2: set->sig[1] = 0;
        case 1: ;
        }
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void siginitsetinv(sigset_t *set, unsigned long mask)
{
        set->sig[0] = ~mask;
        switch ((128 / 32)) {
        default:
                memset(&set->sig[1], -1, sizeof(long)*((128 / 32)-1));
                break;
        case 2: set->sig[1] = (unsigned long)-1;
        case 1: ;
        }
}



static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void init_sigpending(struct sigpending *sig)
{
        sigemptyset(&sig->signal);
        sig->head = ((void *)0);
        sig->tail = &sig->head;
}

extern long do_sigpending(void *, unsigned long);
# 194 "drivers/char/serial.c" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 1

#define _LINUX_SCHED_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/param.h" 1

#define _ASM_PARAM_H 
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/param.h"
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/compiler.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/compiler.h"
#define _ASM_COMPILER_H 




#define GCC_REG_ACCUM "accum"
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/param.h" 2
# 44 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/param.h"
#define HZ 100
#define hz_to_std(a) (a)
# 58 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/param.h"
#define EXEC_PAGESIZE 65536


#define NGROUPS 32



#define NOGROUP (-1)


#define MAXHOSTNAMELEN 64


#define CLOCKS_PER_SEC 100
# 5 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2

extern unsigned long event;


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/binfmts.h" 1

#define _LINUX_BINFMTS_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ptrace.h" 1

#define _LINUX_PTRACE_H 





#define PTRACE_TRACEME 0
#define PTRACE_PEEKTEXT 1
#define PTRACE_PEEKDATA 2
#define PTRACE_PEEKUSR 3
#define PTRACE_POKETEXT 4
#define PTRACE_POKEDATA 5
#define PTRACE_POKEUSR 6
#define PTRACE_CONT 7
#define PTRACE_KILL 8
#define PTRACE_SINGLESTEP 9

#define PTRACE_ATTACH 0x10
#define PTRACE_DETACH 0x11

#define PTRACE_SYSCALL 24
# 40 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ptrace.h"
#define force_successful_syscall_return() do { } while (0)
# 5 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/binfmts.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h" 1
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h"
#define _LINUX_CAPABILITY_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 1

#define _LINUX_FS_H 
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/limits.h" 1

#define _LINUX_LIMITS_H 

#define NR_OPEN 1024

#define NGROUPS_MAX 32
#define ARG_MAX 131072
#define CHILD_MAX 999
#define OPEN_MAX 256
#define LINK_MAX 127
#define MAX_CANON 255
#define MAX_INPUT 255
#define NAME_MAX 255
#define PATH_MAX 4096
#define PIPE_BUF 4096
#define XATTR_NAME_MAX 255
#define XATTR_SIZE_MAX 65536
#define XATTR_LIST_MAX 65536

#define RTSIG_MAX 32
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/vfs.h" 1

#define _LINUX_VFS_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/statfs.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/statfs.h"
#define __ASM_MIPS_STATFS_H 







typedef __kernel_fsid_t fsid_t;



struct statfs {
        long f_type;
#define f_fstyp f_type
        long f_bsize;
        long f_frsize;
        long f_blocks;
        long f_bfree;
        long f_files;
        long f_ffree;


        long f_bavail;
        __kernel_fsid_t f_fsid;
        long f_namelen;
        long f_spare[6];
};
# 5 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/vfs.h" 2
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/net.h" 1
# 19 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/net.h"
#define _LINUX_NET_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/socket.h" 1

#define _LINUX_SOCKET_H 




#define _K_SS_MAXSIZE 128
#define _K_SS_ALIGNSIZE (__alignof__ (struct sockaddr *))


struct __kernel_sockaddr_storage {
        unsigned short ss_family;

        char __data[128 - sizeof(unsigned short)];


} __attribute__ ((aligned((__alignof__ (struct sockaddr *)))));



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/socket.h" 1

#define _ASM_SOCKET_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/sockios.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/sockios.h"
#define __ASM_MIPS_SOCKIOS_H 




#define FIOGETOWN _IOR('f', 123, int)
#define FIOSETOWN _IOW('f', 124, int)

#define SIOCATMARK _IOR('s', 7, int)
#define SIOCSPGRP _IOW('s', 8, pid_t)
#define SIOCGPGRP _IOR('s', 9, pid_t)

#define SIOCGSTAMP 0x8906
# 5 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/socket.h" 2






#define SOL_SOCKET 0xffff

#define SO_DEBUG 0x0001
#define SO_REUSEADDR 0x0004
#define SO_KEEPALIVE 0x0008

#define SO_DONTROUTE 0x0010
#define SO_BROADCAST 0x0020

#define SO_LINGER 0x0080

#define SO_OOBINLINE 0x0100




#define SO_TYPE 0x1008
#define SO_STYLE SO_TYPE
#define SO_ERROR 0x1007
#define SO_SNDBUF 0x1001
#define SO_RCVBUF 0x1002
#define SO_SNDLOWAT 0x1003
#define SO_RCVLOWAT 0x1004
#define SO_SNDTIMEO 0x1005
#define SO_RCVTIMEO 0x1006
#define SO_ACCEPTCONN 0x1009


#define SO_NO_CHECK 11
#define SO_PRIORITY 12
#define SO_BSDCOMPAT 14

#define SO_PASSCRED 17
#define SO_PEERCRED 18


#define SO_SECURITY_AUTHENTICATION 22
#define SO_SECURITY_ENCRYPTION_TRANSPORT 23
#define SO_SECURITY_ENCRYPTION_NETWORK 24

#define SO_BINDTODEVICE 25


#define SO_ATTACH_FILTER 26
#define SO_DETACH_FILTER 27

#define SO_PEERNAME 28
#define SO_TIMESTAMP 29
#define SCM_TIMESTAMP SO_TIMESTAMP




#define SOCK_DGRAM 1
#define SOCK_STREAM 2
#define SOCK_RAW 3
#define SOCK_RDM 4
#define SOCK_SEQPACKET 5
#define SOCK_PACKET 10




#define SOCK_MAX (SOCK_PACKET+1)
# 22 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/socket.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sockios.h" 1
# 19 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sockios.h"
#define _LINUX_SOCKIOS_H 




#define SIOCINQ FIONREAD
#define SIOCOUTQ TIOCOUTQ


#define SIOCADDRT 0x890B
#define SIOCDELRT 0x890C
#define SIOCRTMSG 0x890D


#define SIOCGIFNAME 0x8910
#define SIOCSIFLINK 0x8911
#define SIOCGIFCONF 0x8912
#define SIOCGIFFLAGS 0x8913
#define SIOCSIFFLAGS 0x8914
#define SIOCGIFADDR 0x8915
#define SIOCSIFADDR 0x8916
#define SIOCGIFDSTADDR 0x8917
#define SIOCSIFDSTADDR 0x8918
#define SIOCGIFBRDADDR 0x8919
#define SIOCSIFBRDADDR 0x891a
#define SIOCGIFNETMASK 0x891b
#define SIOCSIFNETMASK 0x891c
#define SIOCGIFMETRIC 0x891d
#define SIOCSIFMETRIC 0x891e
#define SIOCGIFMEM 0x891f
#define SIOCSIFMEM 0x8920
#define SIOCGIFMTU 0x8921
#define SIOCSIFMTU 0x8922
#define SIOCSIFNAME 0x8923
#define SIOCSIFHWADDR 0x8924
#define SIOCGIFENCAP 0x8925
#define SIOCSIFENCAP 0x8926
#define SIOCGIFHWADDR 0x8927
#define SIOCGIFSLAVE 0x8929
#define SIOCSIFSLAVE 0x8930
#define SIOCADDMULTI 0x8931
#define SIOCDELMULTI 0x8932
#define SIOCGIFINDEX 0x8933
#define SIOGIFINDEX SIOCGIFINDEX
#define SIOCSIFPFLAGS 0x8934
#define SIOCGIFPFLAGS 0x8935
#define SIOCDIFADDR 0x8936
#define SIOCSIFHWBROADCAST 0x8937
#define SIOCGIFCOUNT 0x8938

#define SIOCGIFBR 0x8940
#define SIOCSIFBR 0x8941

#define SIOCGIFTXQLEN 0x8942
#define SIOCSIFTXQLEN 0x8943

#define SIOCGIFDIVERT 0x8944
#define SIOCSIFDIVERT 0x8945

#define SIOCETHTOOL 0x8946

#define SIOCGMIIPHY 0x8947
#define SIOCGMIIREG 0x8948
#define SIOCSMIIREG 0x8949

#define SIOCWANDEV 0x894A



#define SIOCDARP 0x8953
#define SIOCGARP 0x8954
#define SIOCSARP 0x8955


#define SIOCDRARP 0x8960
#define SIOCGRARP 0x8961
#define SIOCSRARP 0x8962



#define SIOCGIFMAP 0x8970
#define SIOCSIFMAP 0x8971



#define SIOCADDDLCI 0x8980
#define SIOCDELDLCI 0x8981

#define SIOCGIFVLAN 0x8982
#define SIOCSIFVLAN 0x8983



#define SIOCBONDENSLAVE 0x8990
#define SIOCBONDRELEASE 0x8991
#define SIOCBONDSETHWADDR 0x8992
#define SIOCBONDSLAVEINFOQUERY 0x8993
#define SIOCBONDINFOQUERY 0x8994
#define SIOCBONDCHANGEACTIVE 0x8995
# 130 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sockios.h"
#define SIOCDEVPRIVATE 0x89F0





#define SIOCPROTOPRIVATE 0x89E0
# 23 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/socket.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/uio.h" 1

#define __LINUX_UIO_H 
# 19 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/uio.h"
struct iovec
{
        void *iov_base;
        __kernel_size_t iov_len;
};





#define UIO_FASTIOV 8
#define UIO_MAXIOV 1024
# 24 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/socket.h" 2


typedef unsigned short sa_family_t;





struct sockaddr {
        sa_family_t sa_family;
        char sa_data[14];
};

struct linger {
        int l_onoff;
        int l_linger;
};

#define sockaddr_storage __kernel_sockaddr_storage







struct msghdr {
        void * msg_name;
        int msg_namelen;
        struct iovec * msg_iov;
        __kernel_size_t msg_iovlen;
        void * msg_control;
        __kernel_size_t msg_controllen;
        unsigned msg_flags;
};







struct cmsghdr {
        __kernel_size_t cmsg_len;
        int cmsg_level;
        int cmsg_type;
};






#define __CMSG_NXTHDR(ctl,len,cmsg) __cmsg_nxthdr((ctl),(len),(cmsg))
#define CMSG_NXTHDR(mhdr,cmsg) cmsg_nxthdr((mhdr), (cmsg))

#define CMSG_ALIGN(len) ( ((len)+sizeof(long)-1) & ~(sizeof(long)-1) )

#define CMSG_DATA(cmsg) ((void *)((char *)(cmsg) + CMSG_ALIGN(sizeof(struct cmsghdr))))
#define CMSG_SPACE(len) (CMSG_ALIGN(sizeof(struct cmsghdr)) + CMSG_ALIGN(len))
#define CMSG_LEN(len) (CMSG_ALIGN(sizeof(struct cmsghdr)) + (len))

#define __CMSG_FIRSTHDR(ctl,len) ((len) >= sizeof(struct cmsghdr) ? (struct cmsghdr *)(ctl) : (struct cmsghdr *)NULL)


#define CMSG_FIRSTHDR(msg) __CMSG_FIRSTHDR((msg)->msg_control, (msg)->msg_controllen)
#define CMSG_OK(mhdr,cmsg) ((cmsg)->cmsg_len >= sizeof(struct cmsghdr) && (cmsg)->cmsg_len <= (unsigned long) ((mhdr)->msg_controllen - ((char *)(cmsg) - (char *)(mhdr)->msg_control)))
# 100 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/socket.h"
#define __KINLINE static inline
# 123 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/socket.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct cmsghdr * __cmsg_nxthdr(void *__ctl, __kernel_size_t __size,
                                               struct cmsghdr *__cmsg)
{
        struct cmsghdr * __ptr;

        __ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) + ( ((__cmsg->cmsg_len)+sizeof(long)-1) & ~(sizeof(long)-1) ));
        if ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) > __size)
                return (struct cmsghdr *)0;

        return __ptr;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct cmsghdr * cmsg_nxthdr (struct msghdr *__msg, struct cmsghdr *__cmsg)
{
        return __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
}



#define SCM_RIGHTS 0x01
#define SCM_CREDENTIALS 0x02

struct ucred {
        __u32 pid;
        __u32 uid;
        __u32 gid;
};


#define AF_UNSPEC 0
#define AF_UNIX 1
#define AF_LOCAL 1
#define AF_INET 2
#define AF_AX25 3
#define AF_IPX 4
#define AF_APPLETALK 5
#define AF_NETROM 6
#define AF_BRIDGE 7
#define AF_ATMPVC 8
#define AF_X25 9
#define AF_INET6 10
#define AF_ROSE 11
#define AF_DECnet 12
#define AF_NETBEUI 13
#define AF_SECURITY 14
#define AF_KEY 15
#define AF_NETLINK 16
#define AF_ROUTE AF_NETLINK
#define AF_PACKET 17
#define AF_ASH 18
#define AF_ECONET 19
#define AF_ATMSVC 20
#define AF_SNA 22
#define AF_IRDA 23
#define AF_PPPOX 24
#define AF_WANPIPE 25
#define AF_LLC 26
#define AF_BLUETOOTH 31
#define AF_MAX 32


#define PF_UNSPEC AF_UNSPEC
#define PF_UNIX AF_UNIX
#define PF_LOCAL AF_LOCAL
#define PF_INET AF_INET
#define PF_AX25 AF_AX25
#define PF_IPX AF_IPX
#define PF_APPLETALK AF_APPLETALK
#define PF_NETROM AF_NETROM
#define PF_BRIDGE AF_BRIDGE
#define PF_ATMPVC AF_ATMPVC
#define PF_X25 AF_X25
#define PF_INET6 AF_INET6
#define PF_ROSE AF_ROSE
#define PF_DECnet AF_DECnet
#define PF_NETBEUI AF_NETBEUI
#define PF_SECURITY AF_SECURITY
#define PF_KEY AF_KEY
#define PF_NETLINK AF_NETLINK
#define PF_ROUTE AF_ROUTE
#define PF_PACKET AF_PACKET
#define PF_ASH AF_ASH
#define PF_ECONET AF_ECONET
#define PF_ATMSVC AF_ATMSVC
#define PF_SNA AF_SNA
#define PF_IRDA AF_IRDA
#define PF_PPPOX AF_PPPOX
#define PF_WANPIPE AF_WANPIPE
#define PF_LLC AF_LLC
#define PF_BLUETOOTH AF_BLUETOOTH
#define PF_MAX AF_MAX


#define SOMAXCONN 128





#define MSG_OOB 1
#define MSG_PEEK 2
#define MSG_DONTROUTE 4
#define MSG_TRYHARD 4
#define MSG_CTRUNC 8
#define MSG_PROBE 0x10
#define MSG_TRUNC 0x20
#define MSG_DONTWAIT 0x40
#define MSG_EOR 0x80
#define MSG_WAITALL 0x100
#define MSG_FIN 0x200
#define MSG_SYN 0x400
#define MSG_CONFIRM 0x800
#define MSG_RST 0x1000
#define MSG_ERRQUEUE 0x2000
#define MSG_NOSIGNAL 0x4000
#define MSG_MORE 0x8000

#define MSG_EOF MSG_FIN



#define SOL_IP 0

#define SOL_TCP 6
#define SOL_UDP 17
#define SOL_IPV6 41
#define SOL_ICMPV6 58
#define SOL_SCTP 132
#define SOL_RAW 255
#define SOL_IPX 256
#define SOL_AX25 257
#define SOL_ATALK 258
#define SOL_NETROM 259
#define SOL_ROSE 260
#define SOL_DECNET 261
#define SOL_X25 262
#define SOL_PACKET 263
#define SOL_ATM 264
#define SOL_AAL 265
#define SOL_IRDA 266
#define SOL_NETBEUI 267
#define SOL_LLC 268


#define IPX_TYPE 1


extern int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
extern int memcpy_fromiovecend(unsigned char *kdata, struct iovec *iov,
                                int offset, int len);
extern int csum_partial_copy_fromiovecend(unsigned char *kdata,
                                          struct iovec *iov,
                                          int offset,
                                          unsigned int len, int *csump);

extern int verify_iovec(struct msghdr *m, struct iovec *iov, char *address, int mode);
extern int memcpy_toiovec(struct iovec *v, unsigned char *kdata, int len);
extern void memcpy_tokerneliovec(struct iovec *iov, unsigned char *kdata, int len);
extern int move_addr_to_user(void *kaddr, int klen, void *uaddr, int *ulen);
extern int move_addr_to_kernel(void *uaddr, int ulen, void *kaddr);
extern int put_cmsg(struct msghdr*, int level, int type, int len, void *data);
# 23 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/net.h" 2


struct poll_table_struct;

#define NPROTO 32


#define SYS_SOCKET 1
#define SYS_BIND 2
#define SYS_CONNECT 3
#define SYS_LISTEN 4
#define SYS_ACCEPT 5
#define SYS_GETSOCKNAME 6
#define SYS_GETPEERNAME 7
#define SYS_SOCKETPAIR 8
#define SYS_SEND 9
#define SYS_RECV 10
#define SYS_SENDTO 11
#define SYS_RECVFROM 12
#define SYS_SHUTDOWN 13
#define SYS_SETSOCKOPT 14
#define SYS_GETSOCKOPT 15
#define SYS_SENDMSG 16
#define SYS_RECVMSG 17


typedef enum {
  SS_FREE = 0,
  SS_UNCONNECTED,
  SS_CONNECTING,
  SS_CONNECTED,
  SS_DISCONNECTING
} socket_state;

#define __SO_ACCEPTCON (1<<16)



#define SOCK_ASYNC_NOSPACE 0
#define SOCK_ASYNC_WAITDATA 1
#define SOCK_NOSPACE 2

struct socket
{
        socket_state state;

        unsigned long flags;
        struct proto_ops *ops;
        struct inode *inode;
        struct fasync_struct *fasync_list;
        struct file *file;
        struct sock *sk;
        wait_queue_head_t wait;

        short type;
        unsigned char passcred;
};

#define SOCK_INODE(S) ((S)->inode)

struct scm_cookie;
struct vm_area_struct;
struct page;

struct proto_ops {
  int family;

  int (*release) (struct socket *sock);
  int (*bind) (struct socket *sock, struct sockaddr *umyaddr,
                         int sockaddr_len);
  int (*connect) (struct socket *sock, struct sockaddr *uservaddr,
                         int sockaddr_len, int flags);
  int (*socketpair) (struct socket *sock1, struct socket *sock2);
  int (*accept) (struct socket *sock, struct socket *newsock,
                         int flags);
  int (*getname) (struct socket *sock, struct sockaddr *uaddr,
                         int *usockaddr_len, int peer);
  unsigned int (*poll) (struct file *file, struct socket *sock, struct poll_table_struct *wait);
  int (*ioctl) (struct socket *sock, unsigned int cmd,
                         unsigned long arg);
  int (*listen) (struct socket *sock, int len);
  int (*shutdown) (struct socket *sock, int flags);
  int (*setsockopt) (struct socket *sock, int level, int optname,
                         char *optval, int optlen);
  int (*getsockopt) (struct socket *sock, int level, int optname,
                         char *optval, int *optlen);
  int (*sendmsg) (struct socket *sock, struct msghdr *m, int total_len, struct scm_cookie *scm);
  int (*recvmsg) (struct socket *sock, struct msghdr *m, int total_len, int flags, struct scm_cookie *scm);
  int (*mmap) (struct file *file, struct socket *sock, struct vm_area_struct * vma);
  ssize_t (*sendpage) (struct socket *sock, struct page *page, int offset, size_t size, int flags);
};

struct net_proto_family
{
        int family;
        int (*create)(struct socket *sock, int protocol);


        short authentication;
        short encryption;
        short encrypt_net;
};

struct net_proto
{
        const char *name;
        void (*init_func)(struct net_proto *);
};

extern int sock_wake_async(struct socket *sk, int how, int band);
extern int sock_register(struct net_proto_family *fam);
extern int sock_unregister(int family);
extern struct socket *sock_alloc(void);
extern int sock_create(int family, int type, int proto, struct socket **);
extern void sock_release(struct socket *);
extern int sock_sendmsg(struct socket *, struct msghdr *m, int len);
extern int sock_recvmsg(struct socket *, struct msghdr *m, int len, int flags);
extern int sock_readv_writev(int type, struct inode * inode, struct file * file,
                                  const struct iovec * iov, long count, long size);
extern struct socket *sockfd_lookup(int fd, int *err);

extern int sock_map_fd(struct socket *sock);
extern int net_ratelimit(void);
extern unsigned long net_random(void);
extern void net_srandom(unsigned long);


#define SOCKOPS_WRAPPED(name) name
#define SOCKOPS_WRAP(name,fam) 
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/kdev_t.h" 1

#define _LINUX_KDEV_T_H 
# 64 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/kdev_t.h"
#define MINORBITS 8
#define MINORMASK ((1U << MINORBITS) - 1)

typedef unsigned short kdev_t;

#define MAJOR(dev) ((unsigned int) ((dev) >> MINORBITS))
#define MINOR(dev) ((unsigned int) ((dev) & MINORMASK))
#define HASHDEV(dev) ((unsigned int) (dev))
#define NODEV 0
#define MKDEV(ma,mi) (((ma) << MINORBITS) | (mi))
#define B_FREE 0xffff

extern const char * kdevname(kdev_t);


#define mk_kdev(a,b) MKDEV(a,b)
#define major(d) MAJOR(d)
#define minor(d) MINOR(d)
#define kdev_same(a,b) ((a) == (b))
#define kdev_none(d) (!(d))
#define kdev_val(d) ((unsigned int)(d))
#define val_to_kdev(d) ((kdev_t)(d))






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int kdev_t_to_nr(kdev_t dev) {
        return (((unsigned int) ((dev) >> 8))<<8) | ((unsigned int) ((dev) & ((1U << 8) - 1)));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) kdev_t to_kdev_t(int dev)
{
        int major, minor;
# 107 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/kdev_t.h"
        major = (dev >> 8);
        minor = (dev & 0xff);

        return (((major) << 8) | (minor));
}
# 17 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ioctl.h" 1

#define _LINUX_IOCTL_H 
# 18 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dcache.h" 1

#define __LINUX_DCACHE_H 




# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mount.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mount.h"
#define _LINUX_MOUNT_H 


#define MNT_NOSUID 1
#define MNT_NODEV 2
#define MNT_NOEXEC 4

struct vfsmount
{
        struct list_head mnt_hash;
        struct vfsmount *mnt_parent;
        struct dentry *mnt_mountpoint;
        struct dentry *mnt_root;
        struct super_block *mnt_sb;
        struct list_head mnt_mounts;
        struct list_head mnt_child;
        atomic_t mnt_count;
        int mnt_flags;
        char *mnt_devname;
        struct list_head mnt_list;
};

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct vfsmount *mntget(struct vfsmount *mnt)
{
        if (mnt)
                atomic_add(1,(&mnt->mnt_count));
        return mnt;
}

extern void __mntput(struct vfsmount *mnt);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void mntput(struct vfsmount *mnt)
{
        if (mnt) {
                if ((atomic_sub_return(1, (&mnt->mnt_count)) == 0))
                        __mntput(mnt);
        }
}
# 8 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dcache.h" 2
# 19 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dcache.h"
#define IS_ROOT(x) ((x) == (x)->d_parent)





struct qstr {
        const unsigned char * name;
        unsigned int len;
        unsigned int hash;
};

struct dentry_stat_t {
        int nr_dentry;
        int nr_unused;
        int age_limit;
        int want_pages;
        int dummy[2];
};
extern struct dentry_stat_t dentry_stat;



#define init_name_hash() 0


static __inline__ __attribute__((always_inline)) unsigned long partial_name_hash(unsigned long c, unsigned long prevhash)
{
        return (prevhash + (c << 4) + (c >> 4)) * 11;
}


static __inline__ __attribute__((always_inline)) unsigned long end_name_hash(unsigned long hash)
{
        return (unsigned int) hash;
}


static __inline__ __attribute__((always_inline)) unsigned int full_name_hash(const unsigned char * name, unsigned int len)
{
        unsigned long hash = 0;
        while (len--)
                hash = partial_name_hash(*name++, hash);
        return end_name_hash(hash);
}

#define DNAME_INLINE_LEN 16

struct dentry {
        atomic_t d_count;
        unsigned int d_flags;
        struct inode * d_inode;
        struct dentry * d_parent;
        struct list_head d_hash;
        struct list_head d_lru;
        struct list_head d_child;
        struct list_head d_subdirs;
        struct list_head d_alias;
        int d_mounted;
        struct qstr d_name;
        unsigned long d_time;
        struct dentry_operations *d_op;
        struct super_block * d_sb;
        unsigned long d_vfs_flags;
        void * d_fsdata;
        unsigned char d_iname[16];
};

struct dentry_operations {
        int (*d_revalidate)(struct dentry *, int);
        int (*d_hash) (struct dentry *, struct qstr *);
        int (*d_compare) (struct dentry *, struct qstr *, struct qstr *);
        int (*d_delete)(struct dentry *);
        void (*d_release)(struct dentry *);
        void (*d_iput)(struct dentry *, struct inode *);
};
# 115 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dcache.h"
#define DCACHE_AUTOFS_PENDING 0x0001
#define DCACHE_NFSFS_RENAMED 0x0002



#define DCACHE_NFSD_DISCONNECTED 0x0004





#define DCACHE_REFERENCED 0x0008

extern spinlock_t dcache_lock;
# 147 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dcache.h"
static __inline__ __attribute__((always_inline)) void d_drop(struct dentry * dentry)
{
        (void)(&dcache_lock);
        list_del(&dentry->d_hash);
        do { (&dentry->d_hash)->next = (&dentry->d_hash); (&dentry->d_hash)->prev = (&dentry->d_hash); } while (0);
        do { } while(0);
}

static __inline__ __attribute__((always_inline)) int dname_external(struct dentry *d)
{
        return d->d_name.name != d->d_iname;
}




extern void d_instantiate(struct dentry *, struct inode *);
extern void d_delete(struct dentry *);


extern struct dentry * d_alloc(struct dentry *, const struct qstr *);
extern void shrink_dcache_sb(struct super_block *);
extern void shrink_dcache_parent(struct dentry *);
extern int d_invalidate(struct dentry *);

#define shrink_dcache() prune_dcache(0)
struct zone_struct;

extern int shrink_dcache_memory(int, unsigned int);
extern void prune_dcache(int);


extern int shrink_icache_memory(int, int);
extern void prune_icache(int);


extern int shrink_dqcache_memory(int, unsigned int);


extern struct dentry * d_alloc_root(struct inode *);


extern void d_genocide(struct dentry *);

extern struct dentry *d_find_alias(struct inode *);
extern void d_prune_aliases(struct inode *);


extern int have_submounts(struct dentry *);




extern void d_rehash(struct dentry *);
# 211 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dcache.h"
static __inline__ __attribute__((always_inline)) void d_add(struct dentry * entry, struct inode * inode)
{
        d_instantiate(entry, inode);
        d_rehash(entry);
}


extern void d_move(struct dentry *, struct dentry *);


extern struct dentry * d_lookup(struct dentry *, struct qstr *);


extern int d_validate(struct dentry *, struct dentry *);

extern char * __d_path(struct dentry *, struct vfsmount *, struct dentry *,
        struct vfsmount *, char *, int);
# 244 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dcache.h"
static __inline__ __attribute__((always_inline)) struct dentry * dget(struct dentry *dentry)
{
        if (dentry) {
                if (!((&dentry->d_count)->counter))
                        __out_of_line_bug(248);
                atomic_add(1,(&dentry->d_count));
        }
        return dentry;
}

extern struct dentry * dget_locked(struct dentry *);
# 263 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dcache.h"
static __inline__ __attribute__((always_inline)) int d_unhashed(struct dentry *dentry)
{
        return list_empty(&dentry->d_hash);
}

extern void dput(struct dentry *);

static __inline__ __attribute__((always_inline)) int d_mountpoint(struct dentry *dentry)
{
        return dentry->d_mounted;
}

extern struct vfsmount *lookup_mnt(struct vfsmount *, struct dentry *);
# 20 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/stat.h" 1

#define _LINUX_STAT_H 



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/stat.h" 1

#define _ASM_STAT_H 



struct stat {
        dev_t st_dev;
        long st_pad1[3];
        ino_t st_ino;
        mode_t st_mode;
        nlink_t st_nlink;
        uid_t st_uid;
        gid_t st_gid;
        dev_t st_rdev;
        long st_pad2[2];
        off_t st_size;
        long st_pad3;




        time_t st_atime;
        long reserved0;
        time_t st_mtime;
        long reserved1;
        time_t st_ctime;
        long reserved2;
        long st_blksize;
        long st_blocks;
        long st_pad4[14];
};







struct stat64 {
        unsigned long st_dev;
        unsigned long st_pad0[3];

        unsigned long long st_ino;

        mode_t st_mode;
        nlink_t st_nlink;

        uid_t st_uid;
        gid_t st_gid;

        unsigned long st_rdev;
        unsigned long st_pad1[3];

        long long st_size;





        time_t st_atime;
        unsigned long reserved0;

        time_t st_mtime;
        unsigned long reserved1;

        time_t st_ctime;
        unsigned long reserved2;

        unsigned long st_blksize;
        unsigned long st_pad2;

        long long st_blocks;
};
# 7 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/stat.h" 2





#define S_IFMT 00170000
#define S_IFSOCK 0140000
#define S_IFLNK 0120000
#define S_IFREG 0100000
#define S_IFBLK 0060000
#define S_IFDIR 0040000
#define S_IFCHR 0020000
#define S_IFIFO 0010000
#define S_ISUID 0004000
#define S_ISGID 0002000
#define S_ISVTX 0001000

#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)

#define S_IRWXU 00700
#define S_IRUSR 00400
#define S_IWUSR 00200
#define S_IXUSR 00100

#define S_IRWXG 00070
#define S_IRGRP 00040
#define S_IWGRP 00020
#define S_IXGRP 00010

#define S_IRWXO 00007
#define S_IROTH 00004
#define S_IWOTH 00002
#define S_IXOTH 00001




#define S_IRWXUGO (S_IRWXU|S_IRWXG|S_IRWXO)
#define S_IALLUGO (S_ISUID|S_ISGID|S_ISVTX|S_IRWXUGO)
#define S_IRUGO (S_IRUSR|S_IRGRP|S_IROTH)
#define S_IWUGO (S_IWUSR|S_IWGRP|S_IWOTH)
#define S_IXUGO (S_IXUSR|S_IXGRP|S_IXOTH)
# 21 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2







struct poll_table_struct;
# 42 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
#undef NR_OPEN
#define NR_OPEN (1024*1024)
#define INR_OPEN 1024

#define BLOCK_SIZE_BITS 10
#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)


struct files_stat_struct {
        int nr_files;
        int nr_free_files;
        int max_files;
};
extern struct files_stat_struct files_stat;

struct inodes_stat_t {
        int nr_inodes;
        int nr_unused;
        int dummy[5];
};
extern struct inodes_stat_t inodes_stat;

extern int leases_enable, dir_notify_enable, lease_break_time;

#define NR_FILE 8192
#define NR_RESERVED_FILES 10
#define NR_SUPER 256

#define MAY_EXEC 1
#define MAY_WRITE 2
#define MAY_READ 4

#define FMODE_READ 1
#define FMODE_WRITE 2

#define READ 0
#define WRITE 1
#define READA 2
#define SPECIAL 4

#define SEL_IN 1
#define SEL_OUT 2
#define SEL_EX 4


#define FS_REQUIRES_DEV 1
#define FS_NO_DCACHE 2
#define FS_NO_PRELIM 4


#define FS_SINGLE 8
#define FS_NOMOUNT 16
#define FS_LITTER 32
#define FS_ODD_RENAME 32768





#define MS_RDONLY 1
#define MS_NOSUID 2
#define MS_NODEV 4
#define MS_NOEXEC 8
#define MS_SYNCHRONOUS 16
#define MS_REMOUNT 32
#define MS_MANDLOCK 64
#define MS_NOATIME 1024
#define MS_NODIRATIME 2048
#define MS_BIND 4096
#define MS_MOVE 8192
#define MS_REC 16384
#define MS_VERBOSE 32768
#define MS_ACTIVE (1<<30)
#define MS_NOUSER (1<<31)




#define MS_RMT_MASK (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_NOATIME| MS_NODIRATIME)





#define MS_MGC_VAL 0xC0ED0000
#define MS_MGC_MSK 0xffff0000



#define S_SYNC 1
#define S_NOATIME 2
#define S_QUOTA 4
#define S_APPEND 8
#define S_IMMUTABLE 16
#define S_DEAD 32
#define S_NOQUOTA 64
# 152 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
#define __IS_FLG(inode,flg) ((inode)->i_sb->s_flags & (flg))

#define IS_RDONLY(inode) ((inode)->i_sb->s_flags & MS_RDONLY)
#define IS_SYNC(inode) (__IS_FLG(inode, MS_SYNCHRONOUS) || ((inode)->i_flags & S_SYNC))
#define IS_MANDLOCK(inode) __IS_FLG(inode, MS_MANDLOCK)

#define IS_QUOTAINIT(inode) ((inode)->i_flags & S_QUOTA)
#define IS_NOQUOTA(inode) ((inode)->i_flags & S_NOQUOTA)
#define IS_APPEND(inode) ((inode)->i_flags & S_APPEND)
#define IS_IMMUTABLE(inode) ((inode)->i_flags & S_IMMUTABLE)
#define IS_NOATIME(inode) (__IS_FLG(inode, MS_NOATIME) || ((inode)->i_flags & S_NOATIME))
#define IS_NODIRATIME(inode) __IS_FLG(inode, MS_NODIRATIME)

#define IS_DEADDIR(inode) ((inode)->i_flags & S_DEAD)




#define BLKROSET _IO(0x12,93)
#define BLKROGET _IO(0x12,94)
#define BLKRRPART _IO(0x12,95)
#define BLKGETSIZE _IO(0x12,96)
#define BLKFLSBUF _IO(0x12,97)
#define BLKRASET _IO(0x12,98)
#define BLKRAGET _IO(0x12,99)
#define BLKFRASET _IO(0x12,100)
#define BLKFRAGET _IO(0x12,101)
#define BLKSECTSET _IO(0x12,102)
#define BLKSECTGET _IO(0x12,103)
#define BLKSSZGET _IO(0x12,104)
# 190 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
#define BLKBSZGET _IOR(0x12,112,sizeof(int))
#define BLKBSZSET _IOW(0x12,113,sizeof(int))
#define BLKGETSIZE64 _IOR(0x12,114,sizeof(u64))

#define BMAP_IOCTL 1
#define FIBMAP _IO(0x00,1)
#define FIGETBSZ _IO(0x00,2)



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/semaphore.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/semaphore.h"
#define _ASM_SEMAPHORE_H 





# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/rwsem.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/rwsem.h"
#define _LINUX_RWSEM_H 



#define RWSEM_DEBUG 0
# 24 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/rwsem.h"
struct rw_semaphore;


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/rwsem-spinlock.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/rwsem-spinlock.h"
#define _LINUX_RWSEM_SPINLOCK_H 
# 24 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/rwsem-spinlock.h"
struct rwsem_waiter;
# 33 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/rwsem-spinlock.h"
struct rw_semaphore {
        __s32 activity;
        spinlock_t wait_lock;
        struct list_head wait_list;



};







#define __RWSEM_DEBUG_INIT 


#define __RWSEM_INITIALIZER(name) { 0, SPIN_LOCK_UNLOCKED, LIST_HEAD_INIT((name).wait_list) __RWSEM_DEBUG_INIT }


#define DECLARE_RWSEM(name) struct rw_semaphore name = __RWSEM_INITIALIZER(name)


extern void init_rwsem(struct rw_semaphore *sem);
extern void __down_read(struct rw_semaphore *sem);
extern int __down_read_trylock(struct rw_semaphore *sem);
extern void __down_write(struct rw_semaphore *sem);
extern int __down_write_trylock(struct rw_semaphore *sem);
extern void __up_read(struct rw_semaphore *sem);
extern void __up_write(struct rw_semaphore *sem);
# 28 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/rwsem.h" 2
# 36 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/rwsem.h"
#define rwsemtrace(SEM,FMT) 






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void down_read(struct rw_semaphore *sem)
{
        ;
        __down_read(sem);
        ;
}




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int down_read_trylock(struct rw_semaphore *sem)
{
        int ret;
        ;
        ret = __down_read_trylock(sem);
        ;
        return ret;
}




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void down_write(struct rw_semaphore *sem)
{
        ;
        __down_write(sem);
        ;
}




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int down_write_trylock(struct rw_semaphore *sem)
{
        int ret;
        ;
        ret = __down_write_trylock(sem);
        ;
        return ret;
}




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void up_read(struct rw_semaphore *sem)
{
        ;
        __up_read(sem);
        ;
}




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void up_write(struct rw_semaphore *sem)
{
        ;
        __up_write(sem);
        ;
}
# 19 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/semaphore.h" 2


struct semaphore {




        atomic_t waking;
        atomic_t count;

        wait_queue_head_t wait;



} __attribute__((aligned(8)));




#define __SEM_DEBUG_INIT(name) 


#define __SEMAPHORE_INITIALIZER(name,_count) { .count = ATOMIC_INIT(_count), .waking = ATOMIC_INIT(0), .wait = __WAIT_QUEUE_HEAD_INITIALIZER((name).wait) __SEM_DEBUG_INIT(name) }






#define __MUTEX_INITIALIZER(name) __SEMAPHORE_INITIALIZER(name, 1)

#define __DECLARE_SEMAPHORE_GENERIC(name,count) struct semaphore name = __SEMAPHORE_INITIALIZER(name, count)


#define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name, 1)
#define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void sema_init (struct semaphore *sem, int val)
{
        ((&sem->count)->counter = (val));
        ((&sem->waking)->counter = (0));
        init_waitqueue_head(&sem->wait);



}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void init_MUTEX (struct semaphore *sem)
{
        sema_init(sem, 1);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void init_MUTEX_LOCKED (struct semaphore *sem)
{
        sema_init(sem, 0);
}






extern spinlock_t semaphore_lock;


extern void __down_failed(struct semaphore * sem);
extern int __down_failed_interruptible(struct semaphore * sem);
extern void __up_wakeup(struct semaphore * sem);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void down(struct semaphore * sem)
{
        int count;




        count = atomic_sub_return(1,(&sem->count));
        if (__builtin_expect((count < 0),0))
                __down_failed(sem);
}





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int down_interruptible(struct semaphore * sem)
{
        int count;




        count = atomic_sub_return(1,(&sem->count));
        if (__builtin_expect((count < 0),0))
                return __down_failed_interruptible(sem);

        return 0;
}
# 220 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/semaphore.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int down_trylock(struct semaphore * sem)
{
        unsigned long flags;
        int count, waking;
        int ret = 0;





        do { __asm__ __volatile__( "__save_and_cli\t%0" : "=r" (flags) : : "memory"); (void)(&semaphore_lock); } while (0);
        count = ((&sem->count)->counter) - 1;
        ((&sem->count)->counter = (count));
        if (__builtin_expect((count < 0),0)) {
                waking = ((&sem->waking)->counter);
                if (waking <= 0) {
                        ((&sem->count)->counter = (count + 1));
                        ret = 1;
                } else {
                        ((&sem->waking)->counter = (waking - 1));
                        ret = 0;
                }
        }
        do { do { } while(0); do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0); } while (0);

        return ret;
}





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void up(struct semaphore * sem)
{
        unsigned long flags;
        int count, waking;
# 266 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/semaphore.h"
        do { __asm__ __volatile__( "__save_and_cli\t%0" : "=r" (flags) : : "memory"); (void)(&semaphore_lock); } while (0);
        count = ((&sem->count)->counter) + 1;
        waking = ((&sem->waking)->counter);
        if (count <= 0)
                waking++;
        ((&sem->count)->counter = (count));
        ((&sem->waking)->counter = (waking));
        do { do { } while(0); do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0); } while (0);

        if (__builtin_expect((count <= 0),0))
                __up_wakeup(sem);
}



static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int sem_getcount(struct semaphore *sem)
{
        return ((&sem->count)->counter);
}
# 201 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2


extern void update_atime (struct inode *);
extern void update_mctime (struct inode *);
#define UPDATE_ATIME(inode) update_atime (inode)

extern void buffer_init(unsigned long);
extern void inode_init(unsigned long);
extern void mnt_init(unsigned long);
extern void files_init(unsigned long mempages);


enum bh_state_bits {
        BH_Uptodate,
        BH_Dirty,
        BH_Lock,
        BH_Req,
        BH_Mapped,
        BH_New,
        BH_Async,
        BH_Wait_IO,
        BH_Launder,
        BH_Attached,
        BH_JBD,
        BH_Sync,
        BH_Delay,

        BH_PrivateStart,


};

#define MAX_BUF_PER_PAGE (PAGE_CACHE_SIZE / 512)
# 246 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
struct buffer_head {

        struct buffer_head *b_next;
        unsigned long b_blocknr;
        unsigned short b_size;
        unsigned short b_list;
        kdev_t b_dev;

        atomic_t b_count;
        kdev_t b_rdev;
        unsigned long b_state;
        unsigned long b_flushtime;

        struct buffer_head *b_next_free;
        struct buffer_head *b_prev_free;
        struct buffer_head *b_this_page;
        struct buffer_head *b_reqnext;

        struct buffer_head **b_pprev;
        char * b_data;
        struct page *b_page;
        void (*b_end_io)(struct buffer_head *bh, int uptodate);
        void *b_private;

        unsigned long b_rsector;
        wait_queue_head_t b_wait;

        struct list_head b_inode_buffers;
};

typedef void (bh_end_io_t)(struct buffer_head *bh, int uptodate);
void init_buffer(struct buffer_head *, bh_end_io_t *, void *);

#define __buffer_state(bh,state) (((bh)->b_state & (1UL << BH_ ##state)) != 0)

#define buffer_uptodate(bh) __buffer_state(bh,Uptodate)
#define buffer_dirty(bh) __buffer_state(bh,Dirty)
#define buffer_locked(bh) __buffer_state(bh,Lock)
#define buffer_req(bh) __buffer_state(bh,Req)
#define buffer_mapped(bh) __buffer_state(bh,Mapped)
#define buffer_new(bh) __buffer_state(bh,New)
#define buffer_async(bh) __buffer_state(bh,Async)
#define buffer_launder(bh) __buffer_state(bh,Launder)
#define buffer_delay(bh) __buffer_state(bh,Delay)

#define bh_offset(bh) ((unsigned long)(bh)->b_data & ~PAGE_MASK)

extern void set_bh_page(struct buffer_head *bh, struct page *page, unsigned long offset);

#define touch_buffer(bh) mark_page_accessed(bh->b_page)


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pipe_fs_i.h" 1

#define _LINUX_PIPE_FS_I_H 

#define PIPEFS_MAGIC 0x50495045
struct pipe_inode_info {
        wait_queue_head_t wait;
        char *base;
        unsigned int len;
        unsigned int start;
        unsigned int readers;
        unsigned int writers;
        unsigned int waiting_readers;
        unsigned int waiting_writers;
        unsigned int r_counter;
        unsigned int w_counter;
};



#define PIPE_SIZE PAGE_SIZE

#define PIPE_SEM(inode) (&(inode).i_sem)
#define PIPE_WAIT(inode) (&(inode).i_pipe->wait)
#define PIPE_BASE(inode) ((inode).i_pipe->base)
#define PIPE_START(inode) ((inode).i_pipe->start)
#define PIPE_LEN(inode) ((inode).i_pipe->len)
#define PIPE_READERS(inode) ((inode).i_pipe->readers)
#define PIPE_WRITERS(inode) ((inode).i_pipe->writers)
#define PIPE_WAITING_READERS(inode) ((inode).i_pipe->waiting_readers)
#define PIPE_WAITING_WRITERS(inode) ((inode).i_pipe->waiting_writers)
#define PIPE_RCOUNTER(inode) ((inode).i_pipe->r_counter)
#define PIPE_WCOUNTER(inode) ((inode).i_pipe->w_counter)

#define PIPE_EMPTY(inode) (PIPE_LEN(inode) == 0)
#define PIPE_FULL(inode) (PIPE_LEN(inode) == PIPE_SIZE)
#define PIPE_FREE(inode) (PIPE_SIZE - PIPE_LEN(inode))
#define PIPE_END(inode) ((PIPE_START(inode) + PIPE_LEN(inode)) & (PIPE_SIZE-1))
#define PIPE_MAX_RCHUNK(inode) (PIPE_SIZE - PIPE_START(inode))
#define PIPE_MAX_WCHUNK(inode) (PIPE_SIZE - PIPE_END(inode))


void pipe_wait(struct inode * inode);

struct inode* pipe_new(struct inode* inode);
# 299 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/minix_fs_i.h" 1

#define _MINIX_FS_I 




struct minix_inode_info {
        union {
                __u16 i1_data[16];
                __u32 i2_data[16];
        } u;
};
# 300 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext2_fs_i.h" 1
# 17 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext2_fs_i.h"
#define _LINUX_EXT2_FS_I 




struct ext2_inode_info {
        __u32 i_data[15];
        __u32 i_flags;
        __u32 i_faddr;
        __u8 i_frag_no;
        __u8 i_frag_size;
        __u16 i_state;
        __u32 i_file_acl;
        __u32 i_dir_acl;
        __u32 i_dtime;
        __u32 i_block_group;
        __u32 i_next_alloc_block;
        __u32 i_next_alloc_goal;
        __u32 i_prealloc_block;
        __u32 i_prealloc_count;
        __u32 i_dir_start_lookup;
};




#define EXT2_STATE_NEW 0x00000001
# 301 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext3_fs_i.h" 1
# 17 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext3_fs_i.h"
#define _LINUX_EXT3_FS_I 






struct ext3_inode_info {
        __u32 i_data[15];
        __u32 i_flags;






        __u32 i_file_acl;
        __u32 i_dir_acl;
        __u32 i_dtime;
        __u32 i_block_group;
        __u32 i_state;
        __u32 i_next_alloc_block;
        __u32 i_next_alloc_goal;




        __u32 i_dir_start_lookup;

        struct list_head i_orphan;
# 63 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext3_fs_i.h"
        loff_t i_disksize;
# 75 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext3_fs_i.h"
        struct rw_semaphore truncate_sem;
};
# 302 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/hpfs_fs_i.h" 1

#define _HPFS_FS_I 

struct hpfs_inode_info {
        unsigned long mmu_private;
        ino_t i_parent_dir;
        unsigned i_dno;
        unsigned i_dpos;
        unsigned i_dsubdno;
        unsigned i_file_sec;
        unsigned i_disk_sec;
        unsigned i_n_secs;
        unsigned i_ea_size;
        unsigned i_conv : 2;
        unsigned i_ea_mode : 1;
        unsigned i_ea_uid : 1;
        unsigned i_ea_gid : 1;
        unsigned i_dirty : 1;
        struct semaphore i_sem;
        loff_t **i_rddir_off;
};

#define i_hpfs_dno u.hpfs_i.i_dno
#define i_hpfs_parent_dir u.hpfs_i.i_parent_dir
#define i_hpfs_n_secs u.hpfs_i.i_n_secs
#define i_hpfs_file_sec u.hpfs_i.i_file_sec
#define i_hpfs_disk_sec u.hpfs_i.i_disk_sec
#define i_hpfs_dpos u.hpfs_i.i_dpos
#define i_hpfs_dsubdno u.hpfs_i.i_dsubdno
#define i_hpfs_ea_size u.hpfs_i.i_ea_size
#define i_hpfs_conv u.hpfs_i.i_conv
#define i_hpfs_ea_mode u.hpfs_i.i_ea_mode
#define i_hpfs_ea_uid u.hpfs_i.i_ea_uid
#define i_hpfs_ea_gid u.hpfs_i.i_ea_gid


#define i_hpfs_sem u.hpfs_i.i_sem
#define i_hpfs_rddir_off u.hpfs_i.i_rddir_off
#define i_hpfs_dirty u.hpfs_i.i_dirty
# 303 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ntfs_fs_i.h" 1

#define _LINUX_NTFS_FS_I_H 




struct ntfs_attribute;
struct ntfs_sb_info;



#define NTFS_INTEGRAL_TYPES 
typedef u8 ntfs_u8;
typedef u16 ntfs_u16;
typedef u32 ntfs_u32;
typedef u64 ntfs_u64;
typedef s8 ntfs_s8;
typedef s16 ntfs_s16;
typedef s32 ntfs_s32;
typedef s64 ntfs_s64;



#define NTMODE_T 
typedef __kernel_mode_t ntmode_t;


#define NTFS_UID_T 
typedef uid_t ntfs_uid_t;


#define NTFS_GID_T 
typedef gid_t ntfs_gid_t;


#define NTFS_SIZE_T 
typedef __kernel_size_t ntfs_size_t;


#define NTFS_TIME_T 
typedef __kernel_time_t ntfs_time_t;




#define NTFS_WCHAR_T 
typedef u16 ntfs_wchar_t;



#define NTFS_OFFSET_T 
typedef s64 ntfs_offset_t;



#define NTFS_TIME64_T 
typedef u64 ntfs_time64_t;
# 68 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ntfs_fs_i.h"
#define NTFS_CLUSTER_T 
typedef s32 ntfs_cluster_t;



struct ntfs_inode_info {
        struct ntfs_sb_info *vol;
        unsigned long i_number;
        __u16 sequence_number;
        unsigned char *attr;
        int attr_count;
        struct ntfs_attribute *attrs;
        int record_count;
        int *records;

        union {
                struct {
                        int recordsize;
                        int clusters_per_record;
                } index;
        } u;
};
# 304 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/msdos_fs_i.h" 1

#define _MSDOS_FS_I 





struct msdos_inode_info {
        unsigned long mmu_private;
        int i_start;
        int i_logstart;
        int i_attrs;
        int i_ctime_ms;
        loff_t i_pos;
        struct inode *i_fat_inode;
        struct list_head i_fat_hash;
};
# 305 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/umsdos_fs_i.h" 1

#define UMSDOS_FS_I_H 
# 39 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/umsdos_fs_i.h"
struct dir_locking_info {
        wait_queue_head_t p;
        short int looking;
        short int creating;



        long pid;

};

struct umsdos_inode_info {
        struct msdos_inode_info msdos_info;
        struct dir_locking_info dir_info;
        int i_patched;
        int i_is_hlink;
        off_t pos;
};
# 306 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/iso_fs_i.h" 1

#define _ISO_FS_I 

enum isofs_file_format {
        isofs_file_normal = 0,
        isofs_file_sparse = 1,
        isofs_file_compressed = 2,
};




struct iso_inode_info {
        unsigned int i_first_extent;
        unsigned char i_file_format;
        unsigned char i_format_parm[3];
        unsigned long i_next_section_ino;
        off_t i_section_size;
};
# 307 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/nfs_fs_i.h" 1

#define _NFS_FS_I 



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/nfs.h" 1







#define _LINUX_NFS_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sunrpc/msg_prot.h" 1







#define _LINUX_SUNRPC_MSGPROT_H_ 



#define RPC_VERSION 2

enum rpc_auth_flavor {
        RPC_AUTH_NULL = 0,
        RPC_AUTH_UNIX = 1,
        RPC_AUTH_SHORT = 2,
        RPC_AUTH_DES = 3,
        RPC_AUTH_KRB = 4,
};

enum rpc_msg_type {
        RPC_CALL = 0,
        RPC_REPLY = 1
};

enum rpc_reply_stat {
        RPC_MSG_ACCEPTED = 0,
        RPC_MSG_DENIED = 1
};

enum rpc_accept_stat {
        RPC_SUCCESS = 0,
        RPC_PROG_UNAVAIL = 1,
        RPC_PROG_MISMATCH = 2,
        RPC_PROC_UNAVAIL = 3,
        RPC_GARBAGE_ARGS = 4,
        RPC_SYSTEM_ERR = 5
};

enum rpc_reject_stat {
        RPC_MISMATCH = 0,
        RPC_AUTH_ERROR = 1
};

enum rpc_auth_stat {
        RPC_AUTH_OK = 0,
        RPC_AUTH_BADCRED = 1,
        RPC_AUTH_REJECTEDCRED = 2,
        RPC_AUTH_BADVERF = 3,
        RPC_AUTH_REJECTEDVERF = 4,
        RPC_AUTH_TOOWEAK = 5
};

#define RPC_PMAP_PROGRAM 100000
#define RPC_PMAP_VERSION 2
#define RPC_PMAP_PORT 111

#define RPC_MAXNETNAMELEN 256
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/nfs.h" 2

#define NFS_PROGRAM 100003
#define NFS_PORT 2049
#define NFS_MAXDATA 8192
#define NFS_MAXPATHLEN 1024
#define NFS_MAXNAMLEN 255
#define NFS_MAXGROUPS 16
#define NFS_FHSIZE 32
#define NFS_COOKIESIZE 4
#define NFS_FIFO_DEV (-1)
#define NFSMODE_FMT 0170000
#define NFSMODE_DIR 0040000
#define NFSMODE_CHR 0020000
#define NFSMODE_BLK 0060000
#define NFSMODE_REG 0100000
#define NFSMODE_LNK 0120000
#define NFSMODE_SOCK 0140000
#define NFSMODE_FIFO 0010000

#define NFS_MNT_PROGRAM 100005
#define NFS_MNT_PORT 627

#define NFS_MAJOR UNNAMED_MAJOR
#define NFS_MINOR 0xff
# 44 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/nfs.h"
 enum nfs_stat {
        NFS_OK = 0,
        NFSERR_PERM = 1,
        NFSERR_NOENT = 2,
        NFSERR_IO = 5,
        NFSERR_NXIO = 6,
        NFSERR_EAGAIN = 11,
        NFSERR_ACCES = 13,
        NFSERR_EXIST = 17,
        NFSERR_XDEV = 18,
        NFSERR_NODEV = 19,
        NFSERR_NOTDIR = 20,
        NFSERR_ISDIR = 21,
        NFSERR_INVAL = 22,
        NFSERR_FBIG = 27,
        NFSERR_NOSPC = 28,
        NFSERR_ROFS = 30,
        NFSERR_MLINK = 31,
        NFSERR_OPNOTSUPP = 45,
        NFSERR_NAMETOOLONG = 63,
        NFSERR_NOTEMPTY = 66,
        NFSERR_DQUOT = 69,
        NFSERR_STALE = 70,
        NFSERR_REMOTE = 71,
        NFSERR_WFLUSH = 99,
        NFSERR_BADHANDLE = 10001,
        NFSERR_NOT_SYNC = 10002,
        NFSERR_BAD_COOKIE = 10003,
        NFSERR_NOTSUPP = 10004,
        NFSERR_TOOSMALL = 10005,
        NFSERR_SERVERFAULT = 10006,
        NFSERR_BADTYPE = 10007,
        NFSERR_JUKEBOX = 10008
 };



enum nfs_ftype {
        NFNON = 0,
        NFREG = 1,
        NFDIR = 2,
        NFBLK = 3,
        NFCHR = 4,
        NFLNK = 5,
        NFSOCK = 6,
        NFBAD = 7,
        NFFIFO = 8
};





#define NFS_MAXFHSIZE 64
struct nfs_fh {
        unsigned short size;
        unsigned char data[64];
};





#define NFS_OFFSET_MAX ((__s64)((~(__u64)0) >> 1))


enum nfs3_stable_how {
        NFS_UNSTABLE = 0,
        NFS_DATA_SYNC = 1,
        NFS_FILE_SYNC = 2
};
# 7 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/nfs_fs_i.h" 2




struct nfs_inode_info {



        __u64 fileid;




        struct nfs_fh fh;




        unsigned short flags;
# 44 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/nfs_fs_i.h"
        unsigned long read_cache_jiffies;
        __u64 read_cache_ctime;
        __u64 read_cache_mtime;
        __u64 read_cache_isize;
        unsigned long attrtimeo;
        unsigned long attrtimeo_timestamp;





        unsigned long cache_mtime_jiffies;





        __u32 cookieverf[2];




        struct list_head read;
        struct list_head dirty;
        struct list_head commit;
        struct list_head writeback;

        unsigned int nread,
                                ndirty,
                                ncommit,
                                npages;


        struct rpc_cred *mm_cred;
};




#define NFS_INO_STALE 0x0001
#define NFS_INO_ADVISE_RDPLUS 0x0002
#define NFS_INO_REVALIDATING 0x0004
#define NFS_IS_SNAPSHOT 0x0010
#define NFS_INO_FLUSH 0x0020
#define NFS_INO_MAPPED 0x0040




struct nfs_lock_info {
        u32 state;
        u32 flags;
        struct nlm_host *host;
};




#define NFS_LCK_GRANTED 0x0001
#define NFS_LCK_RECLAIM 0x0002
# 308 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sysv_fs_i.h" 1

#define _SYSV_FS_I 




struct sysv_inode_info {
        u32 i_data[10+1+1+1];




        u32 i_dir_start_lookup;
};
# 309 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/affs_fs_i.h" 1

#define _AFFS_FS_I 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/a.out.h" 1

#define __A_OUT_GNU_H__ 

#define __GNU_EXEC_MACROS__ 



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/a.out.h" 1

#define __ASM_MIPS_A_OUT_H 

struct exec
{
  unsigned long a_info;
  unsigned a_text;
  unsigned a_data;
  unsigned a_bss;
  unsigned a_syms;
  unsigned a_entry;
  unsigned a_trsize;
  unsigned a_drsize;
};

#define N_TRSIZE(a) ((a).a_trsize)
#define N_DRSIZE(a) ((a).a_drsize)
#define N_SYMSIZE(a) ((a).a_syms)



#define STACK_TOP TASK_SIZE
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/a.out.h" 2




enum machine_type {



  M_OLDSUN2 = 0,




  M_68010 = 1,




  M_68020 = 2,




  M_SPARC = 3,


  M_386 = 100,
  M_MIPS1 = 151,
  M_MIPS2 = 152
};


#define N_MAGIC(exec) ((exec).a_info & 0xffff)

#define N_MACHTYPE(exec) ((enum machine_type)(((exec).a_info >> 16) & 0xff))
#define N_FLAGS(exec) (((exec).a_info >> 24) & 0xff)
#define N_SET_INFO(exec,magic,type,flags) ((exec).a_info = ((magic) & 0xffff) | (((int)(type) & 0xff) << 16) | (((flags) & 0xff) << 24))



#define N_SET_MAGIC(exec,magic) ((exec).a_info = (((exec).a_info & 0xffff0000) | ((magic) & 0xffff)))


#define N_SET_MACHTYPE(exec,machtype) ((exec).a_info = ((exec).a_info&0xff00ffff) | ((((int)(machtype))&0xff) << 16))



#define N_SET_FLAGS(exec,flags) ((exec).a_info = ((exec).a_info&0x00ffffff) | (((flags) & 0xff) << 24))




#define OMAGIC 0407

#define NMAGIC 0410

#define ZMAGIC 0413


#define QMAGIC 0314


#define CMAGIC 0421


#define N_BADMAG(x) (N_MAGIC(x) != OMAGIC && N_MAGIC(x) != NMAGIC && N_MAGIC(x) != ZMAGIC && N_MAGIC(x) != QMAGIC)





#define _N_HDROFF(x) (1024 - sizeof (struct exec))


#define N_TXTOFF(x) (N_MAGIC(x) == ZMAGIC ? _N_HDROFF((x)) + sizeof (struct exec) : (N_MAGIC(x) == QMAGIC ? 0 : sizeof (struct exec)))





#define N_DATOFF(x) (N_TXTOFF(x) + (x).a_text)



#define N_TRELOFF(x) (N_DATOFF(x) + (x).a_data)



#define N_DRELOFF(x) (N_TRELOFF(x) + N_TRSIZE(x))



#define N_SYMOFF(x) (N_DRELOFF(x) + N_DRSIZE(x))



#define N_STROFF(x) (N_SYMOFF(x) + N_SYMSIZE(x))




#define N_TXTADDR(x) (N_MAGIC(x) == QMAGIC ? PAGE_SIZE : 0)
# 136 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/a.out.h"
#define SEGMENT_SIZE PAGE_SIZE




#define _N_SEGMENT_ROUND(x) (((x) + SEGMENT_SIZE - 1) & ~(SEGMENT_SIZE - 1))

#define _N_TXTENDADDR(x) (N_TXTADDR(x)+(x).a_text)


#define N_DATADDR(x) (N_MAGIC(x)==OMAGIC? (_N_TXTENDADDR(x)) : (_N_SEGMENT_ROUND (_N_TXTENDADDR(x))))






#define N_BSSADDR(x) (N_DATADDR(x) + (x).a_data)



struct nlist {
  union {
    char *n_name;
    struct nlist *n_next;
    long n_strx;
  } n_un;
  unsigned char n_type;
  char n_other;
  short n_desc;
  unsigned long n_value;
};



#define N_UNDF 0


#define N_ABS 2


#define N_TEXT 4


#define N_DATA 6


#define N_BSS 8


#define N_FN 15



#define N_EXT 1


#define N_TYPE 036


#define N_STAB 0340
# 207 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/a.out.h"
#define N_INDR 0xa
# 221 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/a.out.h"
#define N_SETA 0x14
#define N_SETT 0x16
#define N_SETD 0x18
#define N_SETB 0x1A


#define N_SETV 0x1C







struct relocation_info
{

  int r_address;

  unsigned int r_symbolnum:24;



  unsigned int r_pcrel:1;


  unsigned int r_length:2;






  unsigned int r_extern:1;







  unsigned int r_pad:4;

};
# 5 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/affs_fs_i.h" 2


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/time.h" 1

#define _LINUX_TIME_H 





#define _STRUCT_TIMESPEC 
struct timespec {
        time_t tv_sec;
        long tv_nsec;
};
# 29 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/time.h"
#define MAX_JIFFY_OFFSET ((~0UL >> 1)-1)

static __inline__ __attribute__((always_inline)) unsigned long
timespec_to_jiffies(struct timespec *value)
{
        unsigned long sec = value->tv_sec;
        long nsec = value->tv_nsec;

        if (sec >= (((~0UL >> 1)-1) / 100))
                return ((~0UL >> 1)-1);
        nsec += 1000000000L / 100 - 1;
        nsec /= 1000000000L / 100;
        return 100 * sec + nsec;
}

static __inline__ __attribute__((always_inline)) void
jiffies_to_timespec(unsigned long jiffies, struct timespec *value)
{
        value->tv_nsec = (jiffies % 100) * (1000000000L / 100);
        value->tv_sec = jiffies / 100;
}
# 67 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/time.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long
mktime (unsigned int year, unsigned int mon,
        unsigned int day, unsigned int hour,
        unsigned int min, unsigned int sec)
{
        if (0 >= (int) (mon -= 2)) {
                mon += 12;
                year -= 1;
        }

        return (((
                (unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +
                        year*365 - 719499
            )*24 + hour
          )*60 + min
        )*60 + sec;
}




struct timeval {
        time_t tv_sec;
        suseconds_t tv_usec;
};

struct timezone {
        int tz_minuteswest;
        int tz_dsttime;
};

#define NFDBITS __NFDBITS


extern void do_gettimeofday(struct timeval *tv);
extern void do_settimeofday(struct timeval *tv);


#define FD_SETSIZE __FD_SETSIZE
#define FD_SET(fd,fdsetp) __FD_SET(fd,fdsetp)
#define FD_CLR(fd,fdsetp) __FD_CLR(fd,fdsetp)
#define FD_ISSET(fd,fdsetp) __FD_ISSET(fd,fdsetp)
#define FD_ZERO(fdsetp) __FD_ZERO(fdsetp)





#define ITIMER_REAL 0
#define ITIMER_VIRTUAL 1
#define ITIMER_PROF 2

struct itimerspec {
        struct timespec it_interval;
        struct timespec it_value;
};

struct itimerval {
        struct timeval it_interval;
        struct timeval it_value;
};
# 8 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/affs_fs_i.h" 2

#define AFFS_CACHE_SIZE PAGE_SIZE


#define AFFS_MAX_PREALLOC 32
#define AFFS_LC_SIZE (AFFS_CACHE_SIZE/sizeof(u32)/2)
#define AFFS_AC_SIZE (AFFS_CACHE_SIZE/sizeof(struct affs_ext_key)/2)
#define AFFS_AC_MASK (AFFS_AC_SIZE-1)

struct affs_ext_key {
        u32 ext;
        u32 key;
};




struct affs_inode_info {
        u32 i_opencnt;
        struct semaphore i_link_lock;
        struct semaphore i_ext_lock;
#define i_hash_lock i_ext_lock
        u32 i_blkcnt;
        u32 i_extcnt;
        u32 *i_lc;
        u32 i_lc_size;
        u32 i_lc_shift;
        u32 i_lc_mask;
        struct affs_ext_key *i_ac;
        u32 i_ext_last;
        struct buffer_head *i_ext_bh;
        unsigned long mmu_private;
        u32 i_protect;
        u32 i_lastalloc;
        int i_pa_cnt;
# 51 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/affs_fs_i.h"
};


#define AFFS_INODE (&inode->u.affs_i)
#define AFFS_DIR (&dir->u.affs_i)
# 310 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ufs_fs_i.h" 1
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ufs_fs_i.h"
#define _LINUX_UFS_FS_I_H 

struct ufs_inode_info {
        union {
                __u32 i_data[15];
                __u8 i_symlink[4*15];
        } i_u1;
        __u32 i_flags;
        __u32 i_gen;
        __u32 i_shadow;
        __u32 i_unused1;
        __u32 i_unused2;
        __u32 i_oeftflag;
        __u16 i_osync;
        __u32 i_lastfrag;
};
# 311 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/efs_fs_i.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/efs_fs_i.h"
#define __EFS_FS_I_H__ 

typedef int32_t efs_block_t;
typedef uint32_t efs_ino_t;

#define EFS_DIRECTEXTENTS 12




typedef union extent_u {
        unsigned char raw[8];
        struct extent_s {
                unsigned int ex_magic:8;
                unsigned int ex_bn:24;
                unsigned int ex_length:8;
                unsigned int ex_offset:24;
        } cooked;
} efs_extent;

typedef struct edevs {
        short odev;
        unsigned int ndev;
} efs_devs;





struct efs_dinode {
        u_short di_mode;
        short di_nlink;
        u_short di_uid;
        u_short di_gid;
        int32_t di_size;
        int32_t di_atime;
        int32_t di_mtime;
        int32_t di_ctime;
        uint32_t di_gen;
        short di_numextents;
        u_char di_version;
        u_char di_spare;
        union di_addr {
                efs_extent di_extents[12];
                efs_devs di_dev;
        } di_u;
};


struct efs_inode_info {
        int numextents;
        int lastextent;

        efs_extent extents[12];
};
# 312 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/coda_fs_i.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/coda_fs_i.h"
#define _LINUX_CODA_FS_I 




# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/coda.h" 1
# 60 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/coda.h"
#define _CODA_HEADER_ 
# 71 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/coda.h"
#define CODA_MAXSYMLINKS 10
# 102 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/coda.h"
#define cdev_t u_quad_t






typedef unsigned long long u_quad_t;
# 136 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/coda.h"
#define CODA_MAXNAMLEN 255
#define CODA_MAXPATHLEN 1024
#define CODA_MAXSYMLINK 10




#define C_O_READ 0x001
#define C_O_WRITE 0x002
#define C_O_TRUNC 0x010
#define C_O_EXCL 0x100
#define C_O_CREAT 0x200


#define C_M_READ 00400
#define C_M_WRITE 00200


#define C_A_C_OK 8
#define C_A_R_OK 4
#define C_A_W_OK 2
#define C_A_X_OK 1
#define C_A_F_OK 0




#define _VENUS_DIRENT_T_ 1
struct venus_dirent {
        unsigned long d_fileno;
        unsigned short d_reclen;
        unsigned char d_type;
        unsigned char d_namlen;
        char d_name[255 + 1];
};

#define DIRSIZ(dp) ((sizeof (struct venus_dirent) - (CODA_MAXNAMLEN+1)) + (((dp)->d_namlen+1 + 3) &~ 3))





#define CDT_UNKNOWN 0
#define CDT_FIFO 1
#define CDT_CHR 2
#define CDT_DIR 4
#define CDT_BLK 6
#define CDT_REG 8
#define CDT_LNK 10
#define CDT_SOCK 12
#define CDT_WHT 14




#define IFTOCDT(mode) (((mode) & 0170000) >> 12)
#define CDTTOIF(dirtype) ((dirtype) << 12)




#define _FID_T_ 1
typedef u_long VolumeId;
typedef u_long VnodeId;
typedef u_long Unique_t;
typedef u_long FileVersion;



#define _VICEFID_T_ 1
typedef struct ViceFid {
    VolumeId Volume;
    VnodeId Vnode;
    Unique_t Unique;
} ViceFid;




static __inline__ __attribute__((always_inline)) ino_t coda_f2i(struct ViceFid *fid)
{
        if ( ! fid )
                return 0;
        if (fid->Vnode == 0xfffffffe || fid->Vnode == 0xffffffff)
                return ((fid->Volume << 20) | (fid->Unique & 0xfffff));
        else
                return (fid->Unique + (fid->Vnode<<10) + (fid->Volume<<20));
}
# 232 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/coda.h"
#define _VUID_T_ 
typedef u_int32_t vuid_t;
typedef u_int32_t vgid_t;



#define _CODACRED_T_ 
struct coda_cred {
    vuid_t cr_uid, cr_euid, cr_suid, cr_fsuid;
    vgid_t cr_groupid, cr_egid, cr_sgid, cr_fsgid;
};



#define _VENUS_VATTR_T_ 



enum coda_vtype { C_VNON, C_VREG, C_VDIR, C_VBLK, C_VCHR, C_VLNK, C_VSOCK, C_VFIFO, C_VBAD };

struct coda_vattr {
        long va_type;
        u_short va_mode;
        short va_nlink;
        vuid_t va_uid;
        vgid_t va_gid;
        long va_fileid;
        u_quad_t va_size;
        long va_blocksize;
        struct timespec va_atime;
        struct timespec va_mtime;
        struct timespec va_ctime;
        u_long va_gen;
        u_long va_flags;
        u_quad_t va_rdev;
        u_quad_t va_bytes;
        u_quad_t va_filerev;
};




struct coda_statfs {
    int32_t f_blocks;
    int32_t f_bfree;
    int32_t f_bavail;
    int32_t f_files;
    int32_t f_ffree;
};





#define CODA_ROOT 2
#define CODA_OPEN_BY_FD 3
#define CODA_OPEN 4
#define CODA_CLOSE 5
#define CODA_IOCTL 6
#define CODA_GETATTR 7
#define CODA_SETATTR 8
#define CODA_ACCESS 9
#define CODA_LOOKUP 10
#define CODA_CREATE 11
#define CODA_REMOVE 12
#define CODA_LINK 13
#define CODA_RENAME 14
#define CODA_MKDIR 15
#define CODA_RMDIR 16
#define CODA_SYMLINK 18
#define CODA_READLINK 19
#define CODA_FSYNC 20
#define CODA_VGET 22
#define CODA_SIGNAL 23
#define CODA_REPLACE 24
#define CODA_FLUSH 25
#define CODA_PURGEUSER 26
#define CODA_ZAPFILE 27
#define CODA_ZAPDIR 28
#define CODA_PURGEFID 30
#define CODA_OPEN_BY_PATH 31
#define CODA_RESOLVE 32
#define CODA_REINTEGRATE 33
#define CODA_STATFS 34
#define CODA_STORE 35
#define CODA_RELEASE 36
#define CODA_NCALLS 37

#define DOWNCALL(opcode) (opcode >= CODA_REPLACE && opcode <= CODA_PURGEFID)

#define VC_MAXDATASIZE 8192
#define VC_MAXMSGSIZE sizeof(union inputArgs)+sizeof(union outputArgs) + VC_MAXDATASIZE


#define CIOC_KERNEL_VERSION _IOWR('c', 10, sizeof (int))





#define CODA_KERNEL_VERSION 2




struct coda_in_hdr {
    unsigned long opcode;
    unsigned long unique;
    u_short pid;
    u_short pgid;
    u_short sid;
    struct coda_cred cred;
};


struct coda_out_hdr {
    unsigned long opcode;
    unsigned long unique;
    unsigned long result;
};


struct coda_root_out {
    struct coda_out_hdr oh;
    ViceFid VFid;
};

struct coda_root_in {
    struct coda_in_hdr in;
};


struct coda_open_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int flags;
};

struct coda_open_out {
    struct coda_out_hdr oh;
    u_quad_t dev;
    ino_t inode;
};



struct coda_store_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int flags;
};

struct coda_store_out {
    struct coda_out_hdr out;
};


struct coda_release_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int flags;
};

struct coda_release_out {
    struct coda_out_hdr out;
};


struct coda_close_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int flags;
};

struct coda_close_out {
    struct coda_out_hdr out;
};


struct coda_ioctl_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int cmd;
    int len;
    int rwflag;
    char *data;
};

struct coda_ioctl_out {
    struct coda_out_hdr oh;
    int len;
    caddr_t data;
};



struct coda_getattr_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
};

struct coda_getattr_out {
    struct coda_out_hdr oh;
    struct coda_vattr attr;
};



struct coda_setattr_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    struct coda_vattr attr;
};

struct coda_setattr_out {
    struct coda_out_hdr out;
};


struct coda_access_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int flags;
};

struct coda_access_out {
    struct coda_out_hdr out;
};



#define CLU_CASE_SENSITIVE 0x01
#define CLU_CASE_INSENSITIVE 0x02


struct coda_lookup_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int name;
    int flags;
};

struct coda_lookup_out {
    struct coda_out_hdr oh;
    ViceFid VFid;
    int vtype;
};



struct coda_create_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    struct coda_vattr attr;
    int excl;
    int mode;
    int name;
};

struct coda_create_out {
    struct coda_out_hdr oh;
    ViceFid VFid;
    struct coda_vattr attr;
};



struct coda_remove_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int name;
};

struct coda_remove_out {
    struct coda_out_hdr out;
};


struct coda_link_in {
    struct coda_in_hdr ih;
    ViceFid sourceFid;
    ViceFid destFid;
    int tname;
};

struct coda_link_out {
    struct coda_out_hdr out;
};



struct coda_rename_in {
    struct coda_in_hdr ih;
    ViceFid sourceFid;
    int srcname;
    ViceFid destFid;
    int destname;
};

struct coda_rename_out {
    struct coda_out_hdr out;
};


struct coda_mkdir_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    struct coda_vattr attr;
    int name;
};

struct coda_mkdir_out {
    struct coda_out_hdr oh;
    ViceFid VFid;
    struct coda_vattr attr;
};



struct coda_rmdir_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int name;
};

struct coda_rmdir_out {
    struct coda_out_hdr out;
};


struct coda_symlink_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int srcname;
    struct coda_vattr attr;
    int tname;
};

struct coda_symlink_out {
    struct coda_out_hdr out;
};


struct coda_readlink_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
};

struct coda_readlink_out {
    struct coda_out_hdr oh;
    int count;
    caddr_t data;
};



struct coda_fsync_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
};

struct coda_fsync_out {
    struct coda_out_hdr out;
};


struct coda_vget_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
};

struct coda_vget_out {
    struct coda_out_hdr oh;
    ViceFid VFid;
    int vtype;
};
# 616 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/coda.h"
struct coda_purgeuser_out {
    struct coda_out_hdr oh;
    struct coda_cred cred;
};



struct coda_zapfile_out {
    struct coda_out_hdr oh;
    ViceFid CodaFid;
};



struct coda_zapdir_out {
    struct coda_out_hdr oh;
    ViceFid CodaFid;
};



struct coda_zapvnode_out {
    struct coda_out_hdr oh;
    struct coda_cred cred;
    ViceFid VFid;
};



struct coda_purgefid_out {
    struct coda_out_hdr oh;
    ViceFid CodaFid;
};



struct coda_replace_out {
    struct coda_out_hdr oh;
    ViceFid NewFid;
    ViceFid OldFid;
};


struct coda_open_by_fd_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int flags;
};

struct coda_open_by_fd_out {
    struct coda_out_hdr oh;
    int fd;


    struct file *fh;

};


struct coda_open_by_path_in {
    struct coda_in_hdr ih;
    ViceFid VFid;
    int flags;
};

struct coda_open_by_path_out {
    struct coda_out_hdr oh;
        int path;
};


struct coda_statfs_in {
    struct coda_in_hdr in;
};

struct coda_statfs_out {
    struct coda_out_hdr oh;
    struct coda_statfs stat;
};






#define CODA_NOCACHE 0x80000000

union inputArgs {
    struct coda_in_hdr ih;
    struct coda_open_in coda_open;
    struct coda_store_in coda_store;
    struct coda_release_in coda_release;
    struct coda_close_in coda_close;
    struct coda_ioctl_in coda_ioctl;
    struct coda_getattr_in coda_getattr;
    struct coda_setattr_in coda_setattr;
    struct coda_access_in coda_access;
    struct coda_lookup_in coda_lookup;
    struct coda_create_in coda_create;
    struct coda_remove_in coda_remove;
    struct coda_link_in coda_link;
    struct coda_rename_in coda_rename;
    struct coda_mkdir_in coda_mkdir;
    struct coda_rmdir_in coda_rmdir;
    struct coda_symlink_in coda_symlink;
    struct coda_readlink_in coda_readlink;
    struct coda_fsync_in coda_fsync;
    struct coda_vget_in coda_vget;
    struct coda_open_by_fd_in coda_open_by_fd;
    struct coda_open_by_path_in coda_open_by_path;
    struct coda_statfs_in coda_statfs;
};

union outputArgs {
    struct coda_out_hdr oh;
    struct coda_root_out coda_root;
    struct coda_open_out coda_open;
    struct coda_ioctl_out coda_ioctl;
    struct coda_getattr_out coda_getattr;
    struct coda_lookup_out coda_lookup;
    struct coda_create_out coda_create;
    struct coda_mkdir_out coda_mkdir;
    struct coda_readlink_out coda_readlink;
    struct coda_vget_out coda_vget;
    struct coda_purgeuser_out coda_purgeuser;
    struct coda_zapfile_out coda_zapfile;
    struct coda_zapdir_out coda_zapdir;
    struct coda_zapvnode_out coda_zapvnode;
    struct coda_purgefid_out coda_purgefid;
    struct coda_replace_out coda_replace;
    struct coda_open_by_fd_out coda_open_by_fd;
    struct coda_open_by_path_out coda_open_by_path;
    struct coda_statfs_out coda_statfs;
};

union coda_downcalls {


    struct coda_purgeuser_out purgeuser;
    struct coda_zapfile_out zapfile;
    struct coda_zapdir_out zapdir;
    struct coda_zapvnode_out zapvnode;
    struct coda_purgefid_out purgefid;
    struct coda_replace_out replace;
};






#define PIOCPARM_MASK 0x0000ffff
struct ViceIoctl {
        caddr_t in, out;
        u_short in_size;
        u_short out_size;
};

struct PioctlData {
        const char *path;
        int follow;
        struct ViceIoctl vi;
};

#define CODA_CONTROL ".CONTROL"
#define CODA_CONTROLLEN 8
#define CTL_VOL -1
#define CTL_VNO -1
#define CTL_UNI -1
#define CTL_INO -1
#define CTL_FILE "/coda/.CONTROL"


#define IS_CTL_FID(fidp) ((fidp)->Volume == CTL_VOL && (fidp)->Vnode == CTL_VNO && (fidp)->Unique == CTL_UNI)





#define CODA_MOUNT_VERSION 1

struct coda_mount_data {
        int version;
        int fd;
};
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/coda_fs_i.h" 2




struct coda_inode_info {
        struct ViceFid c_fid;
        u_short c_flags;
        struct list_head c_cilist;
        int c_mapcount;
        struct coda_cred c_cached_cred;
        unsigned int c_cached_perm;
};




#define CODA_MAGIC 0xC0DAC0DA
struct coda_file_info {
        int cfi_magic;
        int cfi_mapcount;
        struct file *cfi_container;
        struct coda_cred cfi_cred;
};

#define CODA_FTOC(file) ((struct coda_file_info *)((file)->private_data))


#define C_VATTR 0x1
#define C_FLUSH 0x2
#define C_DYING 0x4
#define C_PURGE 0x8

int coda_cnode_make(struct inode **, struct ViceFid *, struct super_block *);
struct inode *coda_iget(struct super_block *sb, struct ViceFid *fid, struct coda_vattr *attr);
int coda_cnode_makectl(struct inode **inode, struct super_block *sb);
struct inode *coda_fid_to_inode(ViceFid *fid, struct super_block *sb);
void coda_replace_fid(struct inode *, ViceFid *, ViceFid *);
# 313 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/romfs_fs_i.h" 1

#define __ROMFS_FS_I 



struct romfs_inode_info {
        unsigned long i_metasize;
        unsigned long i_dataoffset;
};
# 314 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/shmem_fs.h" 1

#define __SHMEM_FS_H 



#define SHMEM_NR_DIRECT 16
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/shmem_fs.h"
typedef struct {
        unsigned long val;
} swp_entry_t;

struct shmem_inode_info {
        spinlock_t lock;
        unsigned long next_index;
        swp_entry_t i_direct[16];
        void **i_indirect;
        unsigned long swapped;
        unsigned long flags;
        struct list_head list;
        struct inode *inode;
};

struct shmem_sb_info {
        unsigned long max_blocks;
        unsigned long free_blocks;
        unsigned long max_inodes;
        unsigned long free_inodes;
        spinlock_t stat_lock;
};

#define SHMEM_I(inode) (&inode->u.shmem_i)
# 315 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/smb_fs_i.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/smb_fs_i.h"
#define _LINUX_SMB_FS_I 







struct smb_inode_info {





        unsigned int open;
        __u16 fileid;
        __u16 attr;

        __u16 access;
        __u16 flags;
        unsigned long oldmtime;
        unsigned long closed;
        unsigned openers;
};
# 316 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/hfs_fs_i.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/hfs_fs_i.h"
#define _LINUX_HFS_FS_I_H 






struct hfs_inode_info {
        int magic;

        unsigned long mmu_private;
        struct hfs_cat_entry *entry;


        struct hfs_fork *fork;
        int convert;


        ino_t file_type;
        char dir_size;


        const struct hfs_hdr_layout *default_layout;
        struct hfs_hdr_layout *layout;


        int tz_secondswest;


        void (*d_drop_op)(struct dentry *, const ino_t);
};
# 317 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/adfs_fs_i.h" 1







#define _ADFS_FS_I 




struct adfs_inode_info {
        unsigned long mmu_private;
        unsigned long parent_id;
        __u32 loadaddr;
        __u32 execaddr;
        unsigned int filetype;
        unsigned int attr;
        int stamped:1;
};
# 318 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/qnx4_fs_i.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/qnx4_fs_i.h"
#define _QNX4_FS_I 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/qnxtypes.h" 1
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/qnxtypes.h"
#define _QNX4TYPES_H 

typedef __u16 qnx4_nxtnt_t;
typedef __u8 qnx4_ftype_t;

typedef struct {
        __u32 xtnt_blk;
        __u32 xtnt_size;
} qnx4_xtnt_t;

typedef __u16 qnx4_mode_t;
typedef __u16 qnx4_muid_t;
typedef __u16 qnx4_mgid_t;
typedef __u32 qnx4_off_t;
typedef __u16 qnx4_nlink_t;
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/qnx4_fs_i.h" 2




struct qnx4_inode_info {
        char i_reserved[16];
        qnx4_off_t i_size;
        qnx4_xtnt_t i_first_xtnt;
        __u32 i_xblk;
        __s32 i_ftime;
        __s32 i_mtime;
        __s32 i_atime;
        __s32 i_ctime;
        qnx4_nxtnt_t i_num_xtnts;
        qnx4_mode_t i_mode;
        qnx4_muid_t i_uid;
        qnx4_mgid_t i_gid;
        qnx4_nlink_t i_nlink;
        __u8 i_zero[4];
        qnx4_ftype_t i_type;
        __u8 i_status;
        unsigned long mmu_private;
};
# 319 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/reiserfs_fs_i.h" 1




#define _REISER_FS_I 




typedef enum {



    i_item_key_version_mask = 0x0001,


    i_stat_data_version_mask = 0x0002,

    i_pack_on_close_mask = 0x0004,

    i_nopack_mask = 0x0008,



    i_link_saved_unlink_mask = 0x0010,
    i_link_saved_truncate_mask = 0x0020
} reiserfs_inode_flags;


struct reiserfs_inode_info {
    __u32 i_key [4];



    __u32 i_flags;

    __u32 i_first_direct_byte;


    __u32 i_attrs;

    int i_prealloc_block;
    int i_prealloc_count;
    struct list_head i_prealloc_list;


    int new_packing_locality:1;






    unsigned long i_trans_id ;
    unsigned long i_trans_index ;





    unsigned long i_tail_trans_id;
    unsigned long i_tail_trans_index;
};
# 320 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/bfs_fs_i.h" 1






#define _LINUX_BFS_FS_I 




struct bfs_inode_info {
        unsigned long i_dsk_ino;
        unsigned long i_sblock;
        unsigned long i_eblock;
};
# 321 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/udf_fs_i.h" 1
# 19 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/udf_fs_i.h"
#define _UDF_FS_I_H 1




typedef struct
{
        __u32 logicalBlockNum;
        __u16 partitionReferenceNum;
} __attribute__ ((packed)) lb_addr;


struct udf_inode_info
{
        long i_umtime;
        long i_uctime;
        long i_crtime;
        long i_ucrtime;

        lb_addr i_location;
        __u64 i_unique;
        __u32 i_lenEAttr;
        __u32 i_lenAlloc;
        __u64 i_lenExtents;
        __u32 i_next_alloc_block;
        __u32 i_next_alloc_goal;
        unsigned i_alloc_type : 3;
        unsigned i_extended_fe : 1;
        unsigned i_strat_4096 : 1;
        unsigned i_new_inode : 1;
        unsigned reserved : 26;
};





#define UDF_GETEASIZE _IOR('l', 0x40, int)
#define UDF_GETEABLOCK _IOR('l', 0x41, void *)
#define UDF_GETVOLIDENT _IOR('l', 0x42, void *)
#define UDF_RELOCATE_BLOCKS _IOWR('l', 0x43, long)
# 322 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ncp_fs_i.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ncp_fs_i.h"
#define _LINUX_NCP_FS_I 







struct ncp_inode_info {
        __u32 dirEntNum;
        __u32 DosDirNum;
        __u32 volNumber;
        __u32 nwattr;
        struct semaphore open_sem;
        atomic_t opened;
        int access;
        __u32 server_file_handle;
        __u8 open_create_action;
        __u8 file_handle[6];
};
# 323 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/proc_fs_i.h" 1
struct proc_inode_info {
        struct task_struct *task;
        int type;
        union {
                int (*proc_get_link)(struct inode *, struct dentry **, struct vfsmount **);
                int (*proc_read)(struct task_struct *task, char *page);
        } op;
        struct file *file;
};
# 324 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/usbdev_fs_i.h" 1
struct usb_device;
struct usb_bus;

struct usbdev_inode_info {
        struct list_head dlist;
        struct list_head slist;
        union {
                struct usb_device *dev;
                struct usb_bus *bus;
        } p;
};
# 325 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/jffs2_fs_i.h" 1



#define _JFFS2_FS_I 
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/jffs2_fs_i.h"
struct jffs2_inode_info {
# 26 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/jffs2_fs_i.h"
        struct semaphore sem;


        __u32 highest_version;


        struct jffs2_node_frag *fraglist;






        struct jffs2_full_dnode *metadata;


        struct jffs2_full_dirent *dents;


        struct jffs2_inode_cache *inocache;





        __u16 flags;
        __u8 usercompr;
};




#define JFFS2_INODE_INFO(i) (&i->u.jffs2_i)
# 326 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/cramfs_fs_sb.h" 1

#define _CRAMFS_FS_SB 




struct cramfs_sb_info {
                        unsigned long magic;
                        unsigned long size;
                        unsigned long blocks;
                        unsigned long files;
                        unsigned long flags;
};
# 327 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2





#define ATTR_MODE 1
#define ATTR_UID 2
#define ATTR_GID 4
#define ATTR_SIZE 8
#define ATTR_ATIME 16
#define ATTR_MTIME 32
#define ATTR_CTIME 64
#define ATTR_ATIME_SET 128
#define ATTR_MTIME_SET 256
#define ATTR_FORCE 512
#define ATTR_ATTR_FLAG 1024
# 353 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
struct iattr {
        unsigned int ia_valid;
        umode_t ia_mode;
        uid_t ia_uid;
        gid_t ia_gid;
        loff_t ia_size;
        time_t ia_atime;
        time_t ia_mtime;
        time_t ia_ctime;
        unsigned int ia_attr_flags;
};




#define ATTR_FLAG_SYNCRONOUS 1
#define ATTR_FLAG_NOATIME 2
#define ATTR_FLAG_APPEND 4
#define ATTR_FLAG_IMMUTABLE 8
#define ATTR_FLAG_NODIRATIME 16




# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/quota.h" 1
# 40 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/quota.h"
#define _LINUX_QUOTA_ 




#define __DQUOT_VERSION__ "dquot_6.5.1"
#define __DQUOT_NUM_VERSION__ 6*10000+5*100+1

typedef __kernel_uid32_t qid_t;
typedef __u64 qsize_t;


#define QUOTABLOCK_BITS 10
#define QUOTABLOCK_SIZE (1 << QUOTABLOCK_BITS)


#define qb2kb(x) ((x) << (QUOTABLOCK_BITS-10))
#define kb2qb(x) ((x) >> (QUOTABLOCK_BITS-10))
#define toqb(x) (((x) + QUOTABLOCK_SIZE - 1) >> QUOTABLOCK_BITS)

#define MAXQUOTAS 2
#define USRQUOTA 0
#define GRPQUOTA 1




#define INITQFNAMES { "user", "group", "undefined", };
# 79 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/quota.h"
#define SUBCMDMASK 0x00ff
#define SUBCMDSHIFT 8
#define QCMD(cmd,type) (((cmd) << SUBCMDSHIFT) | ((type) & SUBCMDMASK))

#define Q_SYNC 0x800001
#define Q_QUOTAON 0x800002
#define Q_QUOTAOFF 0x800003
#define Q_GETFMT 0x800004
#define Q_GETINFO 0x800005
#define Q_SETINFO 0x800006
#define Q_GETQUOTA 0x800007
#define Q_SETQUOTA 0x800008





#define QIF_BLIMITS 1
#define QIF_SPACE 2
#define QIF_ILIMITS 4
#define QIF_INODES 8
#define QIF_BTIME 16
#define QIF_ITIME 32
#define QIF_LIMITS (QIF_BLIMITS | QIF_ILIMITS)
#define QIF_USAGE (QIF_SPACE | QIF_INODES)
#define QIF_TIMES (QIF_BTIME | QIF_ITIME)
#define QIF_ALL (QIF_LIMITS | QIF_USAGE | QIF_TIMES)

struct if_dqblk {
        __u64 dqb_bhardlimit;
        __u64 dqb_bsoftlimit;
        __u64 dqb_curspace;
        __u64 dqb_ihardlimit;
        __u64 dqb_isoftlimit;
        __u64 dqb_curinodes;
        __u64 dqb_btime;
        __u64 dqb_itime;
        __u32 dqb_valid;
};





#define IIF_BGRACE 1
#define IIF_IGRACE 2
#define IIF_FLAGS 4
#define IIF_ALL (IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)

struct if_dqinfo {
        __u64 dqi_bgrace;
        __u64 dqi_igrace;
        __u32 dqi_flags;
        __u32 dqi_valid;
};



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dqblk_xfs.h" 1
# 22 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dqblk_xfs.h"
#define _LINUX_DQBLK_XFS_H 







#define XQM_CMD(x) (('X'<<8)+(x))
#define Q_XQUOTAON XQM_CMD(1)
#define Q_XQUOTAOFF XQM_CMD(2)
#define Q_XGETQUOTA XQM_CMD(3)
#define Q_XSETQLIM XQM_CMD(4)
#define Q_XGETQSTAT XQM_CMD(5)
#define Q_XQUOTARM XQM_CMD(6)
# 45 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dqblk_xfs.h"
#define FS_DQUOT_VERSION 1
typedef struct fs_disk_quota {
        __s8 d_version;
        __s8 d_flags;
        __u16 d_fieldmask;
        __u32 d_id;
        __u64 d_blk_hardlimit;
        __u64 d_blk_softlimit;
        __u64 d_ino_hardlimit;
        __u64 d_ino_softlimit;
        __u64 d_bcount;
        __u64 d_icount;
        __s32 d_itimer;

        __s32 d_btimer;
        __u16 d_iwarns;
        __u16 d_bwarns;
        __s32 d_padding2;
        __u64 d_rtb_hardlimit;
        __u64 d_rtb_softlimit;
        __u64 d_rtbcount;
        __s32 d_rtbtimer;
        __u16 d_rtbwarns;
        __s16 d_padding3;
        char d_padding4[8];
} fs_disk_quota_t;




#define FS_DQ_ISOFT (1<<0)
#define FS_DQ_IHARD (1<<1)
#define FS_DQ_BSOFT (1<<2)
#define FS_DQ_BHARD (1<<3)
#define FS_DQ_RTBSOFT (1<<4)
#define FS_DQ_RTBHARD (1<<5)
#define FS_DQ_LIMIT_MASK (FS_DQ_ISOFT | FS_DQ_IHARD | FS_DQ_BSOFT | FS_DQ_BHARD | FS_DQ_RTBSOFT | FS_DQ_RTBHARD)
# 90 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dqblk_xfs.h"
#define FS_DQ_BTIMER (1<<6)
#define FS_DQ_ITIMER (1<<7)
#define FS_DQ_RTBTIMER (1<<8)
#define FS_DQ_TIMER_MASK (FS_DQ_BTIMER | FS_DQ_ITIMER | FS_DQ_RTBTIMER)
# 103 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dqblk_xfs.h"
#define FS_DQ_BWARNS (1<<9)
#define FS_DQ_IWARNS (1<<10)
#define FS_DQ_RTBWARNS (1<<11)
#define FS_DQ_WARNS_MASK (FS_DQ_BWARNS | FS_DQ_IWARNS | FS_DQ_RTBWARNS)




#define XFS_QUOTA_UDQ_ACCT (1<<0)
#define XFS_QUOTA_UDQ_ENFD (1<<1)
#define XFS_QUOTA_GDQ_ACCT (1<<2)
#define XFS_QUOTA_GDQ_ENFD (1<<3)
#define XFS_QUOTA_PDQ_ACCT (1<<4)
#define XFS_QUOTA_PDQ_ENFD (1<<5)

#define XFS_USER_QUOTA (1<<0)
#define XFS_PROJ_QUOTA (1<<1)
#define XFS_GROUP_QUOTA (1<<2)







#define FS_QSTAT_VERSION 1




typedef struct fs_qfilestat {
        __u64 qfs_ino;
        __u64 qfs_nblks;
        __u32 qfs_nextents;
} fs_qfilestat_t;

typedef struct fs_quota_stat {
        __s8 qs_version;
        __u16 qs_flags;
        __s8 qs_pad;
        fs_qfilestat_t qs_uquota;
        fs_qfilestat_t qs_gquota;
        __u32 qs_incoredqs;
        __s32 qs_btimelimit;
        __s32 qs_itimelimit;
        __s32 qs_rtbtimelimit;
        __u16 qs_bwarnlimit;
        __u16 qs_iwarnlimit;
} fs_quota_stat_t;
# 138 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/quota.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dqblk_v1.h" 1





#define _LINUX_DQBLK_V1_H 


#define QFMT_VFS_OLD 1


#define V1_DQF_RSQUASH 1


struct v1_mem_dqinfo {
};
# 139 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/quota.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/dqblk_v2.h" 1





#define _LINUX_DQBLK_V2_H 




#define QFMT_VFS_V0 2


struct v2_mem_dqinfo {
        unsigned int dqi_blocks;
        unsigned int dqi_free_blk;
        unsigned int dqi_free_entry;
};
# 140 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/quota.h" 2




struct mem_dqblk {
        __u32 dqb_bhardlimit;
        __u32 dqb_bsoftlimit;
        qsize_t dqb_curspace;
        __u32 dqb_ihardlimit;
        __u32 dqb_isoftlimit;
        __u32 dqb_curinodes;
        time_t dqb_btime;
        time_t dqb_itime;
};




struct quota_format_type;

struct mem_dqinfo {
        struct quota_format_type *dqi_format;
        int dqi_flags;
        unsigned int dqi_bgrace;
        unsigned int dqi_igrace;
        union {
                struct v1_mem_dqinfo v1_i;
                struct v2_mem_dqinfo v2_i;
        } u;
};

#define DQF_MASK 0xffff
#define DQF_INFO_DIRTY 0x10000
#define DQF_ANY_DQUOT_DIRTY 0x20000

extern __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void mark_info_dirty(struct mem_dqinfo *info)
{
        info->dqi_flags |= 0x10000;
}

#define info_dirty(info) ((info)->dqi_flags & DQF_INFO_DIRTY)

#define info_any_dirty(info) ((info)->dqi_flags & DQF_INFO_DIRTY || (info)->dqi_flags & DQF_ANY_DQUOT_DIRTY)


#define sb_dqopt(sb) (&(sb)->s_dquot)

struct dqstats {
        int lookups;
        int drops;
        int reads;
        int writes;
        int cache_hits;
        int allocated_dquots;
        int free_dquots;
        int syncs;
};

extern struct dqstats dqstats;

#define NR_DQHASH 43

#define DQ_LOCKED 0x01
#define DQ_MOD 0x02
#define DQ_BLKS 0x10
#define DQ_INODES 0x20
#define DQ_FAKE 0x40
#define DQ_INVAL 0x80

struct dquot {
        struct list_head dq_hash;
        struct list_head dq_inuse;
        struct list_head dq_free;
        wait_queue_head_t dq_wait_lock;
        wait_queue_head_t dq_wait_free;
        int dq_count;
        int dq_dup_ref;


        struct super_block *dq_sb;
        unsigned int dq_id;
        kdev_t dq_dev;
        loff_t dq_off;
        short dq_type;
        short dq_flags;
        struct mem_dqblk dq_dqb;
};

#define NODQUOT (struct dquot *)NULL

#define QUOTA_OK 0
#define NO_QUOTA 1


struct quota_format_ops {
        int (*check_quota_file)(struct super_block *sb, int type);
        int (*read_file_info)(struct super_block *sb, int type);
        int (*write_file_info)(struct super_block *sb, int type);
        int (*free_file_info)(struct super_block *sb, int type);
        int (*read_dqblk)(struct dquot *dquot);
        int (*commit_dqblk)(struct dquot *dquot);
};


struct dquot_operations {
        void (*initialize) (struct inode *, int);
        void (*drop) (struct inode *);
        int (*alloc_space) (struct inode *, qsize_t, int);
        int (*alloc_inode) (const struct inode *, unsigned long);
        void (*free_space) (struct inode *, qsize_t);
        void (*free_inode) (const struct inode *, unsigned long);
        int (*transfer) (struct inode *, struct iattr *);
        int (*write_dquot) (struct dquot *);
};


struct quotactl_ops {
        int (*quota_on)(struct super_block *, int, int, char *);
        int (*quota_off)(struct super_block *, int);
        int (*quota_sync)(struct super_block *, int);
        int (*get_info)(struct super_block *, int, struct if_dqinfo *);
        int (*set_info)(struct super_block *, int, struct if_dqinfo *);
        int (*get_dqblk)(struct super_block *, int, qid_t, struct if_dqblk *);
        int (*set_dqblk)(struct super_block *, int, qid_t, struct if_dqblk *);
        int (*get_xstate)(struct super_block *, struct fs_quota_stat *);
        int (*set_xstate)(struct super_block *, unsigned int, int);
        int (*get_xquota)(struct super_block *, int, qid_t, struct fs_disk_quota *);
        int (*set_xquota)(struct super_block *, int, qid_t, struct fs_disk_quota *);
};

struct quota_format_type {
        int qf_fmt_id;
        struct quota_format_ops *qf_ops;
        struct module *qf_owner;
        struct quota_format_type *qf_next;
};

#define DQUOT_USR_ENABLED 0x01
#define DQUOT_GRP_ENABLED 0x02

struct quota_info {
        unsigned int flags;
        struct semaphore dqio_sem;
        struct semaphore dqoff_sem;
        struct file *files[2];
        struct mem_dqinfo info[2];
        struct quota_format_ops *ops[2];
};


#define mark_dquot_dirty(dquot) do { dquot->dq_flags |= DQ_MOD; sb_dqopt(dquot->dq_sb)->info[dquot->dq_type].dqi_flags |= DQF_ANY_DQUOT_DIRTY;} while (0)




#define dquot_dirty(dquot) ((dquot)->dq_flags & DQ_MOD)

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int is_enabled(struct quota_info *dqopt, int type)
{
        switch (type) {
                case 0:
                        return dqopt->flags & 0x01;
                case 1:
                        return dqopt->flags & 0x02;
        }
        return 0;
}

#define sb_any_quota_enabled(sb) (is_enabled(sb_dqopt(sb), USRQUOTA) | is_enabled(sb_dqopt(sb), GRPQUOTA))

#define sb_has_quota_enabled(sb,type) (is_enabled(sb_dqopt(sb), type))

int register_quota_format(struct quota_format_type *fmt);
void unregister_quota_format(struct quota_format_type *fmt);
void init_dquot_operations(struct dquot_operations *fsdqops);
# 378 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2





struct page;
struct address_space;
struct kiobuf;

struct address_space_operations {
        int (*writepage)(struct page *);
        int (*readpage)(struct file *, struct page *);
        int (*sync_page)(struct page *);




        int (*prepare_write)(struct file *, struct page *, unsigned, unsigned);
        int (*commit_write)(struct file *, struct page *, unsigned, unsigned);

        int (*bmap)(struct address_space *, long);
        int (*flushpage) (struct page *, unsigned long);
        int (*releasepage) (struct page *, int);
#define KERNEL_HAS_O_DIRECT 
        int (*direct_IO)(int, struct inode *, struct kiobuf *, unsigned long, int);
#define KERNEL_HAS_DIRECT_FILEIO 
        int (*direct_fileIO)(int, struct file *, struct kiobuf *, unsigned long, int);
        void (*removepage)(struct page *);
};

struct address_space {
        struct list_head clean_pages;
        struct list_head dirty_pages;
        struct list_head locked_pages;
        unsigned long nrpages;
        struct address_space_operations *a_ops;
        struct inode *host;
        struct vm_area_struct *i_mmap;
        struct vm_area_struct *i_mmap_shared;
        spinlock_t i_shared_lock;
        int gfp_mask;
};

struct char_device {
        struct list_head hash;
        atomic_t count;
        dev_t dev;
        atomic_t openers;
        struct semaphore sem;
};

struct block_device {
        struct list_head bd_hash;
        atomic_t bd_count;
        struct inode * bd_inode;
        dev_t bd_dev;
        int bd_openers;
        const struct block_device_operations *bd_op;
        struct semaphore bd_sem;
        struct list_head bd_inodes;
};

struct inode {
        struct list_head i_hash;
        struct list_head i_list;
        struct list_head i_dentry;

        struct list_head i_dirty_buffers;
        struct list_head i_dirty_data_buffers;

        unsigned long i_ino;
        atomic_t i_count;
        kdev_t i_dev;
        umode_t i_mode;
        unsigned int i_nlink;
        uid_t i_uid;
        gid_t i_gid;
        kdev_t i_rdev;
        loff_t i_size;
        time_t i_atime;
        time_t i_mtime;
        time_t i_ctime;
        unsigned int i_blkbits;
        unsigned long i_blksize;
        unsigned long i_blocks;
        unsigned long i_version;
        unsigned short i_bytes;
        struct semaphore i_sem;
        struct rw_semaphore i_alloc_sem;
        struct semaphore i_zombie;
        struct inode_operations *i_op;
        struct file_operations *i_fop;
        struct super_block *i_sb;
        wait_queue_head_t i_wait;
        struct file_lock *i_flock;
        struct address_space *i_mapping;
        struct address_space i_data;
        struct dquot *i_dquot[2];

        struct list_head i_devices;
        struct pipe_inode_info *i_pipe;
        struct block_device *i_bdev;
        struct char_device *i_cdev;

        unsigned long i_dnotify_mask;
        struct dnotify_struct *i_dnotify;

        unsigned long i_state;

        unsigned int i_flags;
        unsigned char i_sock;

        atomic_t i_writecount;
        unsigned int i_attr_flags;
        __u32 i_generation;
        union {
                struct minix_inode_info minix_i;
                struct ext2_inode_info ext2_i;
                struct ext3_inode_info ext3_i;
                struct hpfs_inode_info hpfs_i;
                struct ntfs_inode_info ntfs_i;
                struct msdos_inode_info msdos_i;
                struct umsdos_inode_info umsdos_i;
                struct iso_inode_info isofs_i;
                struct nfs_inode_info nfs_i;
                struct sysv_inode_info sysv_i;
                struct affs_inode_info affs_i;
                struct ufs_inode_info ufs_i;
                struct efs_inode_info efs_i;
                struct romfs_inode_info romfs_i;
                struct shmem_inode_info shmem_i;
                struct coda_inode_info coda_i;
                struct smb_inode_info smbfs_i;
                struct hfs_inode_info hfs_i;
                struct adfs_inode_info adfs_i;
                struct qnx4_inode_info qnx4_i;
                struct reiserfs_inode_info reiserfs_i;
                struct bfs_inode_info bfs_i;
                struct udf_inode_info udf_i;
                struct ncp_inode_info ncpfs_i;
                struct proc_inode_info proc_i;
                struct socket socket_i;
                struct usbdev_inode_info usbdev_i;
                struct jffs2_inode_info jffs2_i;
                void *generic_ip;
        } u;
};

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void inode_add_bytes(struct inode *inode, loff_t bytes)
{
        inode->i_blocks += bytes >> 9;
        bytes &= 511;
        inode->i_bytes += bytes;
        if (inode->i_bytes >= 512) {
                inode->i_blocks++;
                inode->i_bytes -= 512;
        }
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void inode_sub_bytes(struct inode *inode, loff_t bytes)
{
        inode->i_blocks -= bytes >> 9;
        bytes &= 511;
        if (inode->i_bytes < bytes) {
                inode->i_blocks--;
                inode->i_bytes += 512;
        }
        inode->i_bytes -= bytes;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) loff_t inode_get_bytes(struct inode *inode)
{
        return (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void inode_set_bytes(struct inode *inode, loff_t bytes)
{
        inode->i_blocks = bytes >> 9;
        inode->i_bytes = bytes & 511;
}

struct fown_struct {
        int pid;
        uid_t uid, euid;
        int signum;
};

struct file {
        struct list_head f_list;
        struct dentry *f_dentry;
        struct vfsmount *f_vfsmnt;
        struct file_operations *f_op;
        atomic_t f_count;
        unsigned int f_flags;
        mode_t f_mode;
        loff_t f_pos;
        unsigned long f_reada, f_ramax, f_raend, f_ralen, f_rawin;
        struct fown_struct f_owner;
        unsigned int f_uid, f_gid;
        int f_error;

        size_t f_maxcount;
        unsigned long f_version;


        void *private_data;


        struct kiobuf *f_iobuf;
        long f_iobuf_lock;
};
extern spinlock_t files_lock;
#define file_list_lock() spin_lock(&files_lock);
#define file_list_unlock() spin_unlock(&files_lock);

#define get_file(x) atomic_inc(&(x)->f_count)
#define file_count(x) atomic_read(&(x)->f_count)

extern int init_private_file(struct file *, struct dentry *, int);

#define MAX_NON_LFS ((1UL<<31) - 1)




#define MAX_LFS_FILESIZE (((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1)




#define FL_POSIX 1
#define FL_FLOCK 2
#define FL_BROKEN 4
#define FL_ACCESS 8
#define FL_LOCKD 16
#define FL_LEASE 32
# 622 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
typedef struct files_struct *fl_owner_t;

struct file_lock {
        struct file_lock *fl_next;
        struct list_head fl_link;
        struct list_head fl_block;
        fl_owner_t fl_owner;
        unsigned int fl_pid;
        wait_queue_head_t fl_wait;
        struct file *fl_file;
        unsigned char fl_flags;
        unsigned char fl_type;
        loff_t fl_start;
        loff_t fl_end;

        void (*fl_notify)(struct file_lock *);
        void (*fl_insert)(struct file_lock *);
        void (*fl_remove)(struct file_lock *);

        struct fasync_struct * fl_fasync;
        unsigned long fl_break_time;

        union {
                struct nfs_lock_info nfs_fl;
        } fl_u;
};



#define INT_LIMIT(x) (~((x)1 << (sizeof(x)*8 - 1)))
#define OFFSET_MAX INT_LIMIT(loff_t)
#define OFFT_OFFSET_MAX INT_LIMIT(off_t)


extern struct list_head file_lock_list;

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fcntl.h" 1

#define _LINUX_FCNTL_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/fcntl.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/fcntl.h"
#define __ASM_FCNTL_H 



#define O_ACCMODE 0x0003
#define O_RDONLY 0x0000
#define O_WRONLY 0x0001
#define O_RDWR 0x0002
#define O_APPEND 0x0008
#define O_SYNC 0x0010
#define O_NONBLOCK 0x0080
#define O_CREAT 0x0100
#define O_TRUNC 0x0200
#define O_EXCL 0x0400
#define O_NOCTTY 0x0800
#define FASYNC 0x1000
#define O_LARGEFILE 0x2000
#define O_DIRECT 0x8000
#define O_DIRECTORY 0x10000
#define O_NOFOLLOW 0x20000

#define O_NDELAY O_NONBLOCK

#define F_DUPFD 0
#define F_GETFD 1
#define F_SETFD 2
#define F_GETFL 3
#define F_SETFL 4
#define F_GETLK 14
#define F_SETLK 6
#define F_SETLKW 7

#define F_SETOWN 24
#define F_GETOWN 23
#define F_SETSIG 10
#define F_GETSIG 11

#define F_GETLK64 33
#define F_SETLK64 34
#define F_SETLKW64 35


#define FD_CLOEXEC 1


#define F_RDLCK 0
#define F_WRLCK 1
#define F_UNLCK 2


#define F_EXLCK 4
#define F_SHLCK 8


#define F_INPROGRESS 16


#define LOCK_SH 1
#define LOCK_EX 2
#define LOCK_NB 4

#define LOCK_UN 8

#define LOCK_MAND 32
#define LOCK_READ 64
#define LOCK_WRITE 128
#define LOCK_RW 192
# 84 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/fcntl.h"
typedef struct flock {
        short l_type;
        short l_whence;
        __kernel_off_t l_start;
        __kernel_off_t l_len;
        long l_sysid;
        __kernel_pid_t l_pid;
        long pad[4];
} flock_t;

typedef struct flock64 {
        short l_type;
        short l_whence;
        loff_t l_start;
        loff_t l_len;
        pid_t l_pid;
} flock64_t;

#define F_LINUX_SPECIFIC_BASE 1024
# 5 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fcntl.h" 2

#define F_SETLEASE (F_LINUX_SPECIFIC_BASE+0)
#define F_GETLEASE (F_LINUX_SPECIFIC_BASE+1)





#define F_NOTIFY (F_LINUX_SPECIFIC_BASE+2)




#define DN_ACCESS 0x00000001
#define DN_MODIFY 0x00000002
#define DN_CREATE 0x00000004
#define DN_DELETE 0x00000008
#define DN_RENAME 0x00000010
#define DN_ATTRIB 0x00000020
#define DN_MULTISHOT 0x80000000




#define IS_GETLK32(cmd) ((cmd) == F_GETLK)
#define IS_SETLK32(cmd) ((cmd) == F_SETLK)
#define IS_SETLKW32(cmd) ((cmd) == F_SETLKW)
#define IS_GETLK64(cmd) ((cmd) == F_GETLK64)
#define IS_SETLK64(cmd) ((cmd) == F_SETLK64)
#define IS_SETLKW64(cmd) ((cmd) == F_SETLKW64)
# 44 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fcntl.h"
#define IS_GETLK(cmd) (IS_GETLK32(cmd) || IS_GETLK64(cmd))
#define IS_SETLK(cmd) (IS_SETLK32(cmd) || IS_SETLK64(cmd))
#define IS_SETLKW(cmd) (IS_SETLKW32(cmd) || IS_SETLKW64(cmd))
# 659 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2

extern int fcntl_getlk(unsigned int, struct flock *);
extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
                        struct flock *);

extern int fcntl_getlk64(unsigned int, struct flock64 *);
extern int fcntl_setlk64(unsigned int, struct file *, unsigned int,
                        struct flock64 *);


extern void locks_init_lock(struct file_lock *);
extern void locks_copy_lock(struct file_lock *, struct file_lock *);
extern void locks_remove_posix(struct file *, fl_owner_t);
extern void locks_remove_flock(struct file *);
extern struct file_lock *posix_test_lock(struct file *, struct file_lock *);
extern int posix_lock_file(struct file *, struct file_lock *, unsigned int);
extern void posix_block_lock(struct file_lock *, struct file_lock *);
extern void posix_unblock_lock(struct file_lock *);
extern int posix_locks_deadlock(struct file_lock *, struct file_lock *);
extern int __get_lease(struct inode *inode, unsigned int flags);
extern time_t lease_get_mtime(struct inode *);
extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
extern void steal_locks(fl_owner_t from);

struct fasync_struct {
        int magic;
        int fa_fd;
        struct fasync_struct *fa_next;
        struct file *fa_file;
};

#define FASYNC_MAGIC 0x4601


extern int fasync_helper(int, struct file *, int, struct fasync_struct **);

extern void kill_fasync(struct fasync_struct **, int, int);

extern void __kill_fasync(struct fasync_struct *, int, int);

struct nameidata {
        struct dentry *dentry;
        struct vfsmount *mnt;
        struct qstr last;
        unsigned int flags;
        int last_type;
};





#define MNT_FORCE 0x00000001
#define MNT_DETACH 0x00000002

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/minix_fs_sb.h" 1

#define _MINIX_FS_SB 




struct minix_sb_info {
                        unsigned long s_ninodes;
                        unsigned long s_nzones;
                        unsigned long s_imap_blocks;
                        unsigned long s_zmap_blocks;
                        unsigned long s_firstdatazone;
                        unsigned long s_log_zone_size;
                        unsigned long s_max_size;
                        int s_dirsize;
                        int s_namelen;
                        int s_link_max;
                        struct buffer_head ** s_imap;
                        struct buffer_head ** s_zmap;
                        struct buffer_head * s_sbh;
                        struct minix_super_block * s_ms;
                        unsigned short s_mount_state;
                        unsigned short s_version;
};
# 716 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext2_fs_sb.h" 1
# 17 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext2_fs_sb.h"
#define _LINUX_EXT2_FS_SB 







#define EXT2_MAX_GROUP_LOADED 8




struct ext2_sb_info {
        unsigned long s_frag_size;
        unsigned long s_frags_per_block;
        unsigned long s_inodes_per_block;
        unsigned long s_frags_per_group;
        unsigned long s_blocks_per_group;
        unsigned long s_inodes_per_group;
        unsigned long s_itb_per_group;
        unsigned long s_gdb_count;
        unsigned long s_desc_per_block;
        unsigned long s_groups_count;
        struct buffer_head * s_sbh;
        struct ext2_super_block * s_es;
        struct buffer_head ** s_group_desc;
        unsigned short s_loaded_inode_bitmaps;
        unsigned short s_loaded_block_bitmaps;
        unsigned long s_inode_bitmap_number[8];
        struct buffer_head * s_inode_bitmap[8];
        unsigned long s_block_bitmap_number[8];
        struct buffer_head * s_block_bitmap[8];
        unsigned long s_mount_opt;
        uid_t s_resuid;
        gid_t s_resgid;
        unsigned short s_mount_state;
        unsigned short s_pad;
        int s_addr_per_block_bits;
        int s_desc_per_block_bits;
        int s_inode_size;
        int s_first_ino;
};
# 717 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext3_fs_sb.h" 1
# 17 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext3_fs_sb.h"
#define _LINUX_EXT3_FS_SB 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/timer.h" 1

#define _LINUX_TIMER_H 
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/timer.h"
struct timer_list {
        struct list_head list;
        unsigned long expires;
        unsigned long data;
        void (*function)(unsigned long);
};

extern void add_timer(struct timer_list * timer);
extern int del_timer(struct timer_list * timer);





#define del_timer_sync(t) del_timer(t)
#define sync_timers() do { } while (0)
# 41 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/timer.h"
int mod_timer(struct timer_list *timer, unsigned long expires);

extern void it_real_fn(unsigned long);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void init_timer(struct timer_list * timer)
{
        timer->list.next = timer->list.prev = ((void *)0);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int timer_pending (const struct timer_list * timer)
{
        return timer->list.next != ((void *)0);
}
# 68 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/timer.h"
#define time_after(a,b) ((long)(b) - (long)(a) < 0)
#define time_before(a,b) time_after(b,a)

#define time_after_eq(a,b) ((long)(a) - (long)(b) >= 0)
#define time_before_eq(a,b) time_after_eq(b,a)
# 21 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext3_fs_sb.h" 2
# 30 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ext3_fs_sb.h"
#define EXT3_MAX_GROUP_LOADED 8




struct ext3_sb_info {
        unsigned long s_frag_size;
        unsigned long s_frags_per_block;
        unsigned long s_inodes_per_block;
        unsigned long s_frags_per_group;
        unsigned long s_blocks_per_group;
        unsigned long s_inodes_per_group;
        unsigned long s_itb_per_group;
        unsigned long s_gdb_count;
        unsigned long s_desc_per_block;
        unsigned long s_groups_count;
        struct buffer_head * s_sbh;
        struct ext3_super_block * s_es;
        struct buffer_head ** s_group_desc;
        unsigned short s_loaded_inode_bitmaps;
        unsigned short s_loaded_block_bitmaps;
        unsigned long s_inode_bitmap_number[8];
        struct buffer_head * s_inode_bitmap[8];
        unsigned long s_block_bitmap_number[8];
        struct buffer_head * s_block_bitmap[8];
        unsigned long s_mount_opt;
        uid_t s_resuid;
        gid_t s_resgid;
        unsigned short s_mount_state;
        unsigned short s_pad;
        int s_addr_per_block_bits;
        int s_desc_per_block_bits;
        int s_inode_size;
        int s_first_ino;
        u32 s_next_generation;


        struct inode * s_journal_inode;
        struct journal_s * s_journal;
        struct list_head s_orphan;
        unsigned long s_commit_interval;
        struct block_device *journal_bdev;




};
# 718 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/hpfs_fs_sb.h" 1

#define _HPFS_FS_SB 

struct hpfs_sb_info {
        ino_t sb_root;
        unsigned sb_fs_size;
        unsigned sb_bitmaps;
        unsigned sb_dirband_start;
        unsigned sb_dirband_size;
        unsigned sb_dmap;
        unsigned sb_n_free;
        unsigned sb_n_free_dnodes;
        uid_t sb_uid;
        gid_t sb_gid;
        umode_t sb_mode;
        unsigned sb_conv : 2;
        unsigned sb_eas : 2;
        unsigned sb_err : 2;
        unsigned sb_chk : 2;
        unsigned sb_lowercase : 1;
        unsigned sb_was_error : 1;
        unsigned sb_chkdsk : 2;
        unsigned sb_rd_fnode : 2;
        unsigned sb_rd_inode : 2;


        wait_queue_head_t sb_iget_q;
        unsigned char *sb_cp_table;


        unsigned *sb_bmp_dir;
        unsigned sb_c_bitmap;
        unsigned sb_max_fwd_alloc;
        wait_queue_head_t sb_creation_de;

        unsigned sb_creation_de_lock : 1;

        int sb_timeshift;
};

#define s_hpfs_root u.hpfs_sb.sb_root
#define s_hpfs_fs_size u.hpfs_sb.sb_fs_size
#define s_hpfs_bitmaps u.hpfs_sb.sb_bitmaps
#define s_hpfs_dirband_start u.hpfs_sb.sb_dirband_start
#define s_hpfs_dirband_size u.hpfs_sb.sb_dirband_size
#define s_hpfs_dmap u.hpfs_sb.sb_dmap
#define s_hpfs_uid u.hpfs_sb.sb_uid
#define s_hpfs_gid u.hpfs_sb.sb_gid
#define s_hpfs_mode u.hpfs_sb.sb_mode
#define s_hpfs_n_free u.hpfs_sb.sb_n_free
#define s_hpfs_n_free_dnodes u.hpfs_sb.sb_n_free_dnodes
#define s_hpfs_lowercase u.hpfs_sb.sb_lowercase
#define s_hpfs_conv u.hpfs_sb.sb_conv
#define s_hpfs_eas u.hpfs_sb.sb_eas
#define s_hpfs_err u.hpfs_sb.sb_err
#define s_hpfs_chk u.hpfs_sb.sb_chk
#define s_hpfs_was_error u.hpfs_sb.sb_was_error
#define s_hpfs_chkdsk u.hpfs_sb.sb_chkdsk

#define s_hpfs_rd_inode u.hpfs_sb.sb_rd_inode
#define s_hpfs_cp_table u.hpfs_sb.sb_cp_table
#define s_hpfs_bmp_dir u.hpfs_sb.sb_bmp_dir
#define s_hpfs_c_bitmap u.hpfs_sb.sb_c_bitmap
#define s_hpfs_max_fwd_alloc u.hpfs_sb.sb_max_fwd_alloc
#define s_hpfs_creation_de u.hpfs_sb.sb_creation_de
#define s_hpfs_creation_de_lock u.hpfs_sb.sb_creation_de_lock
#define s_hpfs_iget_q u.hpfs_sb.sb_iget_q

#define s_hpfs_timeshift u.hpfs_sb.sb_timeshift
# 719 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ntfs_fs_sb.h" 1

#define _LINUX_NTFS_FS_SB_H 



struct ntfs_sb_info{

        ntfs_uid_t uid;
        ntfs_gid_t gid;
        ntmode_t umask;
        void *nls_map;
        unsigned int ngt;
        char mft_zone_multiplier;
        unsigned long mft_data_pos;
        ntfs_cluster_t mft_zone_pos;
        ntfs_cluster_t mft_zone_start;
        ntfs_cluster_t mft_zone_end;
        ntfs_cluster_t data1_zone_pos;
        ntfs_cluster_t data2_zone_pos;


        ntfs_size_t partition_bias;

        ntfs_u32 at_standard_information;
        ntfs_u32 at_attribute_list;
        ntfs_u32 at_file_name;
        ntfs_u32 at_volume_version;
        ntfs_u32 at_security_descriptor;
        ntfs_u32 at_volume_name;
        ntfs_u32 at_volume_information;
        ntfs_u32 at_data;
        ntfs_u32 at_index_root;
        ntfs_u32 at_index_allocation;
        ntfs_u32 at_bitmap;
        ntfs_u32 at_symlink;

        int sector_size;
        int cluster_size;
        int cluster_size_bits;
        int mft_clusters_per_record;
        int mft_record_size;
        int mft_record_size_bits;
        int index_clusters_per_record;
        int index_record_size;
        int index_record_size_bits;
        ntfs_cluster_t nr_clusters;
        ntfs_cluster_t mft_lcn;
        ntfs_cluster_t mft_mirr_lcn;

        unsigned char *mft;
        unsigned short *upcase;
        unsigned int upcase_length;

        struct ntfs_inode_info *mft_ino;
        struct ntfs_inode_info *mftmirr;
        struct ntfs_inode_info *bitmap;
        struct super_block *sb;
        unsigned char ino_flags;
};
# 720 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/msdos_fs_sb.h" 1

#define _MSDOS_FS_SB 
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fat_cvf.h" 1

#define _FAT_CVF 

#define CVF_USE_READPAGE 0x0001

struct cvf_format
{ int cvf_version;
  char* cvf_version_text;
  unsigned long flags;
  int (*detect_cvf) (struct super_block*sb);
  int (*mount_cvf) (struct super_block*sb,char*options);
  int (*unmount_cvf) (struct super_block*sb);
  struct buffer_head* (*cvf_bread) (struct super_block*sb,int block);
  struct buffer_head* (*cvf_getblk) (struct super_block*sb,int block);
  void (*cvf_brelse) (struct super_block *sb,struct buffer_head *bh);
  void (*cvf_mark_buffer_dirty) (struct super_block *sb,
                              struct buffer_head *bh);
  void (*cvf_set_uptodate) (struct super_block *sb,
                         struct buffer_head *bh,
                         int val);
  int (*cvf_is_uptodate) (struct super_block *sb,struct buffer_head *bh);
  void (*cvf_ll_rw_block) (struct super_block *sb,
                        int opr,
                        int nbreq,
                        struct buffer_head *bh[32]);
  int (*fat_access) (struct super_block *sb,int nr,int new_value);
  int (*cvf_statfs) (struct super_block *sb,struct statfs *buf, int bufsiz);
  int (*cvf_bmap) (struct inode *inode,int block);
  ssize_t (*cvf_file_read) ( struct file *, char *, size_t, loff_t *);
  ssize_t (*cvf_file_write) ( struct file *, const char *, size_t, loff_t *);
  int (*cvf_mmap) (struct file *, struct vm_area_struct *);
  int (*cvf_readpage) (struct inode *, struct page *);
  int (*cvf_writepage) (struct inode *, struct page *);
  int (*cvf_dir_ioctl) (struct inode * inode, struct file * filp,
                        unsigned int cmd, unsigned long arg);
  void (*zero_out_cluster) (struct inode*, int clusternr);
};

int register_cvf_format(struct cvf_format*cvf_format);
int unregister_cvf_format(struct cvf_format*cvf_format);
void dec_cvf_format_use_count_by_version(int version);
int detect_cvf(struct super_block*sb,char*force);

extern struct cvf_format *cvf_formats[];
extern int cvf_format_use_count[];
# 4 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/msdos_fs_sb.h" 2





struct fat_mount_options {
        uid_t fs_uid;
        gid_t fs_gid;
        unsigned short fs_umask;
        unsigned short codepage;
        char *iocharset;
        unsigned short shortname;
        unsigned char name_check;
        unsigned char conversion;
        unsigned quiet:1,
                 showexec:1,
                 sys_immutable:1,
                 dotsOK:1,
                 isvfat:1,
                 utf8:1,
                 unicode_xlate:1,
                 posixfs:1,
                 numtail:1,
                 atari:1,
                 fat32:1,
                 nocase:1;
};

struct msdos_sb_info {
        unsigned short cluster_size;
        unsigned short cluster_bits;
        unsigned char fats,fat_bits;
        unsigned short fat_start;
        unsigned long fat_length;
        unsigned long dir_start;
        unsigned short dir_entries;
        unsigned long data_start;
        unsigned long clusters;
        unsigned long root_cluster;
        unsigned long fsinfo_sector;
        struct semaphore fat_lock;
        int prev_free;
        int free_clusters;
        struct fat_mount_options options;
        struct nls_table *nls_disk;
        struct nls_table *nls_io;
        struct cvf_format* cvf_format;
        void *dir_ops;
        void *private_data;
        int dir_per_block;
        int dir_per_block_bits;
};
# 721 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/iso_fs_sb.h" 1

#define _ISOFS_FS_SB 




struct isofs_sb_info {
        unsigned long s_ninodes;
        unsigned long s_nzones;
        unsigned long s_firstdatazone;
        unsigned long s_log_zone_size;
        unsigned long s_max_size;

        unsigned char s_high_sierra;
        unsigned char s_mapping;
        int s_rock_offset;
        unsigned char s_rock;
        unsigned char s_joliet_level;
        unsigned char s_utf8;
        unsigned char s_cruft;


        unsigned char s_unhide;
        unsigned char s_nosuid;
        unsigned char s_nodev;
        unsigned char s_nocompress;

        mode_t s_mode;
        gid_t s_gid;
        uid_t s_uid;
        struct nls_table *s_nls_iocharset;
};
# 722 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/nfs_fs_sb.h" 1

#define _NFS_FS_SB 






struct nfs_server {
        struct rpc_clnt * client;
        struct nfs_rpc_ops * rpc_ops;
        int flags;
        unsigned int rsize;
        unsigned int rpages;
        unsigned int wsize;
        unsigned int wpages;
        unsigned int dtsize;
        unsigned int bsize;
        unsigned int acregmin;
        unsigned int acregmax;
        unsigned int acdirmin;
        unsigned int acdirmax;
        unsigned int namelen;
        char * hostname;
        struct nfs_reqlist * rw_requests;
        struct list_head lru_read,
                                lru_dirty,
                                lru_commit,
                                lru_busy;
};




struct nfs_sb_info {
        struct nfs_server s_server;
};
# 723 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sysv_fs_sb.h" 1

#define _SYSV_FS_SB 
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sysv_fs_sb.h"
struct sysv_sb_info {
        int s_type;
        char s_bytesex;
        char s_truncate;

        nlink_t s_link_max;
        unsigned int s_inodes_per_block;
        unsigned int s_inodes_per_block_1;
        unsigned int s_inodes_per_block_bits;
        unsigned int s_ind_per_block;
        unsigned int s_ind_per_block_bits;
        unsigned int s_ind_per_block_2;
        unsigned int s_toobig_block;
        unsigned int s_block_base;
        unsigned short s_fic_size;
        unsigned short s_flc_size;

        struct buffer_head *s_bh1;
        struct buffer_head *s_bh2;


        char * s_sbd1;
        char * s_sbd2;
        u16 *s_sb_fic_count;
        u16 *s_sb_fic_inodes;
        u16 *s_sb_total_free_inodes;
        u16 *s_bcache_count;
        u32 *s_bcache;
        u32 *s_free_blocks;
        u32 *s_sb_time;
        u32 *s_sb_state;


        u32 s_firstinodezone;
        u32 s_firstdatazone;
        u32 s_ninodes;
        u32 s_ndatazones;
        u32 s_nzones;
        u16 s_namelen;
};



#define sv_type u.sysv_sb.s_type
#define sv_bytesex u.sysv_sb.s_bytesex
#define sv_truncate u.sysv_sb.s_truncate
#define sv_link_max u.sysv_sb.s_link_max
#define sv_inodes_per_block u.sysv_sb.s_inodes_per_block
#define sv_inodes_per_block_1 u.sysv_sb.s_inodes_per_block_1
#define sv_inodes_per_block_bits u.sysv_sb.s_inodes_per_block_bits
#define sv_ind_per_block u.sysv_sb.s_ind_per_block
#define sv_ind_per_block_bits u.sysv_sb.s_ind_per_block_bits
#define sv_ind_per_block_2 u.sysv_sb.s_ind_per_block_2
#define sv_toobig_block u.sysv_sb.s_toobig_block
#define sv_block_base u.sysv_sb.s_block_base
#define sv_fic_size u.sysv_sb.s_fic_size
#define sv_flc_size u.sysv_sb.s_flc_size
#define sv_bh1 u.sysv_sb.s_bh1
#define sv_bh2 u.sysv_sb.s_bh2
#define sv_sbd1 u.sysv_sb.s_sbd1
#define sv_sbd2 u.sysv_sb.s_sbd2
#define sv_sb_fic_count u.sysv_sb.s_sb_fic_count
#define sv_sb_fic_inodes u.sysv_sb.s_sb_fic_inodes
#define sv_sb_total_free_inodes u.sysv_sb.s_sb_total_free_inodes
#define sv_bcache_count u.sysv_sb.s_bcache_count
#define sv_bcache u.sysv_sb.s_bcache
#define sv_free_blocks u.sysv_sb.s_free_blocks
#define sv_sb_time u.sysv_sb.s_sb_time
#define sv_sb_state u.sysv_sb.s_sb_state
#define sv_firstinodezone u.sysv_sb.s_firstinodezone
#define sv_firstdatazone u.sysv_sb.s_firstdatazone
#define sv_ninodes u.sysv_sb.s_ninodes
#define sv_ndatazones u.sysv_sb.s_ndatazones
#define sv_nzones u.sysv_sb.s_nzones
#define sv_namelen u.sysv_sb.s_namelen
# 724 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/affs_fs_sb.h" 1

#define _AFFS_FS_SB 
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/affs_fs_sb.h"
struct affs_bm_info {
        u32 bm_key;
        u32 bm_free;
};

struct affs_sb_info {
        int s_partition_size;
        int s_reserved;

        u32 s_data_blksize;
        u32 s_root_block;
        int s_hashsize;
        unsigned long s_flags;
        uid_t s_uid;
        gid_t s_gid;
        umode_t s_mode;
        struct buffer_head *s_root_bh;
        struct semaphore s_bmlock;
        struct affs_bm_info *s_bitmap;
        u32 s_bmap_count;
        u32 s_bmap_bits;
        u32 s_last_bmap;
        struct buffer_head *s_bmap_bh;
        char *s_prefix;
        int s_prefix_len;
        char s_volume[32];
};

#define SF_INTL 0x0001
#define SF_BM_VALID 0x0002
#define SF_IMMUTABLE 0x0004
#define SF_QUIET 0x0008
#define SF_SETUID 0x0010
#define SF_SETGID 0x0020
#define SF_SETMODE 0x0040
#define SF_MUFS 0x0100
#define SF_OFS 0x0200
#define SF_PREFIX 0x0400
#define SF_VERBOSE 0x0800


#define AFFS_SB (&sb->u.affs_sb)
# 725 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ufs_fs_sb.h" 1
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ufs_fs_sb.h"
#define __LINUX_UFS_FS_SB_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ufs_fs.h" 1
# 28 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ufs_fs.h"
#define __LINUX_UFS_FS_H 






#define UFS_BBLOCK 0
#define UFS_BBSIZE 8192
#define UFS_SBLOCK 8192
#define UFS_SBSIZE 8192

#define UFS_SECTOR_SIZE 512
#define UFS_SECTOR_BITS 9
#define UFS_MAGIC 0x00011954
#define UFS_CIGAM 0x54190100




#define UFS_MAGIC_LFN 0x00095014
#define UFS_CIGAM_LFN 0x14500900

#define UFS_MAGIC_SEC 0x00612195
#define UFS_CIGAM_SEC 0x95216100

#define UFS_MAGIC_FEA 0x00195612
#define UFS_CIGAM_FEA 0x12561900

#define UFS_MAGIC_4GB 0x05231994
#define UFS_CIGAM_4GB 0x94192305


#define UFS_FSF_LFN 0x00000001
#define UFS_FSF_B1 0x00000002
#define UFS_FSF_LFS 0x00000002
#define UFS_FSF_LUID 0x00000004




#define UFS_BSIZE 8192
#define UFS_MINBSIZE 4096
#define UFS_FSIZE 1024
#define UFS_MAXFRAG (UFS_BSIZE / UFS_FSIZE)

#define UFS_NDADDR 12
#define UFS_NINDIR 3

#define UFS_IND_BLOCK (UFS_NDADDR + 0)
#define UFS_DIND_BLOCK (UFS_NDADDR + 1)
#define UFS_TIND_BLOCK (UFS_NDADDR + 2)

#define UFS_NDIR_FRAGMENT (UFS_NDADDR << uspi->s_fpbshift)
#define UFS_IND_FRAGMENT (UFS_IND_BLOCK << uspi->s_fpbshift)
#define UFS_DIND_FRAGMENT (UFS_DIND_BLOCK << uspi->s_fpbshift)
#define UFS_TIND_FRAGMENT (UFS_TIND_BLOCK << uspi->s_fpbshift)

#define UFS_ROOTINO 2
#define UFS_FIRST_INO (UFS_ROOTINO + 1)

#define UFS_USEEFT ((__u16)65535)

#define UFS_FSOK 0x7c269d38
#define UFS_FSACTIVE ((char)0x00)
#define UFS_FSCLEAN ((char)0x01)
#define UFS_FSSTABLE ((char)0x02)
#define UFS_FSOSF1 ((char)0x03)
#define UFS_FSBAD ((char)0xff)



#define UFS_DE_MASK 0x00000010
#define UFS_DE_OLD 0x00000000
#define UFS_DE_44BSD 0x00000010

#define UFS_UID_MASK 0x00000060
#define UFS_UID_OLD 0x00000000
#define UFS_UID_44BSD 0x00000020
#define UFS_UID_EFT 0x00000040

#define UFS_ST_MASK 0x00000700
#define UFS_ST_OLD 0x00000000
#define UFS_ST_44BSD 0x00000100
#define UFS_ST_SUN 0x00000200
#define UFS_ST_SUNx86 0x00000400

#define UFS_CG_MASK 0x00003000
#define UFS_CG_OLD 0x00000000
#define UFS_CG_44BSD 0x00002000
#define UFS_CG_SUN 0x00001000


#define UFS_42INODEFMT -1
#define UFS_44INODEFMT 2


#define UFS_MOUNT_ONERROR 0x0000000F
#define UFS_MOUNT_ONERROR_PANIC 0x00000001
#define UFS_MOUNT_ONERROR_LOCK 0x00000002
#define UFS_MOUNT_ONERROR_UMOUNT 0x00000004
#define UFS_MOUNT_ONERROR_REPAIR 0x00000008

#define UFS_MOUNT_UFSTYPE 0x00000FF0
#define UFS_MOUNT_UFSTYPE_OLD 0x00000010
#define UFS_MOUNT_UFSTYPE_44BSD 0x00000020
#define UFS_MOUNT_UFSTYPE_SUN 0x00000040
#define UFS_MOUNT_UFSTYPE_NEXTSTEP 0x00000080
#define UFS_MOUNT_UFSTYPE_NEXTSTEP_CD 0x00000100
#define UFS_MOUNT_UFSTYPE_OPENSTEP 0x00000200
#define UFS_MOUNT_UFSTYPE_SUNx86 0x00000400
#define UFS_MOUNT_UFSTYPE_HP 0x00000800

#define ufs_clear_opt(o,opt) o &= ~UFS_MOUNT_ ##opt
#define ufs_set_opt(o,opt) o |= UFS_MOUNT_ ##opt
#define ufs_test_opt(o,opt) ((o) & UFS_MOUNT_ ##opt)
# 157 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ufs_fs.h"
#define UFS_MINFREE 5
#define UFS_DEFAULTOPT UFS_OPTTIME





#define ufs_fsbtodb(uspi,b) ((b) << (uspi)->s_fsbtodb)
#define ufs_dbtofsb(uspi,b) ((b) >> (uspi)->s_fsbtodb)





#define ufs_cgbase(c) (uspi->s_fpg * (c))
#define ufs_cgstart(c) (ufs_cgbase(c) + uspi->s_cgoffset * ((c) & ~uspi->s_cgmask))
#define ufs_cgsblock(c) (ufs_cgstart(c) + uspi->s_sblkno)
#define ufs_cgcmin(c) (ufs_cgstart(c) + uspi->s_cblkno)
#define ufs_cgimin(c) (ufs_cgstart(c) + uspi->s_iblkno)
#define ufs_cgdmin(c) (ufs_cgstart(c) + uspi->s_dblkno)







#define ufs_inotocg(x) ((x) / uspi->s_ipg)
#define ufs_inotocgoff(x) ((x) % uspi->s_ipg)
#define ufs_inotofsba(x) (ufs_cgimin(ufs_inotocg(x)) + ufs_inotocgoff(x) / uspi->s_inopf)
#define ufs_inotofsbo(x) ((x) % uspi->s_inopf)





#define ufs_dtog(d) ((d) / uspi->s_fpg)
#define ufs_dtogd(d) ((d) % uspi->s_fpg)




#define ufs_cbtocylno(bno) ((bno) * uspi->s_nspf / uspi->s_spc)

#define ufs_cbtorpos(bno) ((((bno) * uspi->s_nspf % uspi->s_spc / uspi->s_nsect * uspi->s_trackskew + (bno) * uspi->s_nspf % uspi->s_spc % uspi->s_nsect * uspi->s_interleave) % uspi->s_nsect * uspi->s_nrpos) / uspi->s_npsect)
# 212 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ufs_fs.h"
#define ufs_blkoff(loc) ((loc) & uspi->s_qbmask)
#define ufs_fragoff(loc) ((loc) & uspi->s_qfmask)
#define ufs_lblktosize(blk) ((blk) << uspi->s_bshift)
#define ufs_lblkno(loc) ((loc) >> uspi->s_bshift)
#define ufs_numfrags(loc) ((loc) >> uspi->s_fshift)
#define ufs_blkroundup(size) (((size) + uspi->s_qbmask) & uspi->s_bmask)
#define ufs_fragroundup(size) (((size) + uspi->s_qfmask) & uspi->s_fmask)
#define ufs_fragstoblks(frags) ((frags) >> uspi->s_fpbshift)
#define ufs_blkstofrags(blks) ((blks) << uspi->s_fpbshift)
#define ufs_fragnum(fsb) ((fsb) & uspi->s_fpbmask)
#define ufs_blknum(fsb) ((fsb) & ~uspi->s_fpbmask)

#define UFS_MAXNAMLEN 255
#define UFS_MAXMNTLEN 512
#define UFS_MAXCSBUFS 31
#define UFS_LINK_MAX 32000





#define UFS_DIR_PAD 4
#define UFS_DIR_ROUND (UFS_DIR_PAD - 1)
#define UFS_DIR_REC_LEN(name_len) (((name_len) + 1 + 8 + UFS_DIR_ROUND) & ~UFS_DIR_ROUND)

struct ufs_timeval {
        __s32 tv_sec;
        __s32 tv_usec;
};

struct ufs_dir_entry {
        __u32 d_ino;
        __u16 d_reclen;
        union {
                __u16 d_namlen;
                struct {
                        __u8 d_type;
                        __u8 d_namlen;
                } d_44;
        } d_u;
        __u8 d_name[255 + 1];
};

struct ufs_csum {
        __u32 cs_ndir;
        __u32 cs_nbfree;
        __u32 cs_nifree;
        __u32 cs_nffree;
};




struct ufs_super_block {
        __u32 fs_link;
        __u32 fs_rlink;
        __u32 fs_sblkno;
        __u32 fs_cblkno;
        __u32 fs_iblkno;
        __u32 fs_dblkno;
        __u32 fs_cgoffset;
        __u32 fs_cgmask;
        __u32 fs_time;
        __u32 fs_size;
        __u32 fs_dsize;
        __u32 fs_ncg;
        __u32 fs_bsize;
        __u32 fs_fsize;
        __u32 fs_frag;

        __u32 fs_minfree;
        __u32 fs_rotdelay;
        __u32 fs_rps;

        __u32 fs_bmask;
        __u32 fs_fmask;
        __u32 fs_bshift;
        __u32 fs_fshift;

        __u32 fs_maxcontig;
        __u32 fs_maxbpg;

        __u32 fs_fragshift;
        __u32 fs_fsbtodb;
        __u32 fs_sbsize;
        __u32 fs_csmask;
        __u32 fs_csshift;
        __u32 fs_nindir;
        __u32 fs_inopb;
        __u32 fs_nspf;

        __u32 fs_optim;

        union {
                struct {
                        __u32 fs_npsect;
                } fs_sun;
                struct {
                        __s32 fs_state;
                } fs_sunx86;
        } fs_u1;
        __u32 fs_interleave;
        __u32 fs_trackskew;




        __u32 fs_id[2];

        __u32 fs_csaddr;
        __u32 fs_cssize;
        __u32 fs_cgsize;

        __u32 fs_ntrak;
        __u32 fs_nsect;
        __u32 fs_spc;

        __u32 fs_ncyl;

        __u32 fs_cpg;
        __u32 fs_ipg;
        __u32 fs_fpg;

        struct ufs_csum fs_cstotal;

        __s8 fs_fmod;
        __s8 fs_clean;
        __s8 fs_ronly;
        __s8 fs_flags;
        __s8 fs_fsmnt[512];

        __u32 fs_cgrotor;
        __u32 fs_csp[31];
        __u32 fs_maxcluster;
        __u32 fs_cpc;
        __u16 fs_opostbl[16][8];
        union {
                struct {
                        __s32 fs_sparecon[53];
                        __s32 fs_reclaim;
                        __s32 fs_sparecon2[1];
                        __s32 fs_state;
                        __u32 fs_qbmask[2];
                        __u32 fs_qfmask[2];
                } fs_sun;
                struct {
                        __s32 fs_sparecon[53];
                        __s32 fs_reclaim;
                        __s32 fs_sparecon2[1];
                        __u32 fs_npsect;
                        __u32 fs_qbmask[2];
                        __u32 fs_qfmask[2];
                } fs_sunx86;
                struct {
                        __s32 fs_sparecon[50];
                        __s32 fs_contigsumsize;
                        __s32 fs_maxsymlinklen;
                        __s32 fs_inodefmt;
                        __u32 fs_maxfilesize[2];
                        __u32 fs_qbmask[2];
                        __u32 fs_qfmask[2];
                        __s32 fs_state;
                } fs_44;
        } fs_u2;
        __s32 fs_postblformat;
        __s32 fs_nrpos;
        __s32 fs_postbloff;
        __s32 fs_rotbloff;
        __s32 fs_magic;
        __u8 fs_space[1];
};




#define UFS_OPTTIME 0
#define UFS_OPTSPACE 1




#define UFS_42POSTBLFMT -1
#define UFS_DYNAMICPOSTBLFMT 1




#define fs_cs(indx) u.ufs_sb.s_csp[(indx) >> uspi->s_csshift][(indx) & ~uspi->s_csmask]
# 408 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ufs_fs.h"
#define CG_MAGIC 0x090255
#define ufs_cg_chkmagic(sb,ucg) (fs32_to_cpu((sb), (ucg)->cg_magic) == CG_MAGIC)





struct ufs_cylinder_group {
        __u32 cg_link;
        __u32 cg_magic;
        __u32 cg_time;
        __u32 cg_cgx;
        __u16 cg_ncyl;
        __u16 cg_niblk;
        __u32 cg_ndblk;
        struct ufs_csum cg_cs;
        __u32 cg_rotor;
        __u32 cg_frotor;
        __u32 cg_irotor;
        __u32 cg_frsum[(8192 / 1024)];
        __u32 cg_btotoff;
        __u32 cg_boff;
        __u32 cg_iusedoff;
        __u32 cg_freeoff;
        __u32 cg_nextfreeoff;
        union {
                struct {
                        __u32 cg_clustersumoff;
                        __u32 cg_clusteroff;
                        __u32 cg_nclusterblks;
                        __u32 cg_sparecon[13];
                } cg_44;
                __u32 cg_sparecon[16];
        } cg_u;
        __u8 cg_space[1];

};




struct ufs_inode {
        __u16 ui_mode;
        __u16 ui_nlink;
        union {
                struct {
                        __u16 ui_suid;
                        __u16 ui_sgid;
                } oldids;
                __u32 ui_inumber;
                __u32 ui_author;
        } ui_u1;
        __u64 ui_size;
        struct ufs_timeval ui_atime;
        struct ufs_timeval ui_mtime;
        struct ufs_timeval ui_ctime;
        union {
                struct {
                        __u32 ui_db[12];
                        __u32 ui_ib[3];
                } ui_addr;
                __u8 ui_symlink[4*(12 +3)];
        } ui_u2;
        __u32 ui_flags;
        __u32 ui_blocks;
        __u32 ui_gen;
        union {
                struct {
                        __u32 ui_shadow;
                        __u32 ui_uid;
                        __u32 ui_gid;
                        __u32 ui_oeftflag;
                } ui_sun;
                struct {
                        __u32 ui_uid;
                        __u32 ui_gid;
                        __s32 ui_spare[2];
                } ui_44;
                struct {
                        __u32 ui_uid;
                        __u32 ui_gid;
                        __u16 ui_modeh;
                        __u16 ui_spare;
                        __u32 ui_trans;
                } ui_hurd;
        } ui_u3;
};



#define UFS_UF_SETTABLE 0x0000ffff
#define UFS_UF_NODUMP 0x00000001
#define UFS_UF_IMMUTABLE 0x00000002
#define UFS_UF_APPEND 0x00000004
#define UFS_UF_OPAQUE 0x00000008
#define UFS_UF_NOUNLINK 0x00000010

#define UFS_SF_SETTABLE 0xffff0000
#define UFS_SF_ARCHIVED 0x00010000
#define UFS_SF_IMMUTABLE 0x00020000
#define UFS_SF_APPEND 0x00040000
#define UFS_SF_NOUNLINK 0x00100000




extern void ufs_free_fragments (struct inode *, unsigned, unsigned);
extern void ufs_free_blocks (struct inode *, unsigned, unsigned);
extern unsigned ufs_new_fragments (struct inode *, u32 *, unsigned, unsigned, unsigned, int *);


extern struct ufs_cg_private_info * ufs_load_cylinder (struct super_block *, unsigned);
extern void ufs_put_cylinder (struct super_block *, unsigned);


extern struct inode_operations ufs_dir_inode_operations;
extern int ufs_check_dir_entry (const char *, struct inode *, struct ufs_dir_entry *, struct buffer_head *, unsigned long);
extern int ufs_add_link (struct dentry *, struct inode *);
extern ino_t ufs_inode_by_name(struct inode *, struct dentry *);
extern int ufs_make_empty(struct inode *, struct inode *);
extern struct ufs_dir_entry * ufs_find_entry (struct dentry *, struct buffer_head **);
extern int ufs_delete_entry (struct inode *, struct ufs_dir_entry *, struct buffer_head *);
extern int ufs_empty_dir (struct inode *);
extern struct ufs_dir_entry * ufs_dotdot (struct inode *, struct buffer_head **);
extern void ufs_set_link(struct inode *, struct ufs_dir_entry *, struct buffer_head *, struct inode *);


extern struct inode_operations ufs_file_inode_operations;
extern struct file_operations ufs_file_operations;

extern struct address_space_operations ufs_aops;


extern void ufs_free_inode (struct inode *inode);
extern struct inode * ufs_new_inode (const struct inode *, int);


extern int ufs_frag_map (struct inode *, int);
extern void ufs_read_inode (struct inode *);
extern void ufs_put_inode (struct inode *);
extern void ufs_write_inode (struct inode *, int);
extern int ufs_sync_inode (struct inode *);
extern void ufs_delete_inode (struct inode *);
extern struct buffer_head * ufs_getfrag (struct inode *, unsigned, int, int *);
extern struct buffer_head * ufs_bread (struct inode *, unsigned, int, int *);


extern struct file_operations ufs_dir_operations;


extern void ufs_warning (struct super_block *, const char *, const char *, ...) __attribute__ ((format (printf, 3, 4)));
extern void ufs_error (struct super_block *, const char *, const char *, ...) __attribute__ ((format (printf, 3, 4)));
extern void ufs_panic (struct super_block *, const char *, const char *, ...) __attribute__ ((format (printf, 3, 4)));
extern void ufs_write_super (struct super_block *);


extern struct inode_operations ufs_fast_symlink_inode_operations;


extern void ufs_truncate (struct inode *);
# 18 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ufs_fs_sb.h" 2





struct ufs_buffer_head {
        unsigned fragment;
        unsigned count;
        struct buffer_head * bh[(8192 / 1024)];
};

struct ufs_cg_private_info {
        struct ufs_cylinder_group ucg;
        __u32 c_cgx;
        __u16 c_ncyl;
        __u16 c_niblk;
        __u32 c_ndblk;
        __u32 c_rotor;
        __u32 c_frotor;
        __u32 c_irotor;
        __u32 c_btotoff;
        __u32 c_boff;
        __u32 c_iusedoff;
        __u32 c_freeoff;
        __u32 c_nextfreeoff;
        __u32 c_clustersumoff;
        __u32 c_clusteroff;
        __u32 c_nclusterblks;
};

struct ufs_sb_private_info {
        struct ufs_buffer_head s_ubh;
        __u32 s_sblkno;
        __u32 s_cblkno;
        __u32 s_iblkno;
        __u32 s_dblkno;
        __u32 s_cgoffset;
        __u32 s_cgmask;
        __u32 s_size;
        __u32 s_dsize;
        __u32 s_ncg;
        __u32 s_bsize;
        __u32 s_fsize;
        __u32 s_fpb;
        __u32 s_minfree;
        __u32 s_bmask;
        __u32 s_fmask;
        __u32 s_bshift;
        __u32 s_fshift;
        __u32 s_fpbshift;
        __u32 s_fsbtodb;
        __u32 s_sbsize;
        __u32 s_csmask;
        __u32 s_csshift;
        __u32 s_nindir;
        __u32 s_inopb;
        __u32 s_nspf;
        __u32 s_npsect;
        __u32 s_interleave;
        __u32 s_trackskew;
        __u32 s_csaddr;
        __u32 s_cssize;
        __u32 s_cgsize;
        __u32 s_ntrak;
        __u32 s_nsect;
        __u32 s_spc;
        __u32 s_ipg;
        __u32 s_fpg;
        __u32 s_cpc;
        __s32 s_contigsumsize;
        __s64 s_qbmask;
        __s64 s_qfmask;
        __s32 s_postblformat;
        __s32 s_nrpos;
        __s32 s_postbloff;
        __s32 s_rotbloff;

        __u32 s_fpbmask;
        __u32 s_apb;
        __u32 s_2apb;
        __u32 s_3apb;
        __u32 s_apbmask;
        __u32 s_apbshift;
        __u32 s_2apbshift;
        __u32 s_3apbshift;
        __u32 s_nspfshift;
        __u32 s_nspb;
        __u32 s_inopf;
        __u32 s_sbbase;
        __u32 s_bpf;
        __u32 s_bpfshift;
        __u32 s_bpfmask;

        __u32 s_maxsymlinklen;
};


#define UFS_MAX_GROUP_LOADED 8
#define UFS_CGNO_EMPTY ((unsigned)-1)

struct ufs_sb_info {
        struct ufs_sb_private_info * s_uspi;
        struct ufs_csum * s_csp[31];
        unsigned s_bytesex;
        unsigned s_flags;
        struct buffer_head ** s_ucg;
        struct ufs_cg_private_info * s_ucpi[8];
        unsigned s_cgno[8];
        unsigned short s_cg_loaded;
        unsigned s_mount_opt;
};







struct ufs_super_block_first {
        __u32 fs_link;
        __u32 fs_rlink;
        __u32 fs_sblkno;
        __u32 fs_cblkno;
        __u32 fs_iblkno;
        __u32 fs_dblkno;
        __u32 fs_cgoffset;
        __u32 fs_cgmask;
        __u32 fs_time;
        __u32 fs_size;
        __u32 fs_dsize;
        __u32 fs_ncg;
        __u32 fs_bsize;
        __u32 fs_fsize;
        __u32 fs_frag;
        __u32 fs_minfree;
        __u32 fs_rotdelay;
        __u32 fs_rps;
        __u32 fs_bmask;
        __u32 fs_fmask;
        __u32 fs_bshift;
        __u32 fs_fshift;
        __u32 fs_maxcontig;
        __u32 fs_maxbpg;
        __u32 fs_fragshift;
        __u32 fs_fsbtodb;
        __u32 fs_sbsize;
        __u32 fs_csmask;
        __u32 fs_csshift;
        __u32 fs_nindir;
        __u32 fs_inopb;
        __u32 fs_nspf;
        __u32 fs_optim;
        union {
                struct {
                        __u32 fs_npsect;
                } fs_sun;
                struct {
                        __s32 fs_state;
                } fs_sunx86;
        } fs_u1;
        __u32 fs_interleave;
        __u32 fs_trackskew;
        __u32 fs_id[2];
        __u32 fs_csaddr;
        __u32 fs_cssize;
        __u32 fs_cgsize;
        __u32 fs_ntrak;
        __u32 fs_nsect;
        __u32 fs_spc;
        __u32 fs_ncyl;
        __u32 fs_cpg;
        __u32 fs_ipg;
        __u32 fs_fpg;
        struct ufs_csum fs_cstotal;
        __s8 fs_fmod;
        __s8 fs_clean;
        __s8 fs_ronly;
        __s8 fs_flags;
        __s8 fs_fsmnt[512 - 212];

};

struct ufs_super_block_second {
        __s8 fs_fsmnt[212];
        __u32 fs_cgrotor;
        __u32 fs_csp[31];
        __u32 fs_maxcluster;
        __u32 fs_cpc;
        __u16 fs_opostbl[82];
};

struct ufs_super_block_third {
        __u16 fs_opostbl[46];
        union {
                struct {
                        __s32 fs_sparecon[53];
                        __s32 fs_reclaim;
                        __s32 fs_sparecon2[1];
                        __s32 fs_state;
                        __u32 fs_qbmask[2];
                        __u32 fs_qfmask[2];
                } fs_sun;
                struct {
                        __s32 fs_sparecon[53];
                        __s32 fs_reclaim;
                        __s32 fs_sparecon2[1];
                        __u32 fs_npsect;
                        __u32 fs_qbmask[2];
                        __u32 fs_qfmask[2];
                } fs_sunx86;
                struct {
                        __s32 fs_sparecon[50];
                        __s32 fs_contigsumsize;
                        __s32 fs_maxsymlinklen;
                        __s32 fs_inodefmt;
                        __u32 fs_maxfilesize[2];
                        __u32 fs_qbmask[2];
                        __u32 fs_qfmask[2];
                        __s32 fs_state;
                } fs_44;
        } fs_u2;
        __s32 fs_postblformat;
        __s32 fs_nrpos;
        __s32 fs_postbloff;
        __s32 fs_rotbloff;
        __s32 fs_magic;
        __u8 fs_space[1];
};
# 726 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/efs_fs_sb.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/efs_fs_sb.h"
#define __EFS_FS_SB_H__ 


#define EFS_SUPER_MAGIC 0x414A53


#define EFS_MAGIC 0x072959
#define EFS_NEWMAGIC 0x07295a

#define IS_EFS_MAGIC(x) ((x == EFS_MAGIC) || (x == EFS_NEWMAGIC))

#define EFS_SUPER 1
#define EFS_ROOTINODE 2


struct efs_super {
        int32_t fs_size;
        int32_t fs_firstcg;
        int32_t fs_cgfsize;
        short fs_cgisize;
        short fs_sectors;
        short fs_heads;
        short fs_ncg;
        short fs_dirty;
        int32_t fs_time;
        int32_t fs_magic;
        char fs_fname[6];
        char fs_fpack[6];
        int32_t fs_bmsize;
        int32_t fs_tfree;
        int32_t fs_tinode;
        int32_t fs_bmblock;
        int32_t fs_replsb;
        int32_t fs_lastialloc;
        char fs_spare[20];
        int32_t fs_checksum;
};


struct efs_sb_info {
        int32_t fs_magic;
        int32_t fs_start;
        int32_t first_block;
        int32_t total_blocks;
        int32_t group_size;
        int32_t data_free;
        int32_t inode_free;
        short inode_blocks;
        short total_groups;
};
# 727 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/romfs_fs_sb.h" 1

#define __ROMFS_FS_SB 



struct romfs_sb_info {
        unsigned long s_maxsize;
};
# 728 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/smb_fs_sb.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/smb_fs_sb.h"
#define _SMB_FS_SB 




# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/smb.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/smb.h"
#define _LINUX_SMB_H 



enum smb_protocol {
        SMB_PROTOCOL_NONE,
        SMB_PROTOCOL_CORE,
        SMB_PROTOCOL_COREPLUS,
        SMB_PROTOCOL_LANMAN1,
        SMB_PROTOCOL_LANMAN2,
        SMB_PROTOCOL_NT1
};

enum smb_case_hndl {
        SMB_CASE_DEFAULT,
        SMB_CASE_LOWER,
        SMB_CASE_UPPER
};

struct smb_dskattr {
        __u16 total;
        __u16 allocblocks;
        __u16 blocksize;
        __u16 free;
};

struct smb_conn_opt {


        unsigned int fd;

        enum smb_protocol protocol;
        enum smb_case_hndl case_handling;



        __u32 max_xmit;
        __u16 server_uid;
        __u16 tid;


        __u16 secmode;
        __u16 maxmux;
        __u16 maxvcs;
        __u16 rawmode;
        __u32 sesskey;


        __u32 maxraw;
        __u32 capabilities;
        __s16 serverzone;
};



#define SMB_NLS_MAXNAMELEN 20
struct smb_nls_codepage {
        char local_name[20];
        char remote_name[20];
};


#define SMB_MAXNAMELEN 255
#define SMB_MAXPATHLEN 1024




struct smb_fattr {

        __u16 attr;

        unsigned long f_ino;
        umode_t f_mode;
        nlink_t f_nlink;
        uid_t f_uid;
        gid_t f_gid;
        kdev_t f_rdev;
        loff_t f_size;
        time_t f_atime;
        time_t f_mtime;
        time_t f_ctime;
        unsigned long f_blksize;
        unsigned long f_blocks;
        int f_unix;
};

enum smb_conn_state {
        CONN_VALID,
        CONN_INVALID,

        CONN_RETRIED,
        CONN_RETRYING
};

#define SMB_SUPER_MAGIC 0x517B

#define SMB_HEADER_LEN 37


#define SMB_INITIAL_PACKET_SIZE 4000
#define SMB_MAX_PACKET_SIZE 32768



#define SMB_TRANS2_MAX_PARAM 64
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/smb_fs_sb.h" 2


#define server_from_inode(inode) (&(inode)->i_sb->u.smbfs_sb)
#define server_from_dentry(dentry) (&(dentry)->d_sb->u.smbfs_sb)
#define SB_of(server) ((struct super_block *) ((char *)(server) - (unsigned long)(&((struct super_block *)0)->u.smbfs_sb)))


struct smb_sb_info {
        enum smb_conn_state state;
        struct file * sock_file;

        struct smb_mount_data_kernel *mnt;
        unsigned char *temp_buf;




        unsigned int generation;
        pid_t conn_pid;
        struct smb_conn_opt opt;

        struct semaphore sem;
        wait_queue_head_t wait;

        __u32 packet_size;
        unsigned char * packet;
        unsigned short rcls;
        unsigned short err;


        void *data_ready;


        struct nls_table *remote_nls;
        struct nls_table *local_nls;




        char *name_buf;

        struct smb_ops *ops;
};


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void
smb_lock_server(struct smb_sb_info *server)
{
        down(&(server->sem));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void
smb_unlock_server(struct smb_sb_info *server)
{
        up(&(server->sem));
}
# 729 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/hfs_fs_sb.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/hfs_fs_sb.h"
#define _LINUX_HFS_FS_SB_H 


struct hfs_name;

typedef int (*hfs_namein_fn) (char *, const struct hfs_name *);
typedef void (*hfs_nameout_fn) (struct hfs_name *, const char *, int);
typedef void (*hfs_ifill_fn) (struct inode *, ino_t, const int);






struct hfs_sb_info {
        int magic;
        struct hfs_mdb *s_mdb;
        int s_quiet;

        int s_lowercase;
        int s_afpd;
        int s_version;
        hfs_namein_fn s_namein;


        hfs_nameout_fn s_nameout;


        hfs_ifill_fn s_ifill;

        const struct hfs_name *s_reserved1;
        const struct hfs_name *s_reserved2;
        __u32 s_type;
        __u32 s_creator;
        umode_t s_umask;

        uid_t s_uid;
        gid_t s_gid;
        char s_conv;
};
# 730 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/adfs_fs_sb.h" 1







#define _ADFS_FS_SB 




struct adfs_discmap;
struct adfs_dir_ops;




struct adfs_sb_info {
        struct adfs_discmap *s_map;
        struct adfs_dir_ops *s_dir;

        uid_t s_uid;
        gid_t s_gid;
        umode_t s_owner_mask;
        umode_t s_other_mask;

        __u32 s_ids_per_zone;
        __u32 s_idlen;
        __u32 s_map_size;
        unsigned long s_size;
        signed int s_map2blk;
        unsigned int s_log2sharesize;
        unsigned int s_version;
        unsigned int s_namelen;
};
# 731 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/qnx4_fs_sb.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/qnx4_fs_sb.h"
#define _QNX4_FS_SB 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/qnx4_fs.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/qnx4_fs.h"
#define _LINUX_QNX4_FS_H 



#define QNX4_ROOT_INO 1

#define QNX4_MAX_XTNTS_PER_XBLK 60

#define QNX4_FILE_USED 0x01
#define QNX4_FILE_MODIFIED 0x02
#define QNX4_FILE_BUSY 0x04
#define QNX4_FILE_LINK 0x08
#define QNX4_FILE_INODE 0x10
#define QNX4_FILE_FSYSCLEAN 0x20

#define QNX4_I_MAP_SLOTS 8
#define QNX4_Z_MAP_SLOTS 64
#define QNX4_SUPER_MAGIC 0x002f
#define QNX4_VALID_FS 0x0001
#define QNX4_ERROR_FS 0x0002
#define QNX4_BLOCK_SIZE 0x200
#define QNX4_BLOCK_SIZE_BITS 9
#define QNX4_DIR_ENTRY_SIZE 0x040
#define QNX4_DIR_ENTRY_SIZE_BITS 6
#define QNX4_XBLK_ENTRY_SIZE 0x200
#define QNX4_INODES_PER_BLOCK 0x08


#define QNX4_SHORT_NAME_MAX 16
#define QNX4_NAME_MAX 48




struct qnx4_inode_entry {
        char di_fname[16];
        qnx4_off_t di_size;
        qnx4_xtnt_t di_first_xtnt;
        __u32 di_xblk;
        __s32 di_ftime;
        __s32 di_mtime;
        __s32 di_atime;
        __s32 di_ctime;
        qnx4_nxtnt_t di_num_xtnts;
        qnx4_mode_t di_mode;
        qnx4_muid_t di_uid;
        qnx4_mgid_t di_gid;
        qnx4_nlink_t di_nlink;
        __u8 di_zero[4];
        qnx4_ftype_t di_type;
        __u8 di_status;
};

struct qnx4_link_info {
        char dl_fname[48];
        __u32 dl_inode_blk;
        __u8 dl_inode_ndx;
        __u8 dl_spare[10];
        __u8 dl_status;
};

struct qnx4_xblk {
        __u32 xblk_next_xblk;
        __u32 xblk_prev_xblk;
        __u8 xblk_num_xtnts;
        __u8 xblk_spare[3];
        __s32 xblk_num_blocks;
        qnx4_xtnt_t xblk_xtnts[60];
        char xblk_signature[8];
        qnx4_xtnt_t xblk_first_xtnt;
};

struct qnx4_super_block {
        struct qnx4_inode_entry RootDir;
        struct qnx4_inode_entry Inode;
        struct qnx4_inode_entry Boot;
        struct qnx4_inode_entry AltBoot;
};



#define QNX4_DEBUG 0




#define QNX4DEBUG(X) (void) 0


extern struct dentry *qnx4_lookup(struct inode *dir, struct dentry *dentry);
extern unsigned long qnx4_count_free_blocks(struct super_block *sb);
extern unsigned long qnx4_block_map(struct inode *inode, long iblock);

extern struct buffer_head *qnx4_getblk(struct inode *, int, int);
extern struct buffer_head *qnx4_bread(struct inode *, int, int);

extern int qnx4_create(struct inode *dir, struct dentry *dentry, int mode);
extern struct inode_operations qnx4_file_inode_operations;
extern struct inode_operations qnx4_dir_inode_operations;
extern struct file_operations qnx4_file_operations;
extern struct file_operations qnx4_dir_operations;
extern int qnx4_is_free(struct super_block *sb, long block);
extern int qnx4_set_bitmap(struct super_block *sb, long block, int busy);
extern int qnx4_create(struct inode *inode, struct dentry *dentry, int mode);
extern void qnx4_truncate(struct inode *inode);
extern void qnx4_free_inode(struct inode *inode);
extern int qnx4_unlink(struct inode *dir, struct dentry *dentry);
extern int qnx4_rmdir(struct inode *dir, struct dentry *dentry);
extern int qnx4_sync_file(struct file *file, struct dentry *dentry, int);
extern int qnx4_sync_inode(struct inode *inode);
extern int qnx4_get_block(struct inode *inode, long iblock, struct buffer_head *bh, int create);
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/qnx4_fs_sb.h" 2





struct qnx4_sb_info {
        struct buffer_head *sb_buf;
        struct qnx4_super_block *sb;
        unsigned int Version;
        struct qnx4_inode_entry *BitMap;
};
# 732 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/reiserfs_fs_sb.h" 1




#define _LINUX_REISER_FS_SB 
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/reiserfs_fs_sb.h"
#define REISERFS_VERSION_2 2
#define UNSET_HASH 0

#define TEA_HASH 1
#define YURA_HASH 2
#define R5_HASH 3
#define DEFAULT_HASH R5_HASH





typedef enum {
  reiserfs_attrs_cleared = 0x00000001,
} reiserfs_super_block_flags;

#define sb_block_count(sbp) (le32_to_cpu((sbp)->s_v1.s_block_count))
#define set_sb_block_count(sbp,v) ((sbp)->s_v1.s_block_count = cpu_to_le32(v))
#define sb_free_blocks(sbp) (le32_to_cpu((sbp)->s_v1.s_free_blocks))
#define set_sb_free_blocks(sbp,v) ((sbp)->s_v1.s_free_blocks = cpu_to_le32(v))
#define sb_root_block(sbp) (le32_to_cpu((sbp)->s_v1.s_root_block))
#define set_sb_root_block(sbp,v) ((sbp)->s_v1.s_root_block = cpu_to_le32(v))

#define sb_jp_journal_1st_block(sbp) (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_1st_block))

#define set_sb_jp_journal_1st_block(sbp,v) ((sbp)->s_v1.s_journal.jp_journal_1st_block = cpu_to_le32(v))

#define sb_jp_journal_dev(sbp) (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_dev))

#define set_sb_jp_journal_dev(sbp,v) ((sbp)->s_v1.s_journal.jp_journal_dev = cpu_to_le32(v))

#define sb_jp_journal_size(sbp) (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_size))

#define set_sb_jp_journal_size(sbp,v) ((sbp)->s_v1.s_journal.jp_journal_size = cpu_to_le32(v))

#define sb_jp_journal_trans_max(sbp) (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_trans_max))

#define set_sb_jp_journal_trans_max(sbp,v) ((sbp)->s_v1.s_journal.jp_journal_trans_max = cpu_to_le32(v))

#define sb_jp_journal_magic(sbp) (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_magic))

#define set_sb_jp_journal_magic(sbp,v) ((sbp)->s_v1.s_journal.jp_journal_magic = cpu_to_le32(v))

#define sb_jp_journal_max_batch(sbp) (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_max_batch))

#define set_sb_jp_journal_max_batch(sbp,v) ((sbp)->s_v1.s_journal.jp_journal_max_batch = cpu_to_le32(v))

#define sb_jp_jourmal_max_commit_age(sbp) (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_max_commit_age))

#define set_sb_jp_journal_max_commit_age(sbp,v) ((sbp)->s_v1.s_journal.jp_journal_max_commit_age = cpu_to_le32(v))


#define sb_blocksize(sbp) (le16_to_cpu((sbp)->s_v1.s_blocksize))
#define set_sb_blocksize(sbp,v) ((sbp)->s_v1.s_blocksize = cpu_to_le16(v))
#define sb_oid_maxsize(sbp) (le16_to_cpu((sbp)->s_v1.s_oid_maxsize))
#define set_sb_oid_maxsize(sbp,v) ((sbp)->s_v1.s_oid_maxsize = cpu_to_le16(v))
#define sb_oid_cursize(sbp) (le16_to_cpu((sbp)->s_v1.s_oid_cursize))
#define set_sb_oid_cursize(sbp,v) ((sbp)->s_v1.s_oid_cursize = cpu_to_le16(v))
#define sb_umount_state(sbp) (le16_to_cpu((sbp)->s_v1.s_umount_state))
#define set_sb_umount_state(sbp,v) ((sbp)->s_v1.s_umount_state = cpu_to_le16(v))
#define sb_fs_state(sbp) (le16_to_cpu((sbp)->s_v1.s_fs_state))
#define set_sb_fs_state(sbp,v) ((sbp)->s_v1.s_fs_state = cpu_to_le16(v))
#define sb_hash_function_code(sbp) (le32_to_cpu((sbp)->s_v1.s_hash_function_code))

#define set_sb_hash_function_code(sbp,v) ((sbp)->s_v1.s_hash_function_code = cpu_to_le32(v))

#define sb_tree_height(sbp) (le16_to_cpu((sbp)->s_v1.s_tree_height))
#define set_sb_tree_height(sbp,v) ((sbp)->s_v1.s_tree_height = cpu_to_le16(v))
#define sb_bmap_nr(sbp) (le16_to_cpu((sbp)->s_v1.s_bmap_nr))
#define set_sb_bmap_nr(sbp,v) ((sbp)->s_v1.s_bmap_nr = cpu_to_le16(v))
#define sb_version(sbp) (le16_to_cpu((sbp)->s_v1.s_version))
#define set_sb_version(sbp,v) ((sbp)->s_v1.s_version = cpu_to_le16(v))

#define sb_reserved_for_journal(sbp) (le16_to_cpu((sbp)->s_v1.s_reserved_for_journal))

#define set_sb_reserved_for_journal(sbp,v) ((sbp)->s_v1.s_reserved_for_journal = cpu_to_le16(v))
# 119 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/reiserfs_fs_sb.h"
#define JOURNAL_BLOCK_SIZE 4096
#define JOURNAL_MAX_CNODE 1500
#define JOURNAL_HASH_SIZE 8192
#define JOURNAL_NUM_BITMAPS 5
#define JOURNAL_LIST_COUNT 64



#define BH_JDirty 16
#define BH_JDirty_wait 18
#define BH_JNew 19






#define BH_JPrepared 20
#define BH_JRestore_dirty 22
# 147 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/reiserfs_fs_sb.h"
struct reiserfs_journal_cnode {
  struct buffer_head *bh ;
  kdev_t dev ;
  unsigned long blocknr ;
  long state ;
  struct reiserfs_journal_list *jlist ;
  struct reiserfs_journal_cnode *next ;
  struct reiserfs_journal_cnode *prev ;
  struct reiserfs_journal_cnode *hprev ;
  struct reiserfs_journal_cnode *hnext ;
};

struct reiserfs_bitmap_node {
  int id ;
  char *data ;
  struct list_head list ;
} ;

struct reiserfs_list_bitmap {
  struct reiserfs_journal_list *journal_list ;
  struct reiserfs_bitmap_node **bitmaps ;
} ;




struct reiserfs_transaction_handle {

  char *t_caller ;
  int t_blocks_logged ;
  int t_blocks_allocated ;
  unsigned long t_trans_id ;
  struct super_block *t_super ;

  int displace_new_blocks:1;

} ;







struct reiserfs_journal_list {
  unsigned long j_start ;
  unsigned long j_len ;
  atomic_t j_nonzerolen ;
  atomic_t j_commit_left ;
  atomic_t j_flushing ;
  atomic_t j_commit_flushing ;
  atomic_t j_older_commits_done ;
  unsigned long j_trans_id ;
  time_t j_timestamp ;
  struct reiserfs_list_bitmap *j_list_bitmap ;
  struct buffer_head *j_commit_bh ;
  struct reiserfs_journal_cnode *j_realblock ;
  struct reiserfs_journal_cnode *j_freedlist ;
  wait_queue_head_t j_commit_wait ;
  wait_queue_head_t j_flush_wait ;
} ;

struct reiserfs_page_list ;

struct reiserfs_journal {
  struct buffer_head ** j_ap_blocks ;
  struct reiserfs_journal_cnode *j_last ;
  struct reiserfs_journal_cnode *j_first ;

  kdev_t j_dev;
  struct file *j_dev_file;
  struct block_device *j_dev_bd;
        int j_1st_reserved_block;

  long j_state ;
  unsigned long j_trans_id ;
  unsigned long j_mount_id ;
  unsigned long j_start ;
  unsigned long j_len ;
  unsigned long j_len_alloc ;
  atomic_t j_wcount ;
  unsigned long j_bcount ;
  unsigned long j_first_unflushed_offset ;
  unsigned long j_last_flush_trans_id ;
  struct buffer_head *j_header_bh ;




  struct reiserfs_page_list *j_flush_pages ;
  time_t j_trans_start_time ;
  wait_queue_head_t j_wait ;
  atomic_t j_wlock ;
  wait_queue_head_t j_join_wait ;
  atomic_t j_jlock ;
  int j_journal_list_index ;
  int j_list_bitmap_index ;
  int j_must_wait ;
  int j_next_full_flush ;
  int j_next_async_flush ;

  int j_cnode_used ;
  int j_cnode_free ;

  unsigned int s_journal_trans_max ;
  unsigned int s_journal_max_batch ;
  unsigned int s_journal_max_commit_age ;
  unsigned int s_journal_max_trans_age ;

  struct reiserfs_journal_cnode *j_cnode_free_list ;
  struct reiserfs_journal_cnode *j_cnode_free_orig ;

  int j_free_bitmap_nodes ;
  int j_used_bitmap_nodes ;
  struct list_head j_bitmap_nodes ;
  struct list_head j_dirty_buffers ;
  struct reiserfs_list_bitmap j_list_bitmap[5] ;
  struct reiserfs_journal_list j_journal_list[64] ;
  struct reiserfs_journal_cnode *j_hash_table[8192] ;
  struct reiserfs_journal_cnode *j_list_hash_table[8192] ;

  struct list_head j_prealloc_list;
};

#define JOURNAL_DESC_MAGIC "ReIsErLB"


typedef __u32 (*hashf_t) (const signed char *, int);

struct reiserfs_bitmap_info
{

    __u16 first_zero_hint;
    __u16 free_count;
    struct buffer_head *bh;
};

struct proc_dir_entry;
# 355 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/reiserfs_fs_sb.h"
typedef struct reiserfs_proc_info_data
{} reiserfs_proc_info_data_t;



struct reiserfs_sb_info
{
    struct buffer_head * s_sbh;


    struct reiserfs_super_block * s_rs;
    struct reiserfs_bitmap_info * s_ap_bitmap;
    struct reiserfs_journal *s_journal ;
    unsigned short s_mount_state;


    void (*end_io_handler)(struct buffer_head *, int);
    hashf_t s_hash_function;


    unsigned long s_mount_opt;



    struct {
        unsigned long bits;
        unsigned long large_file_size;
        int border;
        int preallocmin;
        int preallocsize;


    } s_alloc_options;


    wait_queue_head_t s_wait;

    atomic_t s_generation_counter;

    unsigned long s_properties;



    int s_kmallocs;
    int s_disk_reads;
    int s_disk_writes;
    int s_fix_nodes;
    int s_do_balance;
    int s_unneeded_left_neighbor;
    int s_good_search_by_key_reada;
    int s_bmaps;
    int s_bmaps_without_search;
    int s_direct2indirect;
    int s_indirect2direct;



    int s_is_unlinked_ok;
    reiserfs_proc_info_data_t s_proc_info_data;
    struct proc_dir_entry *procdir;
    int reserved_blocks;
};


#define REISERFS_3_5 0
#define REISERFS_3_6 1


#define REISERFS_LARGETAIL 0
#define REISERFS_SMALLTAIL 17
#define REPLAYONLY 3
#define REISERFS_NOLOG 4
#define REISERFS_CONVERT 5
# 441 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/reiserfs_fs_sb.h"
#define FORCE_TEA_HASH 6
#define FORCE_RUPASOV_HASH 7
#define FORCE_R5_HASH 8
#define FORCE_HASH_DETECT 9






#define REISERFS_NO_BORDER 11
#define REISERFS_NO_UNHASHED_RELOCATION 12
#define REISERFS_HASHED_RELOCATION 13
#define REISERFS_TEST4 14

#define REISERFS_TEST1 11
#define REISERFS_TEST2 12
#define REISERFS_TEST3 13
#define REISERFS_TEST4 14

#define REISERFS_ATTRS (15)

#define reiserfs_r5_hash(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_R5_HASH))
#define reiserfs_rupasov_hash(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_RUPASOV_HASH))
#define reiserfs_tea_hash(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_TEA_HASH))
#define reiserfs_hash_detect(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_HASH_DETECT))
#define reiserfs_no_border(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_NO_BORDER))
#define reiserfs_no_unhashed_relocation(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_NO_UNHASHED_RELOCATION))
#define reiserfs_hashed_relocation(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_HASHED_RELOCATION))
#define reiserfs_test4(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_TEST4))

#define have_large_tails(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_LARGETAIL))
#define have_small_tails(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_SMALLTAIL))
#define replay_only(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REPLAYONLY))
#define reiserfs_dont_log(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_NOLOG))
#define reiserfs_attrs(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_ATTRS))
#define old_format_only(s) ((s)->u.reiserfs_sb.s_properties & (1 << REISERFS_3_5))
#define convert_reiserfs(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_CONVERT))


void reiserfs_file_buffer (struct buffer_head * bh, int list);
int reiserfs_is_super(struct super_block *s) ;
int journal_mark_dirty(struct reiserfs_transaction_handle *, struct super_block *, struct buffer_head *bh) ;
int flush_old_commits(struct super_block *s, int) ;
int show_reiserfs_locks(void) ;
int reiserfs_resize(struct super_block *, unsigned long) ;

#define CARRY_ON 0
#define SCHEDULE_OCCURRED 1


#define SB_BUFFER_WITH_SB(s) ((s)->u.reiserfs_sb.s_sbh)
#define SB_JOURNAL(s) ((s)->u.reiserfs_sb.s_journal)
#define SB_JOURNAL_1st_RESERVED_BLOCK(s) (SB_JOURNAL(s)->j_1st_reserved_block)
#define SB_JOURNAL_LIST(s) (SB_JOURNAL(s)->j_journal_list)
#define SB_JOURNAL_LIST_INDEX(s) (SB_JOURNAL(s)->j_journal_list_index)
#define SB_JOURNAL_LEN_FREE(s) (SB_JOURNAL(s)->j_journal_len_free)
#define SB_AP_BITMAP(s) ((s)->u.reiserfs_sb.s_ap_bitmap)

#define SB_DISK_JOURNAL_HEAD(s) (SB_JOURNAL(s)->j_header_bh->)

#define SB_JOURNAL_TRANS_MAX(s) (SB_JOURNAL(s)->s_journal_trans_max)
#define SB_JOURNAL_MAX_BATCH(s) (SB_JOURNAL(s)->s_journal_max_batch)
#define SB_JOURNAL_MAX_COMMIT_AGE(s) (SB_JOURNAL(s)->s_journal_max_commit_age)
#define SB_JOURNAL_MAX_TRANS_AGE(s) (SB_JOURNAL(s)->s_journal_max_trans_age)
#define SB_JOURNAL_DEV(s) (SB_JOURNAL(s)->j_dev)
# 733 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/bfs_fs_sb.h" 1






#define _LINUX_BFS_FS_SB 




struct bfs_sb_info {
        unsigned long si_blocks;
        unsigned long si_freeb;
        unsigned long si_freei;
        unsigned long si_lf_ioff;
        unsigned long si_lf_sblk;
        unsigned long si_lf_eblk;
        unsigned long si_lasti;
        char * si_imap;
        struct buffer_head * si_sbh;
        struct bfs_super_block * si_bfs_sb;
};
# 734 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/udf_fs_sb.h" 1
# 19 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/udf_fs_sb.h"
#define _UDF_FS_SB_H 1

#pragma pack(1)

#define UDF_MAX_BLOCK_LOADED 8

#define UDF_TYPE1_MAP15 0x1511U
#define UDF_VIRTUAL_MAP15 0x1512U
#define UDF_VIRTUAL_MAP20 0x2012U
#define UDF_SPARABLE_MAP15 0x1522U

struct udf_sparing_data
{
        __u16 s_packet_len;
        struct buffer_head *s_spar_map[4];
};

struct udf_virtual_data
{
        __u32 s_num_entries;
        __u16 s_start_offset;
};

struct udf_bitmap
{
        __u32 s_extLength;
        __u32 s_extPosition;
        __u16 s_nr_groups;
        struct buffer_head **s_block_bitmap;
};

struct udf_part_map
{
        union
        {
                struct udf_bitmap *s_bitmap;
                struct inode *s_table;
        } s_uspace;
        union
        {
                struct udf_bitmap *s_bitmap;
                struct inode *s_table;
        } s_fspace;
        __u32 s_partition_root;
        __u32 s_partition_len;
        __u16 s_partition_type;
        __u16 s_partition_num;
        union
        {
                struct udf_sparing_data s_sparing;
                struct udf_virtual_data s_virtual;
        } s_type_specific;
        __u32 (*s_partition_func)(struct super_block *, __u32, __u16, __u32);
        __u16 s_volumeseqnum;
        __u16 s_partition_flags;
};

#pragma pack()

struct udf_sb_info
{
        struct udf_part_map *s_partmaps;
        __u8 s_volident[32];


        __u16 s_partitions;
        __u16 s_partition;


        __s32 s_session;
        __u32 s_anchor[4];
        __u32 s_lastblock;

        struct buffer_head *s_lvidbh;


        mode_t s_umask;
        gid_t s_gid;
        uid_t s_uid;


        time_t s_recordtime;


        __u16 s_serialnum;


        __u16 s_udfrev;


        __u32 s_flags;


        struct nls_table *s_nls_map;


        struct inode *s_vat;
};
# 735 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ncp_fs_sb.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ncp_fs_sb.h"
#define _NCP_FS_SB 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ncp_mount.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ncp_mount.h"
#define _LINUX_NCP_MOUNT_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ncp.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ncp.h"
#define _LINUX_NCP_H 



#define NCP_PTYPE (0x11)
#define NCP_PORT (0x0451)

#define NCP_ALLOC_SLOT_REQUEST (0x1111)
#define NCP_REQUEST (0x2222)
#define NCP_DEALLOC_SLOT_REQUEST (0x5555)

struct ncp_request_header {
        __u16 type;
        __u8 sequence;
        __u8 conn_low;
        __u8 task;
        __u8 conn_high;
        __u8 function;
        __u8 data[0];
} __attribute__((packed));

#define NCP_REPLY (0x3333)
#define NCP_POSITIVE_ACK (0x9999)

struct ncp_reply_header {
        __u16 type;
        __u8 sequence;
        __u8 conn_low;
        __u8 task;
        __u8 conn_high;
        __u8 completion_code;
        __u8 connection_state;
        __u8 data[0];
} __attribute__((packed));

#define NCP_VOLNAME_LEN (16)
#define NCP_NUMBER_OF_VOLUMES (256)
struct ncp_volume_info {
        __u32 total_blocks;
        __u32 free_blocks;
        __u32 purgeable_blocks;
        __u32 not_yet_purgeable_blocks;
        __u32 total_dir_entries;
        __u32 available_dir_entries;
        __u8 sectors_per_block;
        char volume_name[(16) + 1];
};

#define AR_READ (ntohs(0x0100))
#define AR_WRITE (ntohs(0x0200))
#define AR_EXCLUSIVE (ntohs(0x2000))

#define NCP_FILE_ID_LEN 6


#define NW_NS_DOS 0
#define NW_NS_MAC 1
#define NW_NS_NFS 2
#define NW_NS_FTAM 3
#define NW_NS_OS2 4


#define RIM_NAME (ntohl(0x01000000L))
#define RIM_SPACE_ALLOCATED (ntohl(0x02000000L))
#define RIM_ATTRIBUTES (ntohl(0x04000000L))
#define RIM_DATA_SIZE (ntohl(0x08000000L))
#define RIM_TOTAL_SIZE (ntohl(0x10000000L))
#define RIM_EXT_ATTR_INFO (ntohl(0x20000000L))
#define RIM_ARCHIVE (ntohl(0x40000000L))
#define RIM_MODIFY (ntohl(0x80000000L))
#define RIM_CREATION (ntohl(0x00010000L))
#define RIM_OWNING_NAMESPACE (ntohl(0x00020000L))
#define RIM_DIRECTORY (ntohl(0x00040000L))
#define RIM_RIGHTS (ntohl(0x00080000L))
#define RIM_ALL (ntohl(0xFF0F0000L))
#define RIM_COMPRESSED_INFO (ntohl(0x00000080L))


#define OC_MODE_OPEN 0x01
#define OC_MODE_TRUNCATE 0x02
#define OC_MODE_REPLACE 0x02
#define OC_MODE_CREATE 0x08


#define OC_ACTION_NONE 0x00
#define OC_ACTION_OPEN 0x01
#define OC_ACTION_CREATE 0x02
#define OC_ACTION_TRUNCATE 0x04
#define OC_ACTION_REPLACE 0x04



#define AR_READ_ONLY 0x0001
#define AR_WRITE_ONLY 0x0002
#define AR_DENY_READ 0x0004
#define AR_DENY_WRITE 0x0008
#define AR_COMPATIBILITY 0x0010
#define AR_WRITE_THROUGH 0x0040
#define AR_OPEN_COMPRESSED 0x0100


struct nw_info_struct {
        __u32 spaceAlloc;
        __u32 attributes;
        __u16 flags;
        __u32 dataStreamSize;
        __u32 totalStreamSize;
        __u16 numberOfStreams;
        __u16 creationTime;
        __u16 creationDate;
        __u32 creatorID;
        __u16 modifyTime;
        __u16 modifyDate;
        __u32 modifierID;
        __u16 lastAccessDate;
        __u16 archiveTime;
        __u16 archiveDate;
        __u32 archiverID;
        __u16 inheritedRightsMask;
        __u32 dirEntNum;
        __u32 DosDirNum;
        __u32 volNumber;
        __u32 EADataSize;
        __u32 EAKeyCount;
        __u32 EAKeySize;
        __u32 NSCreator;
        __u8 nameLen;
        __u8 entryName[256];
} __attribute__((packed));


#define DM_ATTRIBUTES (ntohl(0x02000000L))
#define DM_CREATE_DATE (ntohl(0x04000000L))
#define DM_CREATE_TIME (ntohl(0x08000000L))
#define DM_CREATOR_ID (ntohl(0x10000000L))
#define DM_ARCHIVE_DATE (ntohl(0x20000000L))
#define DM_ARCHIVE_TIME (ntohl(0x40000000L))
#define DM_ARCHIVER_ID (ntohl(0x80000000L))
#define DM_MODIFY_DATE (ntohl(0x00010000L))
#define DM_MODIFY_TIME (ntohl(0x00020000L))
#define DM_MODIFIER_ID (ntohl(0x00040000L))
#define DM_LAST_ACCESS_DATE (ntohl(0x00080000L))
#define DM_INHERITED_RIGHTS_MASK (ntohl(0x00100000L))
#define DM_MAXIMUM_SPACE (ntohl(0x00200000L))

struct nw_modify_dos_info {
        __u32 attributes;
        __u16 creationDate;
        __u16 creationTime;
        __u32 creatorID;
        __u16 modifyDate;
        __u16 modifyTime;
        __u32 modifierID;
        __u16 archiveDate;
        __u16 archiveTime;
        __u32 archiverID;
        __u16 lastAccessDate;
        __u16 inheritanceGrantMask;
        __u16 inheritanceRevokeMask;
        __u32 maximumSpace;
} __attribute__((packed));

struct nw_search_sequence {
        __u8 volNumber;
        __u32 dirBase;
        __u32 sequence;
} __attribute__((packed));
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ncp_mount.h" 2

#define NCP_MOUNT_VERSION 3


#define NCP_MOUNT_SOFT 0x0001
#define NCP_MOUNT_INTR 0x0002
#define NCP_MOUNT_STRONG 0x0004
#define NCP_MOUNT_NO_OS2 0x0008
#define NCP_MOUNT_NO_NFS 0x0010
#define NCP_MOUNT_EXTRAS 0x0020
#define NCP_MOUNT_SYMLINKS 0x0040

struct ncp_mount_data {
        int version;
        unsigned int ncp_fd;
        __kernel_uid_t mounted_uid;
        __kernel_pid_t wdog_pid;

        unsigned char mounted_vol[(16) + 1];
        unsigned int time_out;

        unsigned int retry_count;
        unsigned int flags;

        __kernel_uid_t uid;
        __kernel_gid_t gid;
        __kernel_mode_t file_mode;
        __kernel_mode_t dir_mode;
};

#define NCP_MOUNT_VERSION_V4 (4)

struct ncp_mount_data_v4 {
        int version;
        unsigned long flags;


        unsigned long mounted_uid;

        long wdog_pid;

        unsigned int ncp_fd;
        unsigned int time_out;

        unsigned int retry_count;



        unsigned long uid;
        unsigned long gid;

        unsigned long file_mode;
        unsigned long dir_mode;
};



struct ncp_mount_data_kernel {
        unsigned long flags;
        unsigned int int_flags;
#define NCP_IMOUNT_LOGGEDIN_POSSIBLE 0x0001
        __kernel_uid32_t mounted_uid;
        __kernel_pid_t wdog_pid;
        unsigned int ncp_fd;
        unsigned int time_out;

        unsigned int retry_count;
        unsigned char mounted_vol[(16) + 1];
        __kernel_uid32_t uid;
        __kernel_gid32_t gid;
        __kernel_mode_t file_mode;
        __kernel_mode_t dir_mode;
};
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ncp_fs_sb.h" 2



#define NCP_DEFAULT_OPTIONS 0

struct ncp_server {

        struct ncp_mount_data_kernel m;



        __u8 name_space[(256) + 2];

        struct file *ncp_filp;

        u8 sequence;
        u8 task;
        u16 connection;

        u8 completion;
        u8 conn_status;



        int buffer_size;

        int reply_size;

        int packet_size;
        unsigned char *packet;


        int lock;
        struct semaphore sem;

        int current_size;
        int has_subfunction;
        int ncp_reply_size;

        int root_setuped;


        int sign_wanted;
        int sign_active;
        char sign_root[8];
        char sign_last[16];


        struct {
                int auth_type;
                size_t object_name_len;
                void* object_name;
                int object_type;
        } auth;

        struct {
                size_t len;
                void* data;
        } priv;


        struct nls_table *nls_vol;
        struct nls_table *nls_io;


        int dentry_ttl;


        unsigned int flags;
};

#define ncp_sb_info ncp_server

#define NCP_FLAG_UTF8 1

#define NCP_CLR_FLAG(server,flag) ((server)->flags &= ~(flag))
#define NCP_SET_FLAG(server,flag) ((server)->flags |= (flag))
#define NCP_IS_FLAG(server,flag) ((server)->flags & (flag))

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int ncp_conn_valid(struct ncp_server *server)
{
        return ((server->conn_status & 0x11) == 0);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void ncp_invalidate_conn(struct ncp_server *server)
{
        server->conn_status |= 0x01;
}
# 736 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/usbdev_fs_sb.h" 1
struct usbdev_sb_info {
        struct list_head slist;
        struct list_head ilist;
        uid_t devuid;
        gid_t devgid;
        umode_t devmode;
        uid_t busuid;
        gid_t busgid;
        umode_t busmode;
        uid_t listuid;
        gid_t listgid;
        umode_t listmode;
};
# 737 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/jffs2_fs_sb.h" 1



#define _JFFS2_FS_SB 



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/completion.h" 1

#define __LINUX_COMPLETION_H 
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/completion.h"
struct completion {
        unsigned int done;
        wait_queue_head_t wait;
};

#define COMPLETION_INITIALIZER(work) { 0, __WAIT_QUEUE_HEAD_INITIALIZER((work).wait) }


#define DECLARE_COMPLETION(work) struct completion work = COMPLETION_INITIALIZER(work)


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void init_completion(struct completion *x)
{
        x->done = 0;
        init_waitqueue_head(&x->wait);
}

extern void wait_for_completion(struct completion *);
extern void complete(struct completion *);

#define INIT_COMPLETION(x) ((x).done = 0)
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/jffs2_fs_sb.h" 2



#define INOCACHE_HASHSIZE 1

#define JFFS2_SB_FLAG_RO 1
#define JFFS2_SB_FLAG_MOUNTING 2





struct jffs2_sb_info {
        struct mtd_info *mtd;

        __u32 highest_ino;
        unsigned int flags;
        spinlock_t nodelist_lock;


        struct task_struct *gc_task;
        struct semaphore gc_thread_start;
        struct completion gc_thread_exit;



        struct semaphore alloc_sem;




        __u32 flash_size;
        __u32 used_size;
        __u32 dirty_size;
        __u32 free_size;
        __u32 erasing_size;
        __u32 bad_size;
        __u32 sector_size;



        __u32 nr_free_blocks;
        __u32 nr_erasing_blocks;

        __u32 nr_blocks;
        struct jffs2_eraseblock *blocks;

        struct jffs2_eraseblock *nextblock;

        struct jffs2_eraseblock *gcblock;

        struct list_head clean_list;
        struct list_head dirty_list;
        struct list_head erasing_list;
        struct list_head erase_pending_list;
        struct list_head erase_complete_list;
        struct list_head free_list;
        struct list_head bad_list;
        struct list_head bad_used_list;

        spinlock_t erase_completion_lock;

        wait_queue_head_t erase_wait;
        struct jffs2_inode_cache *inocache_list[1];
        spinlock_t inocache_lock;
};




#define JFFS2_SB_INFO(sb) (&sb->u.jffs2_sb)


#define OFNI_BS_2SFFJ(c) ((struct super_block *) ( ((char *)c) - ((char *)(&((struct super_block *)NULL)->u)) ) )
# 739 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h" 2

extern struct list_head super_blocks;
extern spinlock_t sb_lock;

#define sb_entry(list) list_entry((list), struct super_block, s_list)
#define S_BIAS (1<<30)
struct super_block {
        struct list_head s_list;
        kdev_t s_dev;
        unsigned long s_blocksize;
        unsigned char s_blocksize_bits;
        unsigned char s_dirt;
        unsigned long long s_maxbytes;
        struct file_system_type *s_type;
        struct super_operations *s_op;
        struct dquot_operations *dq_op;
        struct quotactl_ops *s_qcop;
        unsigned long s_flags;
        unsigned long s_magic;
        struct dentry *s_root;
        struct rw_semaphore s_umount;
        struct semaphore s_lock;
        int s_count;
        atomic_t s_active;

        struct list_head s_dirty;
        struct list_head s_locked_inodes;
        struct list_head s_files;

        struct block_device *s_bdev;
        struct list_head s_instances;
        struct quota_info s_dquot;

        union {
                struct minix_sb_info minix_sb;
                struct ext2_sb_info ext2_sb;
                struct ext3_sb_info ext3_sb;
                struct hpfs_sb_info hpfs_sb;
                struct ntfs_sb_info ntfs_sb;
                struct msdos_sb_info msdos_sb;
                struct isofs_sb_info isofs_sb;
                struct nfs_sb_info nfs_sb;
                struct sysv_sb_info sysv_sb;
                struct affs_sb_info affs_sb;
                struct ufs_sb_info ufs_sb;
                struct efs_sb_info efs_sb;
                struct shmem_sb_info shmem_sb;
                struct romfs_sb_info romfs_sb;
                struct smb_sb_info smbfs_sb;
                struct hfs_sb_info hfs_sb;
                struct adfs_sb_info adfs_sb;
                struct qnx4_sb_info qnx4_sb;
                struct reiserfs_sb_info reiserfs_sb;
                struct bfs_sb_info bfs_sb;
                struct udf_sb_info udf_sb;
                struct ncp_server ncpfs_sb;
                struct usbdev_sb_info usbdevfs_sb;
                struct jffs2_sb_info jffs2_sb;
                struct cramfs_sb_info cramfs_sb;
                void *generic_sbp;
        } u;




        struct semaphore s_vfs_rename_sem;
# 813 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
        struct semaphore s_nfsd_free_path_sem;
};




extern int vfs_create(struct inode *, struct dentry *, int);
extern int vfs_mkdir(struct inode *, struct dentry *, int);
extern int vfs_mknod(struct inode *, struct dentry *, int, dev_t);
extern int vfs_symlink(struct inode *, struct dentry *, const char *);
extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
extern int vfs_rmdir(struct inode *, struct dentry *);
extern int vfs_unlink(struct inode *, struct dentry *);
extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);




#define DT_UNKNOWN 0
#define DT_FIFO 1
#define DT_CHR 2
#define DT_DIR 4
#define DT_BLK 6
#define DT_REG 8
#define DT_LNK 10
#define DT_SOCK 12
#define DT_WHT 14







typedef int (*filldir_t)(void *, const char *, int, loff_t, ino_t, unsigned);

struct block_device_operations {
        int (*open) (struct inode *, struct file *);
        int (*release) (struct inode *, struct file *);
        int (*ioctl) (struct inode *, struct file *, unsigned, unsigned long);
        int (*check_media_change) (kdev_t);
        int (*revalidate) (kdev_t);
        struct module *owner;
};






struct file_operations {
        struct module *owner;
        loff_t (*llseek) (struct file *, loff_t, int);
        ssize_t (*read) (struct file *, char *, size_t, loff_t *);
        ssize_t (*write) (struct file *, const char *, size_t, loff_t *);
        int (*readdir) (struct file *, void *, filldir_t);
        unsigned int (*poll) (struct file *, struct poll_table_struct *);
        int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
        int (*mmap) (struct file *, struct vm_area_struct *);
        int (*open) (struct inode *, struct file *);
        int (*flush) (struct file *);
        int (*release) (struct inode *, struct file *);
        int (*fsync) (struct file *, struct dentry *, int datasync);
        int (*fasync) (int, struct file *, int);
        int (*lock) (struct file *, int, struct file_lock *);
        ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);
        ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);
        ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
        unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
};

struct inode_operations {
        int (*create) (struct inode *,struct dentry *,int);
        struct dentry * (*lookup) (struct inode *,struct dentry *);
        int (*link) (struct dentry *,struct inode *,struct dentry *);
        int (*unlink) (struct inode *,struct dentry *);
        int (*symlink) (struct inode *,struct dentry *,const char *);
        int (*mkdir) (struct inode *,struct dentry *,int);
        int (*rmdir) (struct inode *,struct dentry *);
        int (*mknod) (struct inode *,struct dentry *,int,int);
        int (*rename) (struct inode *, struct dentry *,
                        struct inode *, struct dentry *);
        int (*readlink) (struct dentry *, char *,int);
        int (*follow_link) (struct dentry *, struct nameidata *);
        void (*truncate) (struct inode *);
        int (*permission) (struct inode *, int);
        int (*revalidate) (struct dentry *);
        int (*setattr) (struct dentry *, struct iattr *);
        int (*getattr) (struct dentry *, struct iattr *);
        int (*setxattr) (struct dentry *, const char *, void *, size_t, int);
        ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
        ssize_t (*listxattr) (struct dentry *, char *, size_t);
        int (*removexattr) (struct dentry *, const char *);
};

struct seq_file;





struct super_operations {
        struct inode *(*alloc_inode)(struct super_block *sb);
        void (*destroy_inode)(struct inode *);

        void (*read_inode) (struct inode *);







        void (*read_inode2) (struct inode *, void *) ;
        void (*dirty_inode) (struct inode *);
        void (*write_inode) (struct inode *, int);
        void (*put_inode) (struct inode *);
        void (*delete_inode) (struct inode *);
        void (*put_super) (struct super_block *);
        void (*write_super) (struct super_block *);
        int (*sync_fs) (struct super_block *);
        void (*write_super_lockfs) (struct super_block *);
        void (*unlockfs) (struct super_block *);
        int (*statfs) (struct super_block *, struct statfs *);
        int (*remount_fs) (struct super_block *, int *, char *);
        void (*clear_inode) (struct inode *);
        void (*umount_begin) (struct super_block *);
# 963 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
        struct dentry * (*fh_to_dentry)(struct super_block *sb, __u32 *fh, int len, int fhtype, int parent);
        int (*dentry_to_fh)(struct dentry *, __u32 *fh, int *lenp, int need_parent);
        int (*show_options)(struct seq_file *, struct vfsmount *);
};


#define I_DIRTY_SYNC 1
#define I_DIRTY_DATASYNC 2
#define I_DIRTY_PAGES 4
#define I_LOCK 8
#define I_FREEING 16
#define I_CLEAR 32
#define I_NEW 64

#define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)

extern void __mark_inode_dirty(struct inode *, int);
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void mark_inode_dirty(struct inode *inode)
{
        __mark_inode_dirty(inode, (1 | 2 | 4));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void mark_inode_dirty_sync(struct inode *inode)
{
        __mark_inode_dirty(inode, 1);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void mark_inode_dirty_pages(struct inode *inode)
{
        __mark_inode_dirty(inode, 4);
}

struct file_system_type {
        const char *name;
        int fs_flags;
        struct super_block *(*read_super) (struct super_block *, void *, int);
        struct module *owner;
        struct file_system_type * next;
        struct list_head fs_supers;
};

#define DECLARE_FSTYPE(var,type,read,flags) struct file_system_type var = { name: type, read_super: read, fs_flags: flags, owner: THIS_MODULE, }







#define DECLARE_FSTYPE_DEV(var,type,read) DECLARE_FSTYPE(var,type,read,FS_REQUIRES_DEV)



#define fops_get(fops) (((fops) && (fops)->owner) ? ( try_inc_mod_count((fops)->owner) ? (fops) : NULL ) : (fops))




#define fops_put(fops) do { if ((fops) && (fops)->owner) __MOD_DEC_USE_COUNT((fops)->owner); } while(0)





extern int register_filesystem(struct file_system_type *);
extern int unregister_filesystem(struct file_system_type *);
extern struct vfsmount *kern_mount(struct file_system_type *);
extern int may_umount(struct vfsmount *);
extern long do_mount(char *, char *, char *, unsigned long, void *);

#define kern_umount mntput

extern int vfs_statfs(struct super_block *, struct statfs *);




#define LOCK_USE_CLNT 1

#define FLOCK_VERIFY_READ 1
#define FLOCK_VERIFY_WRITE 2

extern int locks_mandatory_locked(struct inode *);
extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);





#define MANDATORY_LOCK(inode) (IS_MANDLOCK(inode) && ((inode)->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID)


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int locks_verify_locked(struct inode *inode)
{
        if ((((inode)->i_sb->s_flags & (64)) && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
                return locks_mandatory_locked(inode);
        return 0;
}

extern int rw_verify_area(int, struct file *, loff_t *, size_t);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int locks_verify_truncate(struct inode *inode,
                                    struct file *filp,
                                    loff_t size)
{
        if (inode->i_flock && (((inode)->i_sb->s_flags & (64)) && ((inode)->i_mode & (0002000 | 00010)) == 0002000))
                return locks_mandatory_area(
                        2, inode, filp,
                        size < inode->i_size ? size : inode->i_size,
                        (size < inode->i_size ? inode->i_size - size
                         : size - inode->i_size)
                );
        return 0;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int get_lease(struct inode *inode, unsigned int mode)
{
        if (inode->i_flock)
                return __get_lease(inode, mode);
        return 0;
}



 long sys_open(const char *, int, int);
 long sys_close(unsigned int);
extern int do_truncate(struct dentry *, loff_t start);

extern struct file *filp_open(const char *, int, int);
extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
extern int filp_close(struct file *, fl_owner_t id);
extern char * getname(const char *);


extern void vfs_caches_init(unsigned long);

#define __getname() kmem_cache_alloc(names_cachep, SLAB_KERNEL)
#define putname(name) kmem_cache_free(names_cachep, (void *)(name))

enum {BDEV_FILE, BDEV_SWAP, BDEV_FS, BDEV_RAW};
extern int register_blkdev(unsigned int, const char *, struct block_device_operations *);
extern int unregister_blkdev(unsigned int, const char *);
extern struct block_device *bdget(dev_t);
extern int bd_acquire(struct inode *inode);
extern void bd_forget(struct inode *inode);
extern void bdput(struct block_device *);
extern struct char_device *cdget(dev_t);
extern void cdput(struct char_device *);
extern int blkdev_open(struct inode *, struct file *);
extern int blkdev_close(struct inode *, struct file *);
extern struct file_operations def_blk_fops;
extern struct address_space_operations def_blk_aops;
extern struct file_operations def_fifo_fops;
extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
extern int blkdev_get(struct block_device *, mode_t, unsigned, int);
extern int blkdev_put(struct block_device *, int);


extern const struct block_device_operations *get_blkfops(unsigned int);
extern int register_chrdev(unsigned int, const char *, struct file_operations *);
extern int unregister_chrdev(unsigned int, const char *);
extern int chrdev_open(struct inode *, struct file *);
extern const char * bdevname(kdev_t);
extern const char * cdevname(kdev_t);
extern const char * kdevname(kdev_t);
extern void init_special_inode(struct inode *, umode_t, int);


extern void make_bad_inode(struct inode *);
extern int is_bad_inode(struct inode *);

extern struct file_operations read_fifo_fops;
extern struct file_operations write_fifo_fops;
extern struct file_operations rdwr_fifo_fops;
extern struct file_operations read_pipe_fops;
extern struct file_operations write_pipe_fops;
extern struct file_operations rdwr_pipe_fops;

extern int fs_may_remount_ro(struct super_block *);

extern int try_to_free_buffers(struct page *, unsigned int);
extern void refile_buffer(struct buffer_head * buf);
extern void create_empty_buffers(struct page *, kdev_t, unsigned long);
extern void end_buffer_io_sync(struct buffer_head *bh, int uptodate);
extern void end_buffer_io_async(struct buffer_head *bh, int uptodate);


extern void set_buffer_async_io(struct buffer_head *bh) ;

#define BUF_CLEAN 0
#define BUF_LOCKED 1
#define BUF_DIRTY 2
#define NR_LIST 3

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void get_bh(struct buffer_head * bh)
{
        atomic_add(1,(&(bh)->b_count));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void put_bh(struct buffer_head *bh)
{
        __asm__ __volatile__("": : :"memory");
        atomic_sub(1,(&bh->b_count));
}




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void mark_buffer_uptodate(struct buffer_head * bh, int on)
{
        if (on)
                set_bit(BH_Uptodate, &bh->b_state);
        else
                clear_bit(BH_Uptodate, &bh->b_state);
}

#define atomic_set_buffer_clean(bh) test_and_clear_bit(BH_Dirty, &(bh)->b_state)

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __mark_buffer_clean(struct buffer_head *bh)
{
        refile_buffer(bh);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void mark_buffer_clean(struct buffer_head * bh)
{
        if (test_and_clear_bit(BH_Dirty, &(bh)->b_state))
                __mark_buffer_clean(bh);
}

extern void __mark_dirty(struct buffer_head *bh);
extern void __mark_buffer_dirty(struct buffer_head *bh);
extern void mark_buffer_dirty(struct buffer_head *bh);

extern void buffer_insert_list(struct buffer_head *, struct list_head *);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void buffer_insert_inode_queue(struct buffer_head *bh, struct inode *inode)
{
        buffer_insert_list(bh, &inode->i_dirty_buffers);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void buffer_insert_inode_data_queue(struct buffer_head *bh, struct inode *inode)
{
        buffer_insert_list(bh, &inode->i_dirty_data_buffers);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int atomic_set_buffer_dirty(struct buffer_head *bh)
{
        return test_and_set_bit(BH_Dirty, &bh->b_state);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void mark_buffer_async(struct buffer_head * bh, int on)
{
        if (on)
                set_bit(BH_Async, &bh->b_state);
        else
                clear_bit(BH_Async, &bh->b_state);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void set_buffer_attached(struct buffer_head *bh)
{
        set_bit(BH_Attached, &bh->b_state);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void clear_buffer_attached(struct buffer_head *bh)
{
        clear_bit(BH_Attached, &bh->b_state);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int buffer_attached(struct buffer_head *bh)
{
        return test_bit(BH_Attached, &bh->b_state);
}







static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void buffer_IO_error(struct buffer_head * bh)
{
        mark_buffer_clean(bh);



        bh->b_end_io(bh, 0);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)
{
        mark_buffer_dirty(bh);
        buffer_insert_inode_queue(bh, inode);
}

extern void set_buffer_flushtime(struct buffer_head *);
extern int get_buffer_flushtime(void);
extern void balance_dirty(void);
extern int check_disk_change(kdev_t);
extern int invalidate_inodes(struct super_block *);
extern int invalidate_device(kdev_t, int);
extern void invalidate_inode_pages(struct inode *);
extern void invalidate_inode_pages2(struct address_space *);
extern void invalidate_inode_buffers(struct inode *);
#define invalidate_buffers(dev) __invalidate_buffers((dev), 0)
#define destroy_buffers(dev) __invalidate_buffers((dev), 1)
extern void invalidate_bdev(struct block_device *, int);
extern void __invalidate_buffers(kdev_t dev, int);
extern void sync_inodes(kdev_t);
extern void sync_unlocked_inodes(void);
extern void write_inode_now(struct inode *, int);
extern int sync_buffers(kdev_t, int);
extern void sync_dev(kdev_t);
extern int fsync_dev(kdev_t);
extern int fsync_super(struct super_block *);
extern int fsync_no_super(kdev_t);
extern void sync_inodes_sb(struct super_block *);
extern int fsync_buffers_list(struct list_head *);
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int fsync_inode_buffers(struct inode *inode)
{
        return fsync_buffers_list(&inode->i_dirty_buffers);
}
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int fsync_inode_data_buffers(struct inode *inode)
{
        return fsync_buffers_list(&inode->i_dirty_data_buffers);
}
extern int inode_has_buffers(struct inode *);
extern int do_fdatasync(struct file *);
extern int filemap_fdatawrite(struct address_space *);
extern int filemap_fdatasync(struct address_space *);
extern int filemap_fdatawait(struct address_space *);
extern void sync_supers(kdev_t dev, int wait);
extern int bmap(struct inode *, int);
extern int notify_change(struct dentry *, struct iattr *);
extern int permission(struct inode *, int);
extern int vfs_permission(struct inode *, int);
extern int get_write_access(struct inode *);
extern int deny_write_access(struct file *);
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void put_write_access(struct inode * inode)
{
        atomic_sub(1,(&inode->i_writecount));
}
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void allow_write_access(struct file *file)
{
        if (file)
                atomic_add(1,(&file->f_dentry->d_inode->i_writecount));
}
extern int do_pipe(int *);

extern int open_namei(const char *, int, int, struct nameidata *);

extern int kernel_read(struct file *, unsigned long, char *, unsigned long);
extern struct file * open_exec(const char *);


extern int is_subdir(struct dentry *, struct dentry *);
extern ino_t find_inode_number(struct dentry *, struct qstr *);
# 1328 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void *ERR_PTR(long error)
{
        return (void *) error;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) long PTR_ERR(const void *ptr)
{
        return (long) ptr;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) long IS_ERR(const void *ptr)
{
        return (unsigned long)ptr > (unsigned long)-1000L;
}
# 1350 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
#define LOOKUP_FOLLOW (1)
#define LOOKUP_DIRECTORY (2)
#define LOOKUP_CONTINUE (4)
#define LOOKUP_POSITIVE (8)
#define LOOKUP_PARENT (16)
#define LOOKUP_NOALT (32)



enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
# 1370 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
typedef struct {
        size_t written;
        size_t count;
        char * buf;
        int error;
} read_descriptor_t;

typedef int (*read_actor_t)(read_descriptor_t *, struct page *, unsigned long, unsigned long);


extern loff_t default_llseek(struct file *file, loff_t offset, int origin);

extern int __user_walk(const char *, unsigned, struct nameidata *);
extern int path_init(const char *, unsigned, struct nameidata *);
extern int path_walk(const char *, struct nameidata *);
extern int path_lookup(const char *, unsigned, struct nameidata *);
extern int link_path_walk(const char *, struct nameidata *);
extern void path_release(struct nameidata *);
extern int follow_down(struct vfsmount **, struct dentry **);
extern int follow_up(struct vfsmount **, struct dentry **);
extern struct dentry * lookup_one_len(const char *, struct dentry *, int);
extern struct dentry * lookup_hash(struct qstr *, struct dentry *);
#define user_path_walk(name,nd) __user_walk(name, LOOKUP_FOLLOW|LOOKUP_POSITIVE, nd)
#define user_path_walk_link(name,nd) __user_walk(name, LOOKUP_POSITIVE, nd)

extern void inode_init_once(struct inode *);
extern void __inode_init_once(struct inode *);
extern void iput(struct inode *);
extern void refile_inode(struct inode *inode);
extern void force_delete(struct inode *);
extern struct inode * igrab(struct inode *);
extern struct inode * ilookup(struct super_block *, unsigned long);
extern ino_t iunique(struct super_block *, ino_t);
extern void unlock_new_inode(struct inode *);

typedef int (*find_inode_t)(struct inode *, unsigned long, void *);

extern struct inode * iget4_locked(struct super_block *, unsigned long,
                                   find_inode_t, void *);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct inode *iget4(struct super_block *sb, unsigned long ino,
                                  find_inode_t find_actor, void *opaque)
{
        struct inode *inode = iget4_locked(sb, ino, find_actor, opaque);

        if (inode && (inode->i_state & 64)) {



                if (sb->s_op->read_inode2)
                        sb->s_op->read_inode2(inode, opaque);
                else
                        sb->s_op->read_inode(inode);
                unlock_new_inode(inode);
        }

        return inode;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct inode *iget(struct super_block *sb, unsigned long ino)
{
        struct inode *inode = iget4_locked(sb, ino, ((void *)0), ((void *)0));

        if (inode && (inode->i_state & 64)) {
                sb->s_op->read_inode(inode);
                unlock_new_inode(inode);
        }

        return inode;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct inode *iget_locked(struct super_block *sb, unsigned long ino)
{
        return iget4_locked(sb, ino, ((void *)0), ((void *)0));
}

extern void clear_inode(struct inode *);
extern struct inode *new_inode(struct super_block *sb);
extern void remove_suid(struct inode *inode);

extern void insert_inode_hash(struct inode *);
extern void remove_inode_hash(struct inode *);
extern struct file * get_empty_filp(void);
extern void file_move(struct file *f, struct list_head *list);
extern struct buffer_head * get_hash_table(kdev_t, int, int);
extern struct buffer_head * getblk(kdev_t, int, int);
extern void ll_rw_block(int, int, struct buffer_head * bh[]);
extern void submit_bh(int, struct buffer_head *);
extern int is_read_only(kdev_t);
extern void __brelse(struct buffer_head *);
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void brelse(struct buffer_head *buf)
{
        if (buf)
                __brelse(buf);
}
extern void __bforget(struct buffer_head *);
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void bforget(struct buffer_head *buf)
{
        if (buf)
                __bforget(buf);
}
extern int set_blocksize(kdev_t, int);
extern int sb_set_blocksize(struct super_block *, int);
extern int sb_min_blocksize(struct super_block *, int);
extern struct buffer_head * bread(kdev_t, int, int);
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct buffer_head * sb_bread(struct super_block *sb, int block)
{
        return bread(sb->s_dev, block, sb->s_blocksize);
}
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct buffer_head * sb_getblk(struct super_block *sb, int block)
{
        return getblk(sb->s_dev, block, sb->s_blocksize);
}
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct buffer_head * sb_get_hash_table(struct super_block *sb, int block)
{
        return get_hash_table(sb->s_dev, block, sb->s_blocksize);
}
extern void wakeup_bdflush(void);
extern void wakeup_kupdate(void);
extern void put_unused_buffer_head(struct buffer_head * bh);
extern struct buffer_head * get_unused_buffer_head(int async);
extern int block_dump;

extern int brw_page(int, struct page *, kdev_t, int [], int);

typedef int (get_block_t)(struct inode*,long,struct buffer_head*,int);


extern int try_to_release_page(struct page * page, int gfp_mask);
extern int discard_bh_page(struct page *, unsigned long, int);
#define block_flushpage(page,offset) discard_bh_page(page, offset, 1)
#define block_invalidate_page(page) discard_bh_page(page, 0, 0)
extern int __block_symlink(struct inode *, const char *, int, unsigned int);
extern int block_symlink(struct inode *, const char *, int);
extern int block_write_full_page(struct page*, get_block_t*);
extern int block_read_full_page(struct page*, get_block_t*);
extern int block_prepare_write(struct page*, unsigned, unsigned, get_block_t*);
extern int cont_prepare_write(struct page*, unsigned, unsigned, get_block_t*,
                                unsigned long *);
extern int generic_cont_expand(struct inode *inode, loff_t size) ;
extern int block_commit_write(struct page *page, unsigned from, unsigned to);
extern int block_sync_page(struct page *);

int generic_block_bmap(struct address_space *, long, get_block_t *);
int generic_commit_write(struct file *, struct page *, unsigned, unsigned);
int block_truncate_page(struct address_space *, loff_t, get_block_t *);
extern int generic_direct_IO(int, struct inode *, struct kiobuf *, unsigned long, int, get_block_t *);
extern int waitfor_one_page(struct page *);
extern int writeout_one_page(struct page *);

extern int generic_file_mmap(struct file *, struct vm_area_struct *);
extern int file_read_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
extern ssize_t generic_file_read(struct file *, char *, size_t, loff_t *);
extern ssize_t do_generic_direct_read(struct file *, char *, size_t, loff_t *);
extern int precheck_file_write(struct file *, struct inode *, size_t *, loff_t *);
extern ssize_t generic_file_write(struct file *, const char *, size_t, loff_t *);
extern void do_generic_file_read(struct file *, loff_t *, read_descriptor_t *, read_actor_t);
extern ssize_t do_generic_file_write(struct file *, const char *, size_t, loff_t *);
extern ssize_t do_generic_direct_write(struct file *, const char *, size_t, loff_t *);
extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
extern ssize_t generic_read_dir(struct file *, char *, size_t, loff_t *);
extern int generic_file_open(struct inode * inode, struct file * filp);

extern struct file_operations generic_ro_fops;

extern int vfs_readlink(struct dentry *, char *, int, const char *);
extern int vfs_follow_link(struct nameidata *, const char *);
extern int page_readlink(struct dentry *, char *, int);
extern int page_follow_link(struct dentry *, struct nameidata *);
extern struct inode_operations page_symlink_inode_operations;

extern int vfs_readdir(struct file *, filldir_t, void *);
extern int dcache_dir_open(struct inode *, struct file *);
extern int dcache_dir_close(struct inode *, struct file *);
extern loff_t dcache_dir_lseek(struct file *, loff_t, int);
extern int dcache_dir_fsync(struct file *, struct dentry *, int);
extern int dcache_readdir(struct file *, void *, filldir_t);
extern struct file_operations dcache_dir_ops;

extern struct file_system_type *get_fs_type(const char *name);
extern struct super_block *get_super(kdev_t);
extern void drop_super(struct super_block *sb);
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int is_mounted(kdev_t dev)
{
        struct super_block *sb = get_super(dev);
        if (sb) {
                drop_super(sb);
                return 1;
        }
        return 0;
}
unsigned long generate_cluster(kdev_t, int b[], int);
unsigned long generate_cluster_swab32(kdev_t, int b[], int);
extern kdev_t ROOT_DEV;


extern void show_buffers(void);





extern ssize_t char_read(struct file *, char *, size_t, loff_t *);
extern ssize_t block_read(struct file *, char *, size_t, loff_t *);
extern int read_ahead[];

extern ssize_t char_write(struct file *, const char *, size_t, loff_t *);
extern ssize_t block_write(struct file *, const char *, size_t, loff_t *);

extern int file_fsync(struct file *, struct dentry *, int);
extern int generic_buffer_fdatasync(struct inode *inode, unsigned long start_idx, unsigned long end_idx);
extern int generic_osync_inode(struct inode *, int);
#define OSYNC_METADATA (1<<0)
#define OSYNC_DATA (1<<1)
#define OSYNC_INODE (1<<2)

extern int inode_change_ok(struct inode *, struct iattr *);
extern int inode_setattr(struct inode *, struct iattr *);


extern int unshare_files(void);
# 1612 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct dentry *lock_parent(struct dentry *dentry)
{
        struct dentry *dir = dget(dentry->d_parent);

        down(&dir->d_inode->i_sem);
        return dir;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct dentry *get_parent(struct dentry *dentry)
{
        return dget(dentry->d_parent);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void unlock_dir(struct dentry *dir)
{
        up(&dir->d_inode->i_sem);
        dput(dir);
}





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void double_down(struct semaphore *s1, struct semaphore *s2)
{
        if (s1 != s2) {
                if ((unsigned long) s1 < (unsigned long) s2) {
                        struct semaphore *tmp = s2;
                        s2 = s1; s1 = tmp;
                }
                down(s1);
        }
        down(s2);
}
# 1656 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void triple_down(struct semaphore *s1,
                               struct semaphore *s2,
                               struct semaphore *s3)
{
        if (s1 != s2) {
                if ((unsigned long) s1 < (unsigned long) s2) {
                        if ((unsigned long) s1 < (unsigned long) s3) {
                                struct semaphore *tmp = s3;
                                s3 = s1; s1 = tmp;
                        }
                        if ((unsigned long) s1 < (unsigned long) s2) {
                                struct semaphore *tmp = s2;
                                s2 = s1; s1 = tmp;
                        }
                } else {
                        if ((unsigned long) s1 < (unsigned long) s3) {
                                struct semaphore *tmp = s3;
                                s3 = s1; s1 = tmp;
                        }
                        if ((unsigned long) s2 < (unsigned long) s3) {
                                struct semaphore *tmp = s3;
                                s3 = s2; s2 = tmp;
                        }
                }
                down(s1);
        } else if ((unsigned long) s2 < (unsigned long) s3) {
                struct semaphore *tmp = s3;
                s3 = s2; s2 = tmp;
        }
        down(s2);
        down(s3);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void double_up(struct semaphore *s1, struct semaphore *s2)
{
        up(s1);
        if (s1 != s2)
                up(s2);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void triple_up(struct semaphore *s1,
                             struct semaphore *s2,
                             struct semaphore *s3)
{
        up(s1);
        if (s1 != s2)
                up(s2);
        up(s3);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void double_lock(struct dentry *d1, struct dentry *d2)
{
        double_down(&d1->d_inode->i_sem, &d2->d_inode->i_sem);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void double_unlock(struct dentry *d1, struct dentry *d2)
{
        double_up(&d1->d_inode->i_sem,&d2->d_inode->i_sem);
        dput(d1);
        dput(d2);
}
# 18 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h" 2
# 30 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h"
#define _LINUX_CAPABILITY_VERSION 0x19980330

typedef struct __user_cap_header_struct {
        __u32 version;
        int pid;
} *cap_user_header_t;

typedef struct __user_cap_data_struct {
        __u32 effective;
        __u32 permitted;
        __u32 inheritable;
} *cap_user_data_t;
# 55 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h"
typedef __u32 kernel_cap_t;



#define _USER_CAP_HEADER_SIZE (2*sizeof(__u32))
#define _KERNEL_CAP_T_SIZE (sizeof(kernel_cap_t))
# 73 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h"
#define CAP_CHOWN 0





#define CAP_DAC_OVERRIDE 1





#define CAP_DAC_READ_SEARCH 2





#define CAP_FOWNER 3
# 100 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h"
#define CAP_FSETID 4





#define CAP_KILL 5





#define CAP_SETGID 6




#define CAP_SETUID 7
# 127 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h"
#define CAP_SETPCAP 8



#define CAP_LINUX_IMMUTABLE 9




#define CAP_NET_BIND_SERVICE 10



#define CAP_NET_BROADCAST 11
# 156 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h"
#define CAP_NET_ADMIN 12




#define CAP_NET_RAW 13





#define CAP_IPC_LOCK 14



#define CAP_IPC_OWNER 15



#define CAP_SYS_MODULE 16




#define CAP_SYS_RAWIO 17



#define CAP_SYS_CHROOT 18



#define CAP_SYS_PTRACE 19



#define CAP_SYS_PACCT 20
# 231 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h"
#define CAP_SYS_ADMIN 21



#define CAP_SYS_BOOT 22







#define CAP_SYS_NICE 23
# 257 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h"
#define CAP_SYS_RESOURCE 24





#define CAP_SYS_TIME 25




#define CAP_SYS_TTY_CONFIG 26



#define CAP_MKNOD 27



#define CAP_LEASE 28





extern kernel_cap_t cap_bset;
# 295 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/capability.h"
#define to_cap_t(x) (x)
#define cap_t(x) (x)





#define CAP_FS_MASK (CAP_TO_MASK(CAP_CHOWN) | CAP_TO_MASK(CAP_DAC_OVERRIDE) | CAP_TO_MASK(CAP_DAC_READ_SEARCH) | CAP_TO_MASK(CAP_FOWNER) | CAP_TO_MASK(CAP_FSETID) | CAP_TO_MASK(CAP_LINUX_IMMUTABLE) | CAP_TO_MASK(CAP_MKNOD))







#define CAP_EMPTY_SET to_cap_t(0)
#define CAP_FULL_SET to_cap_t(~0)
#define CAP_INIT_EFF_SET to_cap_t(~0 & ~CAP_TO_MASK(CAP_SETPCAP))
#define CAP_INIT_INH_SET to_cap_t(0)

#define CAP_TO_MASK(x) (1 << (x))
#define cap_raise(c,flag) (cap_t(c) |= CAP_TO_MASK(flag))
#define cap_lower(c,flag) (cap_t(c) &= ~CAP_TO_MASK(flag))
#define cap_raised(c,flag) (cap_t(c) & CAP_TO_MASK(flag))

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) kernel_cap_t cap_combine(kernel_cap_t a, kernel_cap_t b)
{
     kernel_cap_t dest;
     (dest) = (a) | (b);
     return dest;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) kernel_cap_t cap_intersect(kernel_cap_t a, kernel_cap_t b)
{
     kernel_cap_t dest;
     (dest) = (a) & (b);
     return dest;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) kernel_cap_t cap_drop(kernel_cap_t a, kernel_cap_t drop)
{
     kernel_cap_t dest;
     (dest) = (a) & ~(drop);
     return dest;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) kernel_cap_t cap_invert(kernel_cap_t c)
{
     kernel_cap_t dest;
     (dest) = ~(c);
     return dest;
}

#define cap_isclear(c) (!cap_t(c))
#define cap_issubset(a,set) (!(cap_t(a) & ~cap_t(set)))

#define cap_clear(c) do { cap_t(c) = 0; } while(0)
#define cap_set_full(c) do { cap_t(c) = ~0; } while(0)
#define cap_mask(c,mask) do { cap_t(c) &= cap_t(mask); } while(0)

#define cap_is_fs_cap(c) (CAP_TO_MASK(c) & CAP_FS_MASK)
# 6 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/binfmts.h" 2






#define MAX_ARG_PAGES 32


#define BINPRM_BUF_SIZE 128






struct linux_binprm{
        char buf[128];
        struct page *page[32];
        unsigned long p;
        int sh_bang;
        struct file * file;
        int e_uid, e_gid;
        kernel_cap_t cap_inheritable, cap_permitted, cap_effective;
        int argc, envc;
        char * filename;
        unsigned long loader, exec;
};





struct linux_binfmt {
        struct linux_binfmt * next;
        struct module *module;
        int (*load_binary)(struct linux_binprm *, struct pt_regs * regs);
        int (*load_shlib)(struct file *);
        int (*core_dump)(long signr, struct pt_regs * regs, struct file * file);
        unsigned long min_coredump;
};

extern int register_binfmt(struct linux_binfmt *);
extern int unregister_binfmt(struct linux_binfmt *);

extern int prepare_binprm(struct linux_binprm *);
extern void remove_arg_zero(struct linux_binprm *);
extern int search_binary_handler(struct linux_binprm *,struct pt_regs *);
extern int flush_old_exec(struct linux_binprm * bprm);
extern int setup_arg_pages(struct linux_binprm * bprm);
extern int copy_strings(int argc,char ** argv,struct linux_binprm *bprm);
extern int copy_strings_kernel(int argc,char ** argv,struct linux_binprm *bprm);
extern void compute_creds(struct linux_binprm *binprm);
extern int do_coredump(long signr, struct pt_regs * regs);
extern void set_binfmt(struct linux_binfmt *new);
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/times.h" 1

#define _LINUX_TIMES_H 

struct tms {
        clock_t tms_utime;
        clock_t tms_stime;
        clock_t tms_cutime;
        clock_t tms_cstime;
};
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/timex.h" 1
# 52 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/timex.h"
#define _LINUX_TIMEX_H 
# 70 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/timex.h"
#define SHIFT_HZ 7
# 92 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/timex.h"
#define SHIFT_KG 6
#define SHIFT_KF 16
#define SHIFT_KH 2
#define MAXTC 6
# 111 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/timex.h"
#define SHIFT_SCALE 22
#define SHIFT_UPDATE (SHIFT_KG + MAXTC)
#define SHIFT_USEC 16
#define FINEUSEC (1L << SHIFT_SCALE)

#define MAXPHASE 512000L
#define MAXFREQ (512L << SHIFT_USEC)
#define MAXTIME (200L << PPS_AVG)
#define MINSEC 16L
#define MAXSEC 1200L
#define NTP_PHASE_LIMIT (MAXPHASE << 5)
# 143 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/timex.h"
#define PPS_AVG 2
#define PPS_SHIFT 2
#define PPS_SHIFTMAX 8
#define PPS_VALID 120
#define MAXGLITCH 30




# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/timex.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/timex.h"
#define _ASM_TIMEX_H 
# 26 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/timex.h"
typedef unsigned int cycles_t;
extern cycles_t cacheflush_time;

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) cycles_t get_cycles (void)
{
        return ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$9" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$9" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; });
}

#define vxtime_lock() do {} while (0)
#define vxtime_unlock() do {} while (0)
# 153 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/timex.h" 2


#define LATCH ((CLOCK_TICK_RATE + HZ/2) / HZ)





struct timex {
        unsigned int modes;
        long offset;
        long freq;
        long maxerror;
        long esterror;
        int status;
        long constant;
        long precision;
        long tolerance;


        struct timeval time;
        long tick;

        long ppsfreq;
        long jitter;
        int shift;
        long stabil;
        long jitcnt;
        long calcnt;
        long errcnt;
        long stbcnt;

        int :32; int :32; int :32; int :32;
        int :32; int :32; int :32; int :32;
        int :32; int :32; int :32; int :32;
};




#define ADJ_OFFSET 0x0001
#define ADJ_FREQUENCY 0x0002
#define ADJ_MAXERROR 0x0004
#define ADJ_ESTERROR 0x0008
#define ADJ_STATUS 0x0010
#define ADJ_TIMECONST 0x0020
#define ADJ_TICK 0x4000
#define ADJ_OFFSET_SINGLESHOT 0x8001


#define MOD_OFFSET ADJ_OFFSET
#define MOD_FREQUENCY ADJ_FREQUENCY
#define MOD_MAXERROR ADJ_MAXERROR
#define MOD_ESTERROR ADJ_ESTERROR
#define MOD_STATUS ADJ_STATUS
#define MOD_TIMECONST ADJ_TIMECONST
#define MOD_CLKB ADJ_TICK
#define MOD_CLKA ADJ_OFFSET_SINGLESHOT





#define STA_PLL 0x0001
#define STA_PPSFREQ 0x0002
#define STA_PPSTIME 0x0004
#define STA_FLL 0x0008

#define STA_INS 0x0010
#define STA_DEL 0x0020
#define STA_UNSYNC 0x0040
#define STA_FREQHOLD 0x0080

#define STA_PPSSIGNAL 0x0100
#define STA_PPSJITTER 0x0200
#define STA_PPSWANDER 0x0400
#define STA_PPSERROR 0x0800

#define STA_CLOCKERR 0x1000

#define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR | STA_CLOCKERR)





#define TIME_OK 0
#define TIME_INS 1
#define TIME_DEL 2
#define TIME_OOP 3
#define TIME_WAIT 4
#define TIME_ERROR 5
#define TIME_BAD TIME_ERROR







extern long tick;
extern int tickadj;




extern int time_state;
extern int time_status;
extern long time_offset;
extern long time_constant;
extern long time_tolerance;
extern long time_precision;
extern long time_maxerror;
extern long time_esterror;

extern long time_phase;
extern long time_freq;
extern long time_adj;
extern long time_reftime;

extern long time_adjust;


extern long pps_offset;
extern long pps_jitter;
extern long pps_freq;
extern long pps_stabil;
extern long pps_valid;


extern int pps_shift;
extern long pps_jitcnt;
extern long pps_calcnt;
extern long pps_errcnt;
extern long pps_stbcnt;
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/rbtree.h" 1
# 95 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/rbtree.h"
#define _LINUX_RBTREE_H 




typedef struct rb_node_s
{
        struct rb_node_s * rb_parent;
        int rb_color;
#define RB_RED 0
#define RB_BLACK 1
        struct rb_node_s * rb_right;
        struct rb_node_s * rb_left;
}
rb_node_t;

typedef struct rb_root_s
{
        struct rb_node_s * rb_node;
}
rb_root_t;

#define RB_ROOT (rb_root_t) { NULL, }
#define rb_entry(ptr,type,member) ((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))


extern void rb_insert_color(rb_node_t *, rb_root_t *);
extern void rb_erase(rb_node_t *, rb_root_t *);


extern rb_node_t *rb_next(rb_node_t *);
extern rb_node_t *rb_prev(rb_node_t *);
extern rb_node_t *rb_first(rb_root_t *);
extern rb_node_t *rb_last(rb_root_t *);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void rb_link_node(rb_node_t * node, rb_node_t * parent, rb_node_t ** rb_link)
{
        node->rb_parent = parent;
        node->rb_color = 0;
        node->rb_left = node->rb_right = ((void *)0);

        *rb_link = node;
}
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2





# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/mmu.h" 1

#define __ASM_MMU_H 

typedef unsigned long mm_context_t[1];
# 22 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty.h" 1

#define _LINUX_TTY_H 
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty.h"
#define MIN_NR_CONSOLES 1
#define MAX_NR_CONSOLES 63
#define MAX_NR_USER_CONSOLES 63






# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/major.h" 1

#define _LINUX_MAJOR_H 
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/major.h"
#define MAX_CHRDEV 255
#define MAX_BLKDEV 255

#define UNNAMED_MAJOR 0
#define MEM_MAJOR 1
#define RAMDISK_MAJOR 1
#define FLOPPY_MAJOR 2
#define PTY_MASTER_MAJOR 2
#define IDE0_MAJOR 3
#define PTY_SLAVE_MAJOR 3
#define HD_MAJOR IDE0_MAJOR
#define TTY_MAJOR 4
#define TTYAUX_MAJOR 5
#define LP_MAJOR 6
#define VCS_MAJOR 7
#define LOOP_MAJOR 7
#define SCSI_DISK0_MAJOR 8
#define SCSI_TAPE_MAJOR 9
#define MD_MAJOR 9
#define MISC_MAJOR 10
#define SCSI_CDROM_MAJOR 11
#define MUX_MAJOR 11
#define QIC02_TAPE_MAJOR 12
#define XT_DISK_MAJOR 13
#define SOUND_MAJOR 14
#define CDU31A_CDROM_MAJOR 15
#define JOYSTICK_MAJOR 15
#define GOLDSTAR_CDROM_MAJOR 16
#define OPTICS_CDROM_MAJOR 17
#define SANYO_CDROM_MAJOR 18
#define CYCLADES_MAJOR 19
#define CYCLADESAUX_MAJOR 20
#define MITSUMI_X_CDROM_MAJOR 20
#define MFM_ACORN_MAJOR 21
#define SCSI_GENERIC_MAJOR 21
#define Z8530_MAJOR 34
#define DIGI_MAJOR 23
#define IDE1_MAJOR 22
#define DIGICU_MAJOR 22
#define MITSUMI_CDROM_MAJOR 23
#define CDU535_CDROM_MAJOR 24
#define STL_SERIALMAJOR 24
#define MATSUSHITA_CDROM_MAJOR 25
#define STL_CALLOUTMAJOR 25
#define MATSUSHITA_CDROM2_MAJOR 26
#define QIC117_TAPE_MAJOR 27
#define MATSUSHITA_CDROM3_MAJOR 27
#define MATSUSHITA_CDROM4_MAJOR 28
#define STL_SIOMEMMAJOR 28
#define ACSI_MAJOR 28
#define AZTECH_CDROM_MAJOR 29
#define GRAPHDEV_MAJOR 29
#define SHMIQ_MAJOR 85
#define CM206_CDROM_MAJOR 32
#define IDE2_MAJOR 33
#define IDE3_MAJOR 34
#define XPRAM_MAJOR 35

#define NETLINK_MAJOR 36
#define PS2ESDI_MAJOR 36
#define IDETAPE_MAJOR 37
#define Z2RAM_MAJOR 37
#define APBLOCK_MAJOR 38
#define DDV_MAJOR 39
#define NBD_MAJOR 43
#define RISCOM8_NORMAL_MAJOR 48
#define DAC960_MAJOR 48
#define RISCOM8_CALLOUT_MAJOR 49
#define MKISS_MAJOR 55
#define DSP56K_MAJOR 55

#define IDE4_MAJOR 56
#define IDE5_MAJOR 57

#define LVM_BLK_MAJOR 58

#define SCSI_DISK1_MAJOR 65
#define SCSI_DISK2_MAJOR 66
#define SCSI_DISK3_MAJOR 67
#define SCSI_DISK4_MAJOR 68
#define SCSI_DISK5_MAJOR 69
#define SCSI_DISK6_MAJOR 70
#define SCSI_DISK7_MAJOR 71


#define COMPAQ_SMART2_MAJOR 72
#define COMPAQ_SMART2_MAJOR1 73
#define COMPAQ_SMART2_MAJOR2 74
#define COMPAQ_SMART2_MAJOR3 75
#define COMPAQ_SMART2_MAJOR4 76
#define COMPAQ_SMART2_MAJOR5 77
#define COMPAQ_SMART2_MAJOR6 78
#define COMPAQ_SMART2_MAJOR7 79

#define SPECIALIX_NORMAL_MAJOR 75
#define SPECIALIX_CALLOUT_MAJOR 76

#define COMPAQ_CISS_MAJOR 104
#define COMPAQ_CISS_MAJOR1 105
#define COMPAQ_CISS_MAJOR2 106
#define COMPAQ_CISS_MAJOR3 107
#define COMPAQ_CISS_MAJOR4 108
#define COMPAQ_CISS_MAJOR5 109
#define COMPAQ_CISS_MAJOR6 110
#define COMPAQ_CISS_MAJOR7 111

#define ATARAID_MAJOR 114

#define DASD_MAJOR 94

#define MDISK_MAJOR 95

#define I2O_MAJOR 80

#define IDE6_MAJOR 88
#define IDE7_MAJOR 89
#define IDE8_MAJOR 90
#define IDE9_MAJOR 91

#define UBD_MAJOR 98

#define AURORA_MAJOR 79

#define JSFD_MAJOR 99

#define PHONE_MAJOR 100

#define LVM_CHAR_MAJOR 109

#define UMEM_MAJOR 116

#define RTF_MAJOR 150
#define RAW_MAJOR 162

#define USB_ACM_MAJOR 166
#define USB_ACM_AUX_MAJOR 167
#define USB_CHAR_MAJOR 180

#define UNIX98_PTY_MASTER_MAJOR 128
#define UNIX98_PTY_MAJOR_COUNT 8
#define UNIX98_PTY_SLAVE_MAJOR (UNIX98_PTY_MASTER_MAJOR+UNIX98_PTY_MAJOR_COUNT)

#define VXVM_MAJOR 199
#define VXSPEC_MAJOR 200
#define VXDMP_MAJOR 201

#define MSR_MAJOR 202
#define CPUID_MAJOR 203

#define OSST_MAJOR 206

#define IBM_TTY3270_MAJOR 227
#define IBM_FS3270_MAJOR 228





#define SCSI_DISK_MAJOR(M) ((M) == SCSI_DISK0_MAJOR || ((M) >= SCSI_DISK1_MAJOR && (M) <= SCSI_DISK7_MAJOR))


#define SCSI_BLK_MAJOR(M) (SCSI_DISK_MAJOR(M) || (M) == SCSI_CDROM_MAJOR)



static __inline__ __attribute__((always_inline)) int scsi_blk_major(int m) {
        return (((m) == 8 || ((m) >= 65 && (m) <= 71)) || (m) == 11);
}




#define IDE_DISK_MAJOR(M) ((M) == IDE0_MAJOR || (M) == IDE1_MAJOR || (M) == IDE2_MAJOR || (M) == IDE3_MAJOR || (M) == IDE4_MAJOR || (M) == IDE5_MAJOR || (M) == IDE6_MAJOR || (M) == IDE7_MAJOR || (M) == IDE8_MAJOR || (M) == IDE9_MAJOR)





static __inline__ __attribute__((always_inline)) int ide_blk_major(int m)
{
        return ((m) == 3 || (m) == 22 || (m) == 33 || (m) == 34 || (m) == 56 || (m) == 57 || (m) == 88 || (m) == 89 || (m) == 90 || (m) == 91);
}
# 22 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty.h" 2


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty_driver.h" 1

#define _LINUX_TTY_DRIVER_H 
# 120 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty_driver.h"
struct tty_driver {
        int magic;
        const char *driver_name;
        const char *name;
        int name_base;
        short major;
        short minor_start;
        short num;
        short type;
        short subtype;
        struct termios init_termios;
        int flags;
        int *refcount;
        struct proc_dir_entry *proc_entry;
        struct tty_driver *other;




        struct tty_struct **table;
        struct termios **termios;
        struct termios **termios_locked;
        void *driver_state;





        int (*open)(struct tty_struct * tty, struct file * filp);
        void (*close)(struct tty_struct * tty, struct file * filp);
        int (*write)(struct tty_struct * tty, int from_user,
                      const unsigned char *buf, int count);
        void (*put_char)(struct tty_struct *tty, unsigned char ch);
        void (*flush_chars)(struct tty_struct *tty);
        int (*write_room)(struct tty_struct *tty);
        int (*chars_in_buffer)(struct tty_struct *tty);
        int (*ioctl)(struct tty_struct *tty, struct file * file,
                    unsigned int cmd, unsigned long arg);
        void (*set_termios)(struct tty_struct *tty, struct termios * old);
        void (*throttle)(struct tty_struct * tty);
        void (*unthrottle)(struct tty_struct * tty);
        void (*stop)(struct tty_struct *tty);
        void (*start)(struct tty_struct *tty);
        void (*hangup)(struct tty_struct *tty);
        void (*break_ctl)(struct tty_struct *tty, int state);
        void (*flush_buffer)(struct tty_struct *tty);
        void (*set_ldisc)(struct tty_struct *tty);
        void (*wait_until_sent)(struct tty_struct *tty, int timeout);
        void (*send_xchar)(struct tty_struct *tty, char ch);
        int (*read_proc)(char *page, char **start, off_t off,
                          int count, int *eof, void *data);
        int (*write_proc)(struct file *file, const char *buffer,
                          unsigned long count, void *data);




        struct tty_driver *next;
        struct tty_driver *prev;
};


#define TTY_DRIVER_MAGIC 0x5402
# 205 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty_driver.h"
#define TTY_DRIVER_INSTALLED 0x0001
#define TTY_DRIVER_RESET_TERMIOS 0x0002
#define TTY_DRIVER_REAL_RAW 0x0004
#define TTY_DRIVER_NO_DEVFS 0x0008


#define TTY_DRIVER_TYPE_SYSTEM 0x0001
#define TTY_DRIVER_TYPE_CONSOLE 0x0002
#define TTY_DRIVER_TYPE_SERIAL 0x0003
#define TTY_DRIVER_TYPE_PTY 0x0004
#define TTY_DRIVER_TYPE_SCC 0x0005
#define TTY_DRIVER_TYPE_SYSCONS 0x0006


#define SYSTEM_TYPE_TTY 0x0001
#define SYSTEM_TYPE_CONSOLE 0x0002
#define SYSTEM_TYPE_SYSCONS 0x0003
#define SYSTEM_TYPE_SYSPTMX 0x0004


#define PTY_TYPE_MASTER 0x0001
#define PTY_TYPE_SLAVE 0x0002


#define SERIAL_TYPE_NORMAL 1
#define SERIAL_TYPE_CALLOUT 2
# 25 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty_ldisc.h" 1

#define _LINUX_TTY_LDISC_H 
# 110 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty_ldisc.h"
struct tty_ldisc {
        int magic;
        char *name;
        int num;
        int flags;



        int (*open)(struct tty_struct *);
        void (*close)(struct tty_struct *);
        void (*flush_buffer)(struct tty_struct *tty);
        ssize_t (*chars_in_buffer)(struct tty_struct *tty);
        ssize_t (*read)(struct tty_struct * tty, struct file * file,
                        unsigned char * buf, size_t nr);
        ssize_t (*write)(struct tty_struct * tty, struct file * file,
                         const unsigned char * buf, size_t nr);
        int (*ioctl)(struct tty_struct * tty, struct file * file,
                         unsigned int cmd, unsigned long arg);
        void (*set_termios)(struct tty_struct *tty, struct termios * old);
        unsigned int (*poll)(struct tty_struct *, struct file *,
                             struct poll_table_struct *);
        int (*hangup)(struct tty_struct *tty);




        void (*receive_buf)(struct tty_struct *, const unsigned char *cp,
                               char *fp, int count);
        int (*receive_room)(struct tty_struct *);
        void (*write_wakeup)(struct tty_struct *);
        int refcount;
};

#define TTY_LDISC_MAGIC 0x5403

#define LDISC_FLAG_DEFINED 0x00000001
# 26 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty.h" 2
# 36 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty.h"
#define NR_PTYS 256
#define NR_LDISCS 16







#define UNIX98_NR_MAJORS ((CONFIG_UNIX98_PTY_COUNT+NR_PTYS-1)/NR_PTYS)
# 59 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty.h"
struct screen_info {
        u8 orig_x;
        u8 orig_y;
        u16 dontuse1;
        u16 orig_video_page;
        u8 orig_video_mode;
        u8 orig_video_cols;
        u16 unused2;
        u16 orig_video_ega_bx;
        u16 unused3;
        u8 orig_video_lines;
        u8 orig_video_isVGA;
        u16 orig_video_points;


        u16 lfb_width;
        u16 lfb_height;
        u16 lfb_depth;
        u32 lfb_base;
        u32 lfb_size;
        u16 dontuse2, dontuse3;
        u16 lfb_linelength;
        u8 red_size;
        u8 red_pos;
        u8 green_size;
        u8 green_pos;
        u8 blue_size;
        u8 blue_pos;
        u8 rsvd_size;
        u8 rsvd_pos;
        u16 vesapm_seg;
        u16 vesapm_off;
        u16 pages;

};

extern struct screen_info screen_info;

#define ORIG_X (screen_info.orig_x)
#define ORIG_Y (screen_info.orig_y)
#define ORIG_VIDEO_MODE (screen_info.orig_video_mode)
#define ORIG_VIDEO_COLS (screen_info.orig_video_cols)
#define ORIG_VIDEO_EGA_BX (screen_info.orig_video_ega_bx)
#define ORIG_VIDEO_LINES (screen_info.orig_video_lines)
#define ORIG_VIDEO_ISVGA (screen_info.orig_video_isVGA)
#define ORIG_VIDEO_POINTS (screen_info.orig_video_points)

#define VIDEO_TYPE_MDA 0x10
#define VIDEO_TYPE_CGA 0x11
#define VIDEO_TYPE_EGAM 0x20
#define VIDEO_TYPE_EGAC 0x21
#define VIDEO_TYPE_VGAC 0x22
#define VIDEO_TYPE_VLFB 0x23

#define VIDEO_TYPE_PICA_S3 0x30
#define VIDEO_TYPE_MIPS_G364 0x31
#define VIDEO_TYPE_SNI_RM 0x32
#define VIDEO_TYPE_SGI 0x33

#define VIDEO_TYPE_TGAC 0x40

#define VIDEO_TYPE_SUN 0x50
#define VIDEO_TYPE_SUNPCI 0x51

#define VIDEO_TYPE_PMAC 0x60






#define __DISABLED_CHAR '\0'






#define TTY_FLIPBUF_SIZE 512

struct tty_flip_buffer {
        struct tq_struct tqueue;
        struct semaphore pty_sem;
        char *char_buf_ptr;
        unsigned char *flag_buf_ptr;
        int count;
        int buf_num;
        unsigned char char_buf[2*512];
        char flag_buf[2*512];
        unsigned char slop[4];
};



#define PTY_BUF_SIZE 4*TTY_FLIPBUF_SIZE





#define TTY_NORMAL 0
#define TTY_BREAK 1
#define TTY_FRAME 2
#define TTY_PARITY 3
#define TTY_OVERRUN 4

#define INTR_CHAR(tty) ((tty)->termios->c_cc[VINTR])
#define QUIT_CHAR(tty) ((tty)->termios->c_cc[VQUIT])
#define ERASE_CHAR(tty) ((tty)->termios->c_cc[VERASE])
#define KILL_CHAR(tty) ((tty)->termios->c_cc[VKILL])
#define EOF_CHAR(tty) ((tty)->termios->c_cc[VEOF])
#define TIME_CHAR(tty) ((tty)->termios->c_cc[VTIME])
#define MIN_CHAR(tty) ((tty)->termios->c_cc[VMIN])
#define SWTC_CHAR(tty) ((tty)->termios->c_cc[VSWTC])
#define START_CHAR(tty) ((tty)->termios->c_cc[VSTART])
#define STOP_CHAR(tty) ((tty)->termios->c_cc[VSTOP])
#define SUSP_CHAR(tty) ((tty)->termios->c_cc[VSUSP])
#define EOL_CHAR(tty) ((tty)->termios->c_cc[VEOL])
#define REPRINT_CHAR(tty) ((tty)->termios->c_cc[VREPRINT])
#define DISCARD_CHAR(tty) ((tty)->termios->c_cc[VDISCARD])
#define WERASE_CHAR(tty) ((tty)->termios->c_cc[VWERASE])
#define LNEXT_CHAR(tty) ((tty)->termios->c_cc[VLNEXT])
#define EOL2_CHAR(tty) ((tty)->termios->c_cc[VEOL2])

#define _I_FLAG(tty,f) ((tty)->termios->c_iflag & (f))
#define _O_FLAG(tty,f) ((tty)->termios->c_oflag & (f))
#define _C_FLAG(tty,f) ((tty)->termios->c_cflag & (f))
#define _L_FLAG(tty,f) ((tty)->termios->c_lflag & (f))

#define I_IGNBRK(tty) _I_FLAG((tty),IGNBRK)
#define I_BRKINT(tty) _I_FLAG((tty),BRKINT)
#define I_IGNPAR(tty) _I_FLAG((tty),IGNPAR)
#define I_PARMRK(tty) _I_FLAG((tty),PARMRK)
#define I_INPCK(tty) _I_FLAG((tty),INPCK)
#define I_ISTRIP(tty) _I_FLAG((tty),ISTRIP)
#define I_INLCR(tty) _I_FLAG((tty),INLCR)
#define I_IGNCR(tty) _I_FLAG((tty),IGNCR)
#define I_ICRNL(tty) _I_FLAG((tty),ICRNL)
#define I_IUCLC(tty) _I_FLAG((tty),IUCLC)
#define I_IXON(tty) _I_FLAG((tty),IXON)
#define I_IXANY(tty) _I_FLAG((tty),IXANY)
#define I_IXOFF(tty) _I_FLAG((tty),IXOFF)
#define I_IMAXBEL(tty) _I_FLAG((tty),IMAXBEL)

#define O_OPOST(tty) _O_FLAG((tty),OPOST)
#define O_OLCUC(tty) _O_FLAG((tty),OLCUC)
#define O_ONLCR(tty) _O_FLAG((tty),ONLCR)
#define O_OCRNL(tty) _O_FLAG((tty),OCRNL)
#define O_ONOCR(tty) _O_FLAG((tty),ONOCR)
#define O_ONLRET(tty) _O_FLAG((tty),ONLRET)
#define O_OFILL(tty) _O_FLAG((tty),OFILL)
#define O_OFDEL(tty) _O_FLAG((tty),OFDEL)
#define O_NLDLY(tty) _O_FLAG((tty),NLDLY)
#define O_CRDLY(tty) _O_FLAG((tty),CRDLY)
#define O_TABDLY(tty) _O_FLAG((tty),TABDLY)
#define O_BSDLY(tty) _O_FLAG((tty),BSDLY)
#define O_VTDLY(tty) _O_FLAG((tty),VTDLY)
#define O_FFDLY(tty) _O_FLAG((tty),FFDLY)

#define C_BAUD(tty) _C_FLAG((tty),CBAUD)
#define C_CSIZE(tty) _C_FLAG((tty),CSIZE)
#define C_CSTOPB(tty) _C_FLAG((tty),CSTOPB)
#define C_CREAD(tty) _C_FLAG((tty),CREAD)
#define C_PARENB(tty) _C_FLAG((tty),PARENB)
#define C_PARODD(tty) _C_FLAG((tty),PARODD)
#define C_HUPCL(tty) _C_FLAG((tty),HUPCL)
#define C_CLOCAL(tty) _C_FLAG((tty),CLOCAL)
#define C_CIBAUD(tty) _C_FLAG((tty),CIBAUD)
#define C_CRTSCTS(tty) _C_FLAG((tty),CRTSCTS)

#define L_ISIG(tty) _L_FLAG((tty),ISIG)
#define L_ICANON(tty) _L_FLAG((tty),ICANON)
#define L_XCASE(tty) _L_FLAG((tty),XCASE)
#define L_ECHO(tty) _L_FLAG((tty),ECHO)
#define L_ECHOE(tty) _L_FLAG((tty),ECHOE)
#define L_ECHOK(tty) _L_FLAG((tty),ECHOK)
#define L_ECHONL(tty) _L_FLAG((tty),ECHONL)
#define L_NOFLSH(tty) _L_FLAG((tty),NOFLSH)
#define L_TOSTOP(tty) _L_FLAG((tty),TOSTOP)
#define L_ECHOCTL(tty) _L_FLAG((tty),ECHOCTL)
#define L_ECHOPRT(tty) _L_FLAG((tty),ECHOPRT)
#define L_ECHOKE(tty) _L_FLAG((tty),ECHOKE)
#define L_FLUSHO(tty) _L_FLAG((tty),FLUSHO)
#define L_PENDIN(tty) _L_FLAG((tty),PENDIN)
#define L_IEXTEN(tty) _L_FLAG((tty),IEXTEN)
# 259 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty.h"
struct tty_struct {
        int magic;
        struct tty_driver driver;
        struct tty_ldisc ldisc;
        struct semaphore termios_sem;
        struct termios *termios, *termios_locked;
        int pgrp;
        int session;
        kdev_t device;
        unsigned long flags;
        int count;
        struct winsize winsize;
        unsigned char stopped:1, hw_stopped:1, flow_stopped:1, packet:1;
        unsigned char low_latency:1, warned:1;
        unsigned char ctrl_status;

        struct tty_struct *link;
        struct fasync_struct *fasync;
        struct tty_flip_buffer flip;
        int max_flip_cnt;
        int alt_speed;
        wait_queue_head_t write_wait;
        wait_queue_head_t read_wait;
        struct tq_struct tq_hangup;
        void *disc_data;
        void *driver_data;
        struct list_head tty_files;

#define N_TTY_BUF_SIZE 4096





        unsigned int column;
        unsigned char lnext:1, erasing:1, raw:1, real_raw:1, icanon:1;
        unsigned char closing:1;
        unsigned short minimum_to_wake;
        unsigned long overrun_time;
        int num_overrun;
        unsigned long process_char_map[256/(8*sizeof(unsigned long))];
        char *read_buf;
        int read_head;
        int read_tail;
        int read_cnt;
        unsigned long read_flags[4096/(8*sizeof(unsigned long))];
        int canon_data;
        unsigned long canon_head;
        unsigned int canon_column;
        struct semaphore atomic_read;
        struct semaphore atomic_write;
        spinlock_t read_lock;

        struct tq_struct SAK_tq;
};


#define TTY_MAGIC 0x5401
# 326 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty.h"
#define TTY_THROTTLED 0
#define TTY_IO_ERROR 1
#define TTY_OTHER_CLOSED 2
#define TTY_EXCLUSIVE 3
#define TTY_DEBUG 4
#define TTY_DO_WRITE_WAKEUP 5
#define TTY_PUSH 6
#define TTY_CLOSING 7
#define TTY_DONT_FLIP 8
#define TTY_LDISC 9
#define TTY_HW_COOK_OUT 14
#define TTY_HW_COOK_IN 15
#define TTY_PTY_LOCK 16
#define TTY_NO_WRITE_SPLIT 17
#define TTY_HUPPED 18

#define TTY_WRITE_FLUSH(tty) tty_write_flush((tty))

extern void tty_write_flush(struct tty_struct *);

extern struct termios tty_std_termios;
extern struct tty_ldisc tty_ldiscs[];
extern int fg_console, last_console, want_console;

extern int kmsg_redirect;

extern void con_init(void);
extern void console_init(void);

extern int lp_init(void);
extern int pty_init(void);
extern void tty_init(void);
extern int mxser_init(void);
extern int moxa_init(void);
extern int ip2_init(void);
extern int pcxe_init(void);
extern int pc_init(void);
extern int vcs_init(void);
extern int rp_init(void);
extern int cy_init(void);
extern int stl_init(void);
extern int stli_init(void);
extern int specialix_init(void);
extern int espserial_init(void);
extern int macserial_init(void);
extern int a2232board_init(void);

extern int tty_paranoia_check(struct tty_struct *tty, kdev_t device,
                              const char *routine);
extern char *tty_name(struct tty_struct *tty, char *buf);
extern void tty_wait_until_sent(struct tty_struct * tty, long timeout);
extern int tty_check_change(struct tty_struct * tty);
extern void stop_tty(struct tty_struct * tty);
extern void start_tty(struct tty_struct * tty);
extern int tty_register_ldisc(int disc, struct tty_ldisc *new_ldisc);
extern int tty_register_driver(struct tty_driver *driver);
extern int tty_unregister_driver(struct tty_driver *driver);
extern void tty_register_devfs (struct tty_driver *driver, unsigned int flags,
                                unsigned minor);
extern void tty_unregister_devfs (struct tty_driver *driver, unsigned minor);
extern int tty_read_raw_data(struct tty_struct *tty, unsigned char *bufp,
                             int buflen);
extern void tty_write_message(struct tty_struct *tty, char *msg);

extern int is_orphaned_pgrp(int pgrp);
extern int is_ignored(int sig);
extern int tty_signal(int sig, struct tty_struct *tty);
extern void tty_hangup(struct tty_struct * tty);
extern void tty_vhangup(struct tty_struct * tty);
extern void tty_unhangup(struct file *filp);
extern int tty_hung_up_p(struct file * filp);
extern void do_SAK(struct tty_struct *tty);
extern void disassociate_ctty(int priv);
extern void tty_flip_buffer_push(struct tty_struct *tty);
extern int tty_get_baud_rate(struct tty_struct *tty);

extern struct tty_ldisc *tty_ldisc_ref(struct tty_struct *);
extern void tty_ldisc_deref(struct tty_ldisc *);
extern struct tty_ldisc *tty_ldisc_ref_wait(struct tty_struct *);

extern struct tty_ldisc *tty_ldisc_get(int);
extern void tty_ldisc_put(int);

extern void tty_wakeup(struct tty_struct *tty);
extern void tty_ldisc_flush(struct tty_struct *tty);



extern struct tty_ldisc tty_ldisc_N_TTY;


extern int n_tty_ioctl(struct tty_struct * tty, struct file * file,
                       unsigned int cmd, unsigned long arg);



extern void serial_console_init(void);



extern int pcxe_open(struct tty_struct *tty, struct file *filp);



extern void console_print(const char *);



extern int vt_ioctl(struct tty_struct *tty, struct file * file,
                    unsigned int cmd, unsigned long arg);
# 25 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sem.h" 1

#define _LINUX_SEM_H 

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ipc.h" 1

#define _LINUX_IPC_H 



#define IPC_PRIVATE ((__kernel_key_t) 0)


struct ipc_perm
{
        __kernel_key_t key;
        __kernel_uid_t uid;
        __kernel_gid_t gid;
        __kernel_uid_t cuid;
        __kernel_gid_t cgid;
        __kernel_mode_t mode;
        unsigned short seq;
};


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ipcbuf.h" 1

#define _ASM_IPCBUF_H 
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/ipcbuf.h"
struct ipc64_perm
{
        __kernel_key_t key;
        __kernel_uid_t uid;
        __kernel_gid_t gid;
        __kernel_uid_t cuid;
        __kernel_gid_t cgid;
        __kernel_mode_t mode;
        unsigned short seq;
        unsigned short __pad1;
        unsigned long __unused1;
        unsigned long __unused2;
};
# 22 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ipc.h" 2


#define IPC_CREAT 00001000
#define IPC_EXCL 00002000
#define IPC_NOWAIT 00004000




#define IPC_DIPC 00010000
#define IPC_OWN 00020000





#define IPC_RMID 0
#define IPC_SET 1
#define IPC_STAT 2
#define IPC_INFO 3





#define IPC_OLD 0

#define IPC_64 0x0100




#define IPCMNI 32768


struct kern_ipc_perm
{
        key_t key;
        uid_t uid;
        gid_t gid;
        uid_t cuid;
        gid_t cgid;
        mode_t mode;
        unsigned long seq;
};
# 5 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sem.h" 2


#define SEM_UNDO 0x1000


#define GETPID 11
#define GETVAL 12
#define GETALL 13
#define GETNCNT 14
#define GETZCNT 15
#define SETVAL 16
#define SETALL 17


#define SEM_STAT 18
#define SEM_INFO 19


struct semid_ds {
        struct ipc_perm sem_perm;
        __kernel_time_t sem_otime;
        __kernel_time_t sem_ctime;
        struct sem *sem_base;
        struct sem_queue *sem_pending;
        struct sem_queue **sem_pending_last;
        struct sem_undo *undo;
        unsigned short sem_nsems;
};


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/sembuf.h" 1

#define _ASM_SEMBUF_H 
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/sembuf.h"
struct semid64_ds {
        struct ipc64_perm sem_perm;
        __kernel_time_t sem_otime;
        __kernel_time_t sem_ctime;
        unsigned long sem_nsems;
        unsigned long __unused1;
        unsigned long __unused2;
};
# 36 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sem.h" 2


struct sembuf {
        unsigned short sem_num;
        short sem_op;
        short sem_flg;
};


union semun {
        int val;
        struct semid_ds *buf;
        unsigned short *array;
        struct seminfo *__buf;
        void *__pad;
};

struct seminfo {
        int semmap;
        int semmni;
        int semmns;
        int semmnu;
        int semmsl;
        int semopm;
        int semume;
        int semusz;
        int semvmx;
        int semaem;
};

#define SEMMNI 128
#define SEMMSL 250
#define SEMMNS (SEMMNI*SEMMSL)
#define SEMOPM 32
#define SEMVMX 32767
#define SEMAEM SEMVMX


#define SEMUME SEMOPM
#define SEMMNU SEMMNS
#define SEMMAP SEMMNS
#define SEMUSZ 20




struct sem {
        int semval;
        int sempid;
};


struct sem_array {
        struct kern_ipc_perm sem_perm;
        time_t sem_otime;
        time_t sem_ctime;
        struct sem *sem_base;
        struct sem_queue *sem_pending;
        struct sem_queue **sem_pending_last;
        struct sem_undo *undo;
        unsigned long sem_nsems;
};


struct sem_queue {
        struct sem_queue * next;
        struct sem_queue ** prev;
        struct task_struct* sleeper;
        struct sem_undo * undo;
        int pid;
        int status;
        struct sem_array * sma;
        int id;
        struct sembuf * sops;
        int nsops;
        int alter;
};




struct sem_undo {
        struct sem_undo * proc_next;
        struct sem_undo * id_next;
        int semid;
        short * semadj;
};

 long sys_semget (key_t key, int nsems, int semflg);
 long sys_semop (int semid, struct sembuf *sops, unsigned nsops);
 long sys_semctl (int semid, int semnum, int cmd, union semun arg);
 long sys_semtimedop (int semid, struct sembuf *sops,
                        unsigned nsops, const struct timespec *timeout);
# 26 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/securebits.h" 1

#define _LINUX_SECUREBITS_H 1

#define SECUREBITS_DEFAULT 0x00000000

extern unsigned securebits;







#define SECURE_NOROOT 0




#define SECURE_NO_SETUID_FIXUP 2






#define issecure(X) ( (1 << (X+1)) & SECUREBITS_DEFAULT ? (1 << (X)) & SECUREBITS_DEFAULT : (1 << (X)) & securebits )
# 28 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/fs_struct.h" 1

#define _LINUX_FS_STRUCT_H 


struct fs_struct {
        atomic_t count;
        rwlock_t lock;
        int umask;
        struct dentry * root, * pwd, * altroot;
        struct vfsmount * rootmnt, * pwdmnt, * altrootmnt;
};

#define INIT_FS { ATOMIC_INIT(1), RW_LOCK_UNLOCKED, 0022, NULL, NULL, NULL, NULL, NULL, NULL }






extern void exit_fs(struct task_struct *);
extern void set_fs_altroot(void);






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void set_fs_root(struct fs_struct *fs,
        struct vfsmount *mnt,
        struct dentry *dentry)
{
        struct dentry *old_root;
        struct vfsmount *old_rootmnt;
        (void)(&fs->lock);
        old_root = fs->root;
        old_rootmnt = fs->rootmnt;
        fs->rootmnt = mntget(mnt);
        fs->root = dget(dentry);
        do { } while(0);
        if (old_root) {
                dput(old_root);
                mntput(old_rootmnt);
        }
}






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void set_fs_pwd(struct fs_struct *fs,
        struct vfsmount *mnt,
        struct dentry *dentry)
{
        struct dentry *old_pwd;
        struct vfsmount *old_pwdmnt;
        (void)(&fs->lock);
        old_pwd = fs->pwd;
        old_pwdmnt = fs->pwdmnt;
        fs->pwdmnt = mntget(mnt);
        fs->pwd = dget(dentry);
        do { } while(0);
        if (old_pwd) {
                dput(old_pwd);
                mntput(old_pwdmnt);
        }
}

struct fs_struct *copy_fs_struct(struct fs_struct *old);
void put_fs_struct(struct fs_struct *fs);
# 29 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2

struct exec_domain;




#define CSIGNAL 0x000000ff
#define CLONE_VM 0x00000100
#define CLONE_FS 0x00000200
#define CLONE_FILES 0x00000400
#define CLONE_SIGHAND 0x00000800
#define CLONE_PID 0x00001000
#define CLONE_PTRACE 0x00002000
#define CLONE_VFORK 0x00004000
#define CLONE_PARENT 0x00008000
#define CLONE_THREAD 0x00010000
#define CLONE_NEWNS 0x00020000

#define CLONE_SIGNAL (CLONE_SIGHAND | CLONE_THREAD)
# 59 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
extern unsigned long avenrun[];

#define FSHIFT 11
#define FIXED_1 (1<<FSHIFT)
#define LOAD_FREQ (5*HZ)
#define EXP_1 1884
#define EXP_5 2014
#define EXP_15 2037

#define CALC_LOAD(load,exp,n) load *= exp; load += n*(FIXED_1-exp); load >>= FSHIFT;




#define CT_TO_SECS(x) ((x) / HZ)
#define CT_TO_USECS(x) (((x) % HZ) * 1000000/HZ)

extern int nr_running, nr_threads;
extern int last_pid;



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/param.h" 1

#define _LINUX_PARAM_H 
# 82 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/resource.h" 1

#define _LINUX_RESOURCE_H 
# 17 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/resource.h"
#define RUSAGE_SELF 0
#define RUSAGE_CHILDREN (-1)
#define RUSAGE_BOTH (-2)

struct rusage {
        struct timeval ru_utime;
        struct timeval ru_stime;
        long ru_maxrss;
        long ru_ixrss;
        long ru_idrss;
        long ru_isrss;
        long ru_minflt;
        long ru_majflt;
        long ru_nswap;
        long ru_inblock;
        long ru_oublock;
        long ru_msgsnd;
        long ru_msgrcv;
        long ru_nsignals;
        long ru_nvcsw;
        long ru_nivcsw;
};

struct rlimit {
        unsigned long rlim_cur;
        unsigned long rlim_max;
};

#define PRIO_MIN (-20)
#define PRIO_MAX 20

#define PRIO_PROCESS 0
#define PRIO_PGRP 1
#define PRIO_USER 2





# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/resource.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/resource.h"
#define _ASM_RESOURCE_H 




#define RLIMIT_CPU 0
#define RLIMIT_FSIZE 1
#define RLIMIT_DATA 2
#define RLIMIT_STACK 3
#define RLIMIT_CORE 4
#define RLIMIT_NOFILE 5
#define RLIMIT_AS 6
#define RLIMIT_RSS 7
#define RLIMIT_NPROC 8
#define RLIMIT_MEMLOCK 9
#define RLIMIT_LOCKS 10

#define RLIM_NLIMITS 11







#define RLIM_INFINITY 0x7fffffffUL

#define INIT_RLIMITS { { RLIM_INFINITY, RLIM_INFINITY }, { RLIM_INFINITY, RLIM_INFINITY }, { RLIM_INFINITY, RLIM_INFINITY }, { _STK_LIM, RLIM_INFINITY }, { 0, RLIM_INFINITY }, { INR_OPEN, INR_OPEN }, { RLIM_INFINITY, RLIM_INFINITY }, { RLIM_INFINITY, RLIM_INFINITY }, { 0, 0 }, { RLIM_INFINITY, RLIM_INFINITY }, { RLIM_INFINITY, RLIM_INFINITY }, }
# 57 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/resource.h" 2
# 83 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2






#define TASK_RUNNING 0
#define TASK_INTERRUPTIBLE 1
#define TASK_UNINTERRUPTIBLE 2
#define TASK_ZOMBIE 4
#define TASK_STOPPED 8

#define __set_task_state(tsk,state_value) do { (tsk)->state = (state_value); } while (0)

#define set_task_state(tsk,state_value) set_mb((tsk)->state, (state_value))


#define __set_current_state(state_value) do { current->state = (state_value); } while (0)

#define set_current_state(state_value) set_mb(current->state, (state_value))





#define SCHED_OTHER 0
#define SCHED_FIFO 1
#define SCHED_RR 2





#define SCHED_YIELD 0x10

struct sched_param {
        int sched_priority;
};

struct completion;
# 134 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
extern rwlock_t tasklist_lock;
extern spinlock_t runqueue_lock;
extern spinlock_t mmlist_lock;

extern void sched_init(void);
extern void init_idle(void);
extern void show_state(void);
extern void cpu_init (void);
extern void trap_init(void);
extern void update_process_times(int user);
extern void update_one_process(struct task_struct *p, unsigned long user,
                               unsigned long system, int cpu);

#define MAX_SCHEDULE_TIMEOUT LONG_MAX
extern signed long schedule_timeout(signed long timeout);
 void schedule(void);

extern int schedule_task(struct tq_struct *task);
extern void flush_scheduled_tasks(void);
extern int start_context_thread(void);
extern int current_is_keventd(void);




#define set_cpus_allowed(p,new_mask) do { } while (0)






#define NR_OPEN_DEFAULT BITS_PER_LONG

struct namespace;



struct files_struct {
        atomic_t count;
        rwlock_t file_lock;
        int max_fds;
        int max_fdset;
        int next_fd;
        struct file ** fd;
        fd_set *close_on_exec;
        fd_set *open_fds;
        fd_set close_on_exec_init;
        fd_set open_fds_init;
        struct file * fd_array[32];
};

#define INIT_FILES { count: ATOMIC_INIT(1), file_lock: RW_LOCK_UNLOCKED, max_fds: NR_OPEN_DEFAULT, max_fdset: __FD_SETSIZE, next_fd: 0, fd: &init_files.fd_array[0], close_on_exec: &init_files.close_on_exec_init, open_fds: &init_files.open_fds_init, close_on_exec_init: { { 0, } }, open_fds_init: { { 0, } }, fd_array: { NULL, } }
# 202 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
#define DEFAULT_MAX_MAP_COUNT (65536)

extern int max_map_count;

struct mm_struct {
        struct vm_area_struct * mmap;
        rb_root_t mm_rb;
        struct vm_area_struct * mmap_cache;
        pgd_t * pgd;
        atomic_t mm_users;
        atomic_t mm_count;
        int map_count;
        struct rw_semaphore mmap_sem;
        spinlock_t page_table_lock;

        struct list_head mmlist;




        unsigned long start_code, end_code, start_data, end_data;
        unsigned long start_brk, brk, start_stack;
        unsigned long arg_start, arg_end, env_start, env_end;
        unsigned long rss, total_vm, locked_vm;
        unsigned long def_flags;
        unsigned long cpu_vm_mask;
        unsigned long swap_address;

        unsigned dumpable:1;


        mm_context_t context;
};

extern int mmlist_nr;

#define INIT_MM(name) { mm_rb: RB_ROOT, pgd: swapper_pg_dir, mm_users: ATOMIC_INIT(2), mm_count: ATOMIC_INIT(1), mmap_sem: __RWSEM_INITIALIZER(name.mmap_sem), page_table_lock: SPIN_LOCK_UNLOCKED, mmlist: LIST_HEAD_INIT(name.mmlist), }
# 249 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
struct signal_struct {
        atomic_t count;
        struct k_sigaction action[128];
        spinlock_t siglock;
};


#define INIT_SIGNALS { count: ATOMIC_INIT(1), action: { {{0,}}, }, siglock: SPIN_LOCK_UNLOCKED }
# 265 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
struct user_struct {
        atomic_t __count;
        atomic_t processes;
        atomic_t files;


        struct user_struct *next, **pprev;
        uid_t uid;
};

#define get_current_user() ({ struct user_struct *__tmp_user = current->user; atomic_inc(&__tmp_user->__count); __tmp_user; })




extern struct user_struct root_user;
#define INIT_USER (&root_user)

struct task_struct {



        volatile long state;
        unsigned long flags;
        int sigpending;
        mm_segment_t addr_limit;



        struct exec_domain *exec_domain;
        volatile long need_resched;
        unsigned long ptrace;

        int lock_depth;






        long counter;
        long nice;
        unsigned long policy;
        struct mm_struct *mm;
        int processor;
# 318 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
        unsigned long cpus_runnable, cpus_allowed;




        struct list_head run_list;
        unsigned long sleep_time;

        struct task_struct *next_task, *prev_task;
        struct mm_struct *active_mm;
        struct list_head local_pages;
        unsigned int allocation_order, nr_local_pages;


        struct linux_binfmt *binfmt;
        int exit_code, exit_signal;
        int pdeath_signal;

        unsigned long personality;
        int did_exec:1;
        unsigned task_dumpable:1;
        pid_t pid;
        pid_t pgrp;
        pid_t tty_old_pgrp;
        pid_t session;
        pid_t tgid;

        int leader;





        struct task_struct *p_opptr, *p_pptr, *p_cptr, *p_ysptr, *p_osptr;
        struct list_head thread_group;


        struct task_struct *pidhash_next;
        struct task_struct **pidhash_pprev;

        wait_queue_head_t wait_chldexit;
        struct completion *vfork_done;
        unsigned long rt_priority;
        unsigned long it_real_value, it_prof_value, it_virt_value;
        unsigned long it_real_incr, it_prof_incr, it_virt_incr;
        struct timer_list real_timer;
        struct tms times;
        unsigned long start_time;
        long per_cpu_utime[1], per_cpu_stime[1];

        unsigned long min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;
        int swappable:1;

        uid_t uid,euid,suid,fsuid;
        gid_t gid,egid,sgid,fsgid;
        int ngroups;
        gid_t groups[32];
        kernel_cap_t cap_effective, cap_inheritable, cap_permitted;
        int keep_capabilities:1;
        struct user_struct *user;

        struct rlimit rlim[11];
        unsigned short used_math;
        char comm[16];

        int link_count, total_link_count;
        struct tty_struct *tty;
        unsigned int locks;

        struct sem_undo *semundo;
        struct sem_queue *semsleeping;

        struct thread_struct thread;

        struct fs_struct *fs;

        struct files_struct *files;

        struct namespace *namespace;

        spinlock_t sigmask_lock;
        struct signal_struct *sig;

        sigset_t blocked;
        struct sigpending pending;

        unsigned long sas_ss_sp;
        size_t sas_ss_size;
        int (*notifier)(void *priv);
        void *notifier_data;
        sigset_t *notifier_mask;


        u32 parent_exec_id;
        u32 self_exec_id;

        spinlock_t alloc_lock;


        void *journal_info;

        struct list_head *scm_work_list;
};




#define PF_ALIGNWARN 0x00000001

#define PF_STARTING 0x00000002
#define PF_EXITING 0x00000004
#define PF_FORKNOEXEC 0x00000040
#define PF_SUPERPRIV 0x00000100
#define PF_DUMPCORE 0x00000200
#define PF_SIGNALED 0x00000400
#define PF_MEMALLOC 0x00000800
#define PF_MEMDIE 0x00001000
#define PF_FREE_PAGES 0x00002000
#define PF_NOIO 0x00004000
#define PF_FSTRANS 0x00008000

#define PF_USEDFPU 0x00100000





#define PT_PTRACED 0x00000001
#define PT_TRACESYS 0x00000002
#define PT_DTRACE 0x00000004
#define PT_TRACESYSGOOD 0x00000008
#define PT_PTRACE_CAP 0x00000010

#define is_dumpable(tsk) ((tsk)->task_dumpable && (tsk)->mm && (tsk)->mm->dumpable)





#define _STK_LIM (8*1024*1024)

#define DEF_COUNTER (10*HZ/100)
#define MAX_COUNTER (20*HZ/100)
#define DEF_NICE (0)

extern void yield(void);




extern struct exec_domain default_exec_domain;





#define INIT_TASK(tsk) { state: 0, flags: 0, sigpending: 0, addr_limit: KERNEL_DS, exec_domain: &default_exec_domain, lock_depth: -1, counter: DEF_COUNTER, nice: DEF_NICE, policy: SCHED_OTHER, mm: NULL, active_mm: &init_mm, cpus_runnable: ~0UL, cpus_allowed: ~0UL, run_list: LIST_HEAD_INIT(tsk.run_list), next_task: &tsk, prev_task: &tsk, p_opptr: &tsk, p_pptr: &tsk, thread_group: LIST_HEAD_INIT(tsk.thread_group), wait_chldexit: __WAIT_QUEUE_HEAD_INITIALIZER(tsk.wait_chldexit), real_timer: { function: it_real_fn }, cap_effective: CAP_INIT_EFF_SET, cap_inheritable: CAP_INIT_INH_SET, cap_permitted: CAP_FULL_SET, keep_capabilities: 0, rlim: INIT_RLIMITS, user: INIT_USER, comm: "swapper", thread: INIT_THREAD, fs: &init_fs, files: &init_files, sigmask_lock: SPIN_LOCK_UNLOCKED, sig: &init_signals, pending: { NULL, &tsk.pending.head, {{0}}}, blocked: {{0}}, alloc_lock: SPIN_LOCK_UNLOCKED, journal_info: NULL, }
# 519 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
#define INIT_TASK_SIZE 2048*sizeof(long)


union task_union {
        struct task_struct task;
        unsigned long stack[2048*sizeof(long)/sizeof(long)];
};

extern union task_union init_task_union;

extern struct mm_struct init_mm;
extern struct task_struct *init_tasks[1];


#define PIDHASH_SZ (4096 >> 2)
extern struct task_struct *pidhash[(4096 >> 2)];

#define pid_hashfn(x) ((((x) >> 8) ^ (x)) & (PIDHASH_SZ - 1))

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void hash_pid(struct task_struct *p)
{
        struct task_struct **htable = &pidhash[((((p->pid) >> 8) ^ (p->pid)) & ((4096 >> 2) - 1))];

        if((p->pidhash_next = *htable) != ((void *)0))
                (*htable)->pidhash_pprev = &p->pidhash_next;
        *htable = p;
        p->pidhash_pprev = htable;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void unhash_pid(struct task_struct *p)
{
        if(p->pidhash_next)
                p->pidhash_next->pidhash_pprev = p->pidhash_pprev;
        *p->pidhash_pprev = p->pidhash_next;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct task_struct *find_task_by_pid(int pid)
{
        struct task_struct *p, **htable = &pidhash[((((pid) >> 8) ^ (pid)) & ((4096 >> 2) - 1))];

        for(p = *htable; p && p->pid != pid; p = p->pidhash_next)
                ;

        return p;
}

#define task_has_cpu(tsk) ((tsk)->cpus_runnable != ~0UL)

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void task_set_cpu(struct task_struct *tsk, unsigned int cpu)
{
        tsk->processor = cpu;
        tsk->cpus_runnable = 1UL << cpu;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void task_release_cpu(struct task_struct *tsk)
{
        tsk->cpus_runnable = ~0UL;
}


extern struct user_struct * alloc_uid(uid_t);
extern void free_uid(struct user_struct *);
extern void switch_uid(struct user_struct *);

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/current.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/current.h"
#define _ASM_CURRENT_H 




register struct task_struct *current asm("$28");
# 584 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h" 2

extern unsigned long volatile jiffies;
extern unsigned long itimer_ticks;
extern unsigned long itimer_next;
extern struct timeval xtime;
extern void do_timer(struct pt_regs *);

extern unsigned int * prof_buffer;
extern unsigned long prof_len;
extern unsigned long prof_shift;

#define CURRENT_TIME (xtime.tv_sec)

extern void __wake_up(wait_queue_head_t *q, unsigned int mode, int nr);
extern void __wake_up_sync(wait_queue_head_t *q, unsigned int mode, int nr);
extern void sleep_on(wait_queue_head_t *q);
extern long sleep_on_timeout(wait_queue_head_t *q, signed long timeout);

extern void interruptible_sleep_on(wait_queue_head_t *q);
extern long interruptible_sleep_on_timeout(wait_queue_head_t *q, signed long timeout);

extern int wake_up_process(struct task_struct * tsk);

#define wake_up(x) __wake_up((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 1)
#define wake_up_nr(x,nr) __wake_up((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, nr)
#define wake_up_all(x) __wake_up((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 0)
#define wake_up_sync(x) __wake_up_sync((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 1)
#define wake_up_sync_nr(x,nr) __wake_up_sync((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, nr)
#define wake_up_interruptible(x) __wake_up((x),TASK_INTERRUPTIBLE, 1)
#define wake_up_interruptible_nr(x,nr) __wake_up((x),TASK_INTERRUPTIBLE, nr)
#define wake_up_interruptible_all(x) __wake_up((x),TASK_INTERRUPTIBLE, 0)
#define wake_up_interruptible_sync(x) __wake_up_sync((x),TASK_INTERRUPTIBLE, 1)
#define wake_up_interruptible_sync_nr(x,nr) __wake_up_sync((x),TASK_INTERRUPTIBLE, nr)
 long sys_wait4(pid_t pid,unsigned int * stat_addr, int options, struct rusage * ru);

extern int in_group_p(gid_t);
extern int in_egroup_p(gid_t);

extern void proc_caches_init(void);
extern void flush_signals(struct task_struct *);
extern void flush_signal_handlers(struct task_struct *);
extern void sig_exit(int, int, struct siginfo *);
extern int dequeue_signal(sigset_t *, siginfo_t *);
extern void block_all_signals(int (*notifier)(void *priv), void *priv,
                              sigset_t *mask);
extern void unblock_all_signals(void);
extern int send_sig_info(int, struct siginfo *, struct task_struct *);
extern int force_sig_info(int, struct siginfo *, struct task_struct *);
extern int kill_pg_info(int, struct siginfo *, pid_t);
extern int kill_sl_info(int, struct siginfo *, pid_t);
extern int kill_proc_info(int, struct siginfo *, pid_t);
extern void notify_parent(struct task_struct *, int);
extern void do_notify_parent(struct task_struct *, int);
extern void force_sig(int, struct task_struct *);
extern int send_sig(int, struct task_struct *, int);
extern int kill_pg(pid_t, int, int);
extern int kill_sl(pid_t, int, int);
extern int kill_proc(pid_t, int, int);
extern int do_sigaction(int, const struct k_sigaction *, struct k_sigaction *);
extern int do_sigaltstack(const stack_t *, stack_t *, unsigned long);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int signal_pending(struct task_struct *p)
{
        return (p->sigpending != 0);
}





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int has_pending_signals(sigset_t *signal, sigset_t *blocked)
{
        unsigned long ready;
        long i;

        switch ((128 / 32)) {
        default:
                for (i = (128 / 32), ready = 0; --i >= 0 ;)
                        ready |= signal->sig[i] &~ blocked->sig[i];
                break;

        case 4: ready = signal->sig[3] &~ blocked->sig[3];
                ready |= signal->sig[2] &~ blocked->sig[2];
                ready |= signal->sig[1] &~ blocked->sig[1];
                ready |= signal->sig[0] &~ blocked->sig[0];
                break;

        case 2: ready = signal->sig[1] &~ blocked->sig[1];
                ready |= signal->sig[0] &~ blocked->sig[0];
                break;

        case 1: ready = signal->sig[0] &~ blocked->sig[0];
        }
        return ready != 0;
}





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void recalc_sigpending(struct task_struct *t)
{
        t->sigpending = has_pending_signals(&t->pending.signal, &t->blocked);
}



static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int on_sig_stack(unsigned long sp)
{
        return (sp - current->sas_ss_sp < current->sas_ss_size);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int sas_ss_flags(unsigned long sp)
{
        return (current->sas_ss_size == 0 ? 2
                : on_sig_stack(sp) ? 1 : 0);
}

extern int request_irq(unsigned int,
                       void (*handler)(int, void *, struct pt_regs *),
                       unsigned long, const char *, void *);
extern void free_irq(unsigned int, void *);
# 721 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int suser(void)
{
        if (!( (1 << (0 +1)) & 0x00000000 ? (1 << (0)) & 0x00000000 : (1 << (0)) & securebits ) && current->euid == 0) {
                current->flags |= 0x00000100;
                return 1;
        }
        return 0;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int fsuser(void)
{
        if (!( (1 << (0 +1)) & 0x00000000 ? (1 << (0)) & 0x00000000 : (1 << (0)) & securebits ) && current->fsuid == 0) {
                current->flags |= 0x00000100;
                return 1;
        }
        return 0;
}







static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int capable(int cap)
{

        if (((current->cap_effective) & (1 << (cap))))



        {
                current->flags |= 0x00000100;
                return 1;
        }
        return 0;
}




extern struct mm_struct * mm_alloc(void);

extern struct mm_struct * start_lazy_tlb(void);
extern void end_lazy_tlb(struct mm_struct *mm);


extern void __mmdrop(struct mm_struct *);
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void mmdrop(struct mm_struct * mm)
{
        if ((atomic_sub_return(1, (&mm->mm_count)) == 0))
                __mmdrop(mm);
}


extern void mmput(struct mm_struct *);

extern void mm_release(void);




extern struct file ** alloc_fd_array(int);
extern int expand_fd_array(struct files_struct *, int nr);
extern void free_fd_array(struct file **, int);

extern fd_set *alloc_fdset(int);
extern int expand_fdset(struct files_struct *, int nr);
extern void free_fdset(fd_set *, int);

extern int copy_thread(int, unsigned long, unsigned long, unsigned long, struct task_struct *, struct pt_regs *);
extern void flush_thread(void);
extern void exit_thread(void);

extern void exit_mm(struct task_struct *);
extern void exit_files(struct task_struct *);
extern void exit_sighand(struct task_struct *);

extern void reparent_to_init(void);
extern void daemonize(void);

extern int do_execve(char *, char **, char **, struct pt_regs *);
extern int do_fork(unsigned long, unsigned long, struct pt_regs *, unsigned long);

extern void set_task_comm(struct task_struct *tsk, char *from);
extern void get_task_comm(char *to, struct task_struct *tsk);

extern void add_wait_queue(wait_queue_head_t *q, wait_queue_t * wait);
extern void add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t * wait);
extern void remove_wait_queue(wait_queue_head_t *q, wait_queue_t * wait);

extern long kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);

#define __wait_event(wq,condition) do { wait_queue_t __wait; init_waitqueue_entry(&__wait, current); add_wait_queue(&wq, &__wait); for (;;) { set_current_state(TASK_UNINTERRUPTIBLE); if (condition) break; schedule(); } current->state = TASK_RUNNING; remove_wait_queue(&wq, &__wait); } while (0)
# 830 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
#define wait_event(wq,condition) do { if (condition) break; __wait_event(wq, condition); } while (0)






#define __wait_event_interruptible(wq,condition,ret) do { wait_queue_t __wait; init_waitqueue_entry(&__wait, current); add_wait_queue(&wq, &__wait); for (;;) { set_current_state(TASK_INTERRUPTIBLE); if (condition) break; if (!signal_pending(current)) { schedule(); continue; } ret = -ERESTARTSYS; break; } current->state = TASK_RUNNING; remove_wait_queue(&wq, &__wait); } while (0)
# 858 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
#define wait_event_interruptible(wq,condition) ({ int __ret = 0; if (!(condition)) __wait_event_interruptible(wq, condition, __ret); __ret; })







#define REMOVE_LINKS(p) do { (p)->next_task->prev_task = (p)->prev_task; (p)->prev_task->next_task = (p)->next_task; if ((p)->p_osptr) (p)->p_osptr->p_ysptr = (p)->p_ysptr; if ((p)->p_ysptr) (p)->p_ysptr->p_osptr = (p)->p_osptr; else (p)->p_pptr->p_cptr = (p)->p_osptr; } while (0)
# 877 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
#define SET_LINKS(p) do { (p)->next_task = &init_task; (p)->prev_task = init_task.prev_task; init_task.prev_task->next_task = (p); init_task.prev_task = (p); (p)->p_ysptr = NULL; if (((p)->p_osptr = (p)->p_pptr->p_cptr) != NULL) (p)->p_osptr->p_ysptr = p; (p)->p_pptr->p_cptr = p; } while (0)
# 888 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/sched.h"
#define for_each_task(p) for (p = &init_task ; (p = p->next_task) != &init_task ; )


#define for_each_thread(task) for (task = next_thread(current) ; task != current ; task = next_thread(task))


#define next_thread(p) list_entry((p)->thread_group.next, struct task_struct, thread_group)


#define thread_group_leader(p) (p->pid == p->tgid)

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void del_from_runqueue(struct task_struct * p)
{
        nr_running--;
        p->sleep_time = jiffies;
        list_del(&p->run_list);
        p->run_list.next = ((void *)0);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int task_on_runqueue(struct task_struct *p)
{
        return (p->run_list.next != ((void *)0));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void unhash_process(struct task_struct *p)
{
        if (task_on_runqueue(p))
                __out_of_line_bug(915);
        do { __cli(); (void)(&tasklist_lock); } while (0);
        nr_threads--;
        unhash_pid(p);
        do { (p)->next_task->prev_task = (p)->prev_task; (p)->prev_task->next_task = (p)->next_task; if ((p)->p_osptr) (p)->p_osptr->p_ysptr = (p)->p_ysptr; if ((p)->p_ysptr) (p)->p_ysptr->p_osptr = (p)->p_osptr; else (p)->p_pptr->p_cptr = (p)->p_osptr; } while (0);
        list_del(&p->thread_group);
        do { do { } while(0); __sti(); } while (0);
}


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void task_lock(struct task_struct *p)
{
        (void)(&p->alloc_lock);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void task_unlock(struct task_struct *p)
{
        do { } while(0);
}


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) char * d_path(struct dentry *dentry, struct vfsmount *vfsmnt,
                                char *buf, int buflen)
{
        char *res;
        struct vfsmount *rootmnt;
        struct dentry *root;
        (void)(&current->fs->lock);
        rootmnt = mntget(current->fs->rootmnt);
        root = dget(current->fs->root);
        (void)(&current->fs->lock);
        (void)(&dcache_lock);
        res = __d_path(dentry, vfsmnt, root, rootmnt, buf, buflen);
        do { } while(0);
        dput(root);
        mntput(rootmnt);
        return res;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int need_resched(void)
{
        return (__builtin_expect((current->need_resched),0));
}

extern void __cond_resched(void);
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void cond_resched(void)
{
        if (need_resched())
                __cond_resched();
}
# 195 "drivers/char/serial.c" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/interrupt.h" 1


#define _LINUX_INTERRUPT_H 
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/interrupt.h"
typedef void irqreturn_t;
#define IRQ_NONE 
#define IRQ_HANDLED 
#define IRQ_RETVAL(x) 

struct irqaction {
        void (*handler)(int, void *, struct pt_regs *);
        unsigned long flags;
        unsigned long mask;
        const char *name;
        void *dev_id;
        struct irqaction *next;
};





enum {
        TIMER_BH = 0,
        TQUEUE_BH,
        DIGI_BH,
        SERIAL_BH,
        RISCOM8_BH,
        SPECIALIX_BH,
        AURORA_BH,
        ESP_BH,
        SCSI_BH,
        IMMEDIATE_BH,
        CYCLADES_BH,
        CM206_BH,
        JS_BH,
        MACSERIAL_BH,
        ISICOM_BH
};

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/hardirq.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/hardirq.h"
#define _ASM_HARDIRQ_H 



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/irq.h" 1

#define __irq_h 
# 19 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/irq.h"
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/irq.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/irq.h"
#define _ASM_IRQ_H 




#define NR_IRQS 128







#define irq_cannonicalize(irq) (irq)


extern void disable_irq(unsigned int);
extern void disable_irq_nosync(unsigned int);
extern void enable_irq(unsigned int);

struct pt_regs;
extern unsigned int do_IRQ(int irq, struct pt_regs *regs);


extern void (*irq_setup)(void);

extern void init_generic_irq(void);
# 20 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/irq.h" 2





#define IRQ_INPROGRESS 1
#define IRQ_DISABLED 2
#define IRQ_PENDING 4
#define IRQ_REPLAY 8
#define IRQ_AUTODETECT 16
#define IRQ_WAITING 32
#define IRQ_LEVEL 64
#define IRQ_MASKED 128
#define IRQ_PER_CPU 256





struct hw_interrupt_type {
        const char * typename;
        unsigned int (*startup)(unsigned int irq);
        void (*shutdown)(unsigned int irq);
        void (*enable)(unsigned int irq);
        void (*disable)(unsigned int irq);
        void (*ack)(unsigned int irq);
        void (*end)(unsigned int irq);
        void (*set_affinity)(unsigned int irq, unsigned long mask);
};

typedef struct hw_interrupt_type hw_irq_controller;
# 59 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/irq.h"
typedef struct {
        unsigned int status;
        hw_irq_controller *handler;
        struct irqaction *action;
        unsigned int depth;
        spinlock_t lock;
} __attribute__((__aligned__(32))) irq_desc_t;

extern irq_desc_t irq_desc [128];

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/hw_irq.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/hw_irq.h"
#define _ASM_HW_IRQ_H 



extern atomic_t irq_err_count;


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void hw_resend_irq(struct hw_interrupt_type *h, unsigned int i)
{
}
# 70 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/irq.h" 2

extern int handle_IRQ_event(unsigned int, struct pt_regs *, struct irqaction *);
extern int setup_irq(unsigned int , struct irqaction * );

extern hw_irq_controller no_irq_type;
extern void no_action(int cpl, void *dev_id, struct pt_regs *regs);
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/hardirq.h" 2


typedef struct {
        unsigned int __softirq_pending;
        unsigned int __local_irq_count;
        unsigned int __local_bh_count;
        unsigned int __syscall_count;
        struct task_struct * __ksoftirqd_task;
} __attribute__((__aligned__(32))) irq_cpustat_t;

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/irq_cpustat.h" 1

#define __irq_cpustat_h 
# 20 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/irq_cpustat.h"
extern irq_cpustat_t irq_stat[];




#define __IRQ_STAT(cpu,member) (irq_stat[((void)(cpu), 0)].member)



#define softirq_pending(cpu) __IRQ_STAT((cpu), __softirq_pending)
#define local_irq_count(cpu) __IRQ_STAT((cpu), __local_irq_count)
#define local_bh_count(cpu) __IRQ_STAT((cpu), __local_bh_count)
#define syscall_count(cpu) __IRQ_STAT((cpu), __syscall_count)
#define ksoftirqd_task(cpu) __IRQ_STAT((cpu), __ksoftirqd_task)

#define nmi_count(cpu) __IRQ_STAT((cpu), __nmi_count)
# 27 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/hardirq.h" 2





#define in_interrupt() ({ int __cpu = smp_processor_id(); (local_irq_count(__cpu) + local_bh_count(__cpu) != 0); })

#define in_irq() (local_irq_count(smp_processor_id()) != 0)



#define hardirq_trylock(cpu) (local_irq_count(cpu) == 0)
#define hardirq_endlock(cpu) do { } while (0)

#define irq_enter(cpu,irq) (local_irq_count(cpu)++)
#define irq_exit(cpu,irq) (local_irq_count(cpu)--)

#define synchronize_irq() barrier();
# 53 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/interrupt.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/softirq.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/softirq.h"
#define _ASM_SOFTIRQ_H 




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void cpu_bh_disable(int cpu)
{
        (irq_stat[((void)((cpu)), 0)].__local_bh_count)++;
        __asm__ __volatile__("": : :"memory");
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __cpu_bh_enable(int cpu)
{
        __asm__ __volatile__("": : :"memory");
        (irq_stat[((void)((cpu)), 0)].__local_bh_count)--;
}


#define local_bh_disable() cpu_bh_disable(smp_processor_id())
#define __local_bh_enable() __cpu_bh_enable(smp_processor_id())
#define local_bh_enable() do { int cpu; barrier(); cpu = smp_processor_id(); if (!--local_bh_count(cpu) && softirq_pending(cpu)) do_softirq(); } while (0)
# 41 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/softirq.h"
#define in_softirq() (local_bh_count(smp_processor_id()) != 0)
# 54 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/interrupt.h" 2
# 63 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/interrupt.h"
enum
{
        HI_SOFTIRQ=0,
        NET_TX_SOFTIRQ,
        NET_RX_SOFTIRQ,
        TASKLET_SOFTIRQ
};





struct softirq_action
{
        void (*action)(struct softirq_action *);
        void *data;
};

 void do_softirq(void);
extern void open_softirq(int nr, void (*action)(struct softirq_action*), void *data);
extern void softirq_init(void);
#define __cpu_raise_softirq(cpu,nr) do { softirq_pending(cpu) |= 1UL << (nr); } while (0)
extern void cpu_raise_softirq(unsigned int cpu, unsigned int nr);
extern void raise_softirq(unsigned int nr);
# 110 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/interrupt.h"
struct tasklet_struct
{
        struct tasklet_struct *next;
        unsigned long state;
        atomic_t count;
        void (*func)(unsigned long);
        unsigned long data;
};

#define DECLARE_TASKLET(name,func,data) struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data }


#define DECLARE_TASKLET_DISABLED(name,func,data) struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(1), func, data }



enum
{
        TASKLET_STATE_SCHED,
        TASKLET_STATE_RUN
};

struct tasklet_head
{
        struct tasklet_struct *list;
} __attribute__ ((__aligned__(32)));

extern struct tasklet_head tasklet_vec[1];
extern struct tasklet_head tasklet_hi_vec[1];
# 157 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/interrupt.h"
#define tasklet_trylock(t) 1
#define tasklet_unlock_wait(t) do { } while (0)
#define tasklet_unlock(t) do { } while (0)


extern void __tasklet_schedule(struct tasklet_struct *t);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void tasklet_schedule(struct tasklet_struct *t)
{
        if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
                __tasklet_schedule(t);
}

extern void __tasklet_hi_schedule(struct tasklet_struct *t);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void tasklet_hi_schedule(struct tasklet_struct *t)
{
        if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
                __tasklet_hi_schedule(t);
}


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void tasklet_disable_nosync(struct tasklet_struct *t)
{
        atomic_add(1,(&t->count));
        __asm__ __volatile__("": : :"memory");
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void tasklet_disable(struct tasklet_struct *t)
{
        tasklet_disable_nosync(t);
        do { } while (0);
        __asm__ __volatile__("": : :"memory");
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void tasklet_enable(struct tasklet_struct *t)
{
        __asm__ __volatile__("": : :"memory");
        atomic_sub(1,(&t->count));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void tasklet_hi_enable(struct tasklet_struct *t)
{
        __asm__ __volatile__("": : :"memory");
        atomic_sub(1,(&t->count));
}

extern void tasklet_kill(struct tasklet_struct *t);
extern void tasklet_init(struct tasklet_struct *t,
                         void (*func)(unsigned long), unsigned long data);
# 221 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/interrupt.h"
#define SMP_TIMER_NAME(name) name
#define SMP_TIMER_DEFINE(name,task) 






extern struct tasklet_struct bh_task_vec[];


extern spinlock_t global_bh_lock;

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void mark_bh(int nr)
{
        tasklet_hi_schedule(bh_task_vec+nr);
}

extern void init_bh(int nr, void (*routine)(void));
extern void remove_bh(int nr);
# 270 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/interrupt.h"
extern unsigned long probe_irq_on(void);
extern int probe_irq_off(unsigned long);
extern unsigned int probe_irq_mask(unsigned long);
# 197 "drivers/char/serial.c" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/tty_flip.h" 1

#define _LINUX_TTY_FLIP_H 




#define _INLINE_ static __inline__


static __inline__ __attribute__((always_inline)) void tty_insert_flip_char(struct tty_struct *tty,
                                   unsigned char ch, char flag)
{
        if (tty->flip.count < 512) {
                tty->flip.count++;
                *tty->flip.flag_buf_ptr++ = flag;
                *tty->flip.char_buf_ptr++ = ch;
        }
}

static __inline__ __attribute__((always_inline)) void tty_schedule_flip(struct tty_struct *tty)
{
        queue_task(&tty->flip.tqueue, &tq_timer);
}

#undef _INLINE_
# 199 "drivers/char/serial.c" 2




# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ioport.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/ioport.h"
#define _LINUX_IOPORT_H 





struct resource {
        const char *name;
        unsigned long start, end;
        unsigned long flags;
        struct resource *parent, *sibling, *child;
};

struct resource_list {
        struct resource_list *next;
        struct resource *res;
        struct pci_dev *dev;
};




#define IORESOURCE_BITS 0x000000ff

#define IORESOURCE_IO 0x00000100
#define IORESOURCE_MEM 0x00000200
#define IORESOURCE_IRQ 0x00000400
#define IORESOURCE_DMA 0x00000800

#define IORESOURCE_PREFETCH 0x00001000
#define IORESOURCE_READONLY 0x00002000
#define IORESOURCE_CACHEABLE 0x00004000
#define IORESOURCE_RANGELENGTH 0x00008000
#define IORESOURCE_SHADOWABLE 0x00010000
#define IORESOURCE_BUS_HAS_VGA 0x00080000

#define IORESOURCE_UNSET 0x20000000
#define IORESOURCE_AUTO 0x40000000
#define IORESOURCE_BUSY 0x80000000


#define IORESOURCE_IRQ_HIGHEDGE (1<<0)
#define IORESOURCE_IRQ_LOWEDGE (1<<1)
#define IORESOURCE_IRQ_HIGHLEVEL (1<<2)
#define IORESOURCE_IRQ_LOWLEVEL (1<<3)


#define IORESOURCE_DMA_TYPE_MASK (3<<0)
#define IORESOURCE_DMA_8BIT (0<<0)
#define IORESOURCE_DMA_8AND16BIT (1<<0)
#define IORESOURCE_DMA_16BIT (2<<0)

#define IORESOURCE_DMA_MASTER (1<<2)
#define IORESOURCE_DMA_BYTE (1<<3)
#define IORESOURCE_DMA_WORD (1<<4)

#define IORESOURCE_DMA_SPEED_MASK (3<<6)
#define IORESOURCE_DMA_COMPATIBLE (0<<6)
#define IORESOURCE_DMA_TYPEA (1<<6)
#define IORESOURCE_DMA_TYPEB (2<<6)
#define IORESOURCE_DMA_TYPEF (3<<6)


#define IORESOURCE_MEM_WRITEABLE (1<<0)
#define IORESOURCE_MEM_CACHEABLE (1<<1)
#define IORESOURCE_MEM_RANGELENGTH (1<<2)
#define IORESOURCE_MEM_TYPE_MASK (3<<3)
#define IORESOURCE_MEM_8BIT (0<<3)
#define IORESOURCE_MEM_16BIT (1<<3)
#define IORESOURCE_MEM_8AND16BIT (2<<3)
#define IORESOURCE_MEM_SHADOWABLE (1<<5)
#define IORESOURCE_MEM_EXPANSIONROM (1<<6)


extern struct resource ioport_resource;
extern struct resource iomem_resource;

extern int check_resource(struct resource *root, unsigned long, unsigned long);
extern int request_resource(struct resource *root, struct resource *new);
extern int release_resource(struct resource *new);
extern int allocate_resource(struct resource *root, struct resource *new,
                             unsigned long size,
                             unsigned long min, unsigned long max,
                             unsigned long align,
                             void (*alignf)(void *, struct resource *,
                                            unsigned long, unsigned long),
                             void *alignf_data);


#define request_region(start,n,name) __request_region(&ioport_resource, (start), (n), (name))
#define request_mem_region(start,n,name) __request_region(&iomem_resource, (start), (n), (name))

extern struct resource * __request_region(struct resource *, unsigned long start, unsigned long n, const char *name);


#define check_region(start,n) __check_region(&ioport_resource, (start), (n))
#define release_region(start,n) __release_region(&ioport_resource, (start), (n))
#define check_mem_region(start,n) __check_region(&iomem_resource, (start), (n))
#define release_mem_region(start,n) __release_region(&iomem_resource, (start), (n))

extern int __check_region(struct resource *, unsigned long, unsigned long);
extern void __release_region(struct resource *, unsigned long, unsigned long);

#define HAVE_AUTOIRQ 
extern void autoirq_setup(int waittime);
extern int autoirq_report(int waittime);
# 204 "drivers/char/serial.c" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h" 1

#define _LINUX_MM_H 
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h"
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mmzone.h" 1

#define _LINUX_MMZONE_H 
# 17 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mmzone.h"
#define MAX_ORDER 10




#define ZONE_DMA 0
#define ZONE_NORMAL 1
#define ZONE_HIGHMEM 2
#define MAX_NR_ZONES 3

typedef struct free_area_struct {
        struct list_head free_list;
        unsigned long *map;
} free_area_t;

struct pglist_data;

typedef struct zone_watermarks_s {
        unsigned long min, low, high;
} zone_watermarks_t;
# 47 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mmzone.h"
typedef struct zone_struct {



        spinlock_t lock;
        unsigned long free_pages;







        zone_watermarks_t watermarks[3];







        unsigned long need_balance;

        unsigned long nr_active_pages, nr_inactive_pages;

        unsigned long nr_cache_pages;





        free_area_t free_area[10];
# 105 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mmzone.h"
        wait_queue_head_t * wait_table;
        unsigned long wait_table_size;
        unsigned long wait_table_shift;




        struct pglist_data *zone_pgdat;
        struct page *zone_mem_map;
        unsigned long zone_start_paddr;
        unsigned long zone_start_mapnr;




        char *name;
        unsigned long size;
        unsigned long realsize;
} zone_t;
# 136 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mmzone.h"
typedef struct zonelist_struct {
        zone_t * zones [3 +1];
} zonelist_t;

#define GFP_ZONEMASK 0x0f
# 153 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mmzone.h"
struct bootmem_data;
typedef struct pglist_data {
        zone_t node_zones[3];
        zonelist_t node_zonelists[0x0f +1];
        int nr_zones;
        struct page *node_mem_map;
        unsigned long *valid_addr_bitmap;
        struct bootmem_data *bdata;
        unsigned long node_start_paddr;
        unsigned long node_start_mapnr;
        unsigned long node_size;
        int node_id;
        struct pglist_data *node_next;
} pg_data_t;

extern int numnodes;
extern pg_data_t *pgdat_list;

#define zone_idx(zone) ((zone) - (zone)->zone_pgdat->node_zones)
#define memclass(pgzone,classzone) (zone_idx(pgzone) <= zone_idx(classzone))





struct page;
extern void show_free_areas_core(pg_data_t *pgdat);
extern void free_area_init_core(int nid, pg_data_t *pgdat, struct page **gmap,
  unsigned long *zones_size, unsigned long paddr, unsigned long *zholes_size,
  struct page *pmap);

extern pg_data_t contig_page_data;
# 197 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mmzone.h"
#define for_each_pgdat(pgdat) for (pgdat = pgdat_list; pgdat; pgdat = pgdat->node_next)







static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) zone_t *next_zone(zone_t *zone)
{
        pg_data_t *pgdat = zone->zone_pgdat;

        if (zone - pgdat->node_zones < 3 - 1)
                zone++;

        else if (pgdat->node_next) {
                pgdat = pgdat->node_next;
                zone = pgdat->node_zones;
        } else
                zone = ((void *)0);

        return zone;
}
# 236 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mmzone.h"
#define for_each_zone(zone) for(zone = pgdat_list->node_zones; zone; zone = next_zone(zone))





#define NODE_DATA(nid) (&contig_page_data)
#define NODE_MEM_MAP(nid) mem_map
#define MAX_NR_NODES 1
# 257 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mmzone.h"
#define MAP_ALIGN(x) ((((x) % sizeof(mem_map_t)) == 0) ? (x) : ((x) + sizeof(mem_map_t) - ((x) % sizeof(mem_map_t))))
# 13 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/swap.h" 1

#define _LINUX_SWAP_H 




#define SWAP_FLAG_PREFER 0x8000
#define SWAP_FLAG_PRIO_MASK 0x7fff
#define SWAP_FLAG_PRIO_SHIFT 0

#define MAX_SWAPFILES 32
# 25 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/swap.h"
union swap_header {
        struct
        {
                char reserved[(1L << 14) - 10];
                char magic[10];
        } magic;
        struct
        {
                char bootbits[1024];
                unsigned int version;
                unsigned int last_page;
                unsigned int nr_badpages;
                unsigned int padding[125];
                unsigned int badpages[1];
        } info;
};






#define __swapoffset(x) ((unsigned long)&((union swap_header *)0)->x)
#define MAX_SWAP_BADPAGES ((__swapoffset(magic.magic) - __swapoffset(info.badpages)) / sizeof(int))




#define SWP_USED 1
#define SWP_WRITEOK 3

#define SWAP_CLUSTER_MAX 32

#define SWAP_MAP_MAX 0x7fff
#define SWAP_MAP_BAD 0x8000




struct swap_info_struct {
        unsigned int flags;
        kdev_t swap_device;
        spinlock_t sdev_lock;
        struct dentry * swap_file;
        struct vfsmount *swap_vfsmnt;
        unsigned short * swap_map;
        unsigned int lowest_bit;
        unsigned int highest_bit;
        unsigned int cluster_next;
        unsigned int cluster_nr;
        int prio;
        int pages;
        unsigned long max;
        int next;
};

extern int nr_swap_pages;


#define vm_swap_full() (nr_swap_pages*2 < total_swap_pages)

extern unsigned int nr_free_pages(void);
extern unsigned int nr_free_buffer_pages(void);
extern unsigned int freeable_lowmem(void);
extern int nr_active_pages;
extern int nr_inactive_pages;
extern unsigned long page_cache_size;
extern atomic_t buffermem_pages;

extern spinlock_cacheline_t pagecache_lock_cacheline;
#define pagecache_lock (pagecache_lock_cacheline.lock)

extern void __remove_inode_page(struct page *);


struct task_struct;
struct vm_area_struct;
struct sysinfo;

struct zone_t;


extern void lru_cache_add(struct page *);
extern void __lru_cache_del(struct page *);
extern void lru_cache_del(struct page *);

extern void activate_page(struct page *);

extern void swap_setup(void);


extern wait_queue_head_t kswapd_wait;
extern int try_to_free_pages_zone(zone_t *, unsigned int);
extern int try_to_free_pages(unsigned int);
extern int vm_vfs_scan_ratio, vm_cache_scan_ratio, vm_lru_balance_ratio, vm_passes, vm_gfp_debug, vm_mapped_ratio, vm_anon_lru;


extern void rw_swap_page(int, struct page *);
extern void rw_swap_page_nolock(int, swp_entry_t, char *);




#define SWAP_CACHE_INFO 

extern void show_swap_cache_info(void);

extern int add_to_swap_cache(struct page *, swp_entry_t);
extern void __delete_from_swap_cache(struct page *page);
extern void delete_from_swap_cache(struct page *page);
extern void free_page_and_swap_cache(struct page *page);
extern struct page * lookup_swap_cache(swp_entry_t);
extern struct page * read_swap_cache_async(swp_entry_t);


extern void out_of_memory(void);


extern int total_swap_pages;
extern unsigned int nr_swapfiles;
extern struct swap_info_struct swap_info[];
extern int is_swap_partition(kdev_t);
extern void si_swapinfo(struct sysinfo *);
extern swp_entry_t get_swap_page(void);
extern void get_swaphandle_info(swp_entry_t, unsigned long *, kdev_t *,
                                        struct inode **);
extern int swap_duplicate(swp_entry_t);
extern int valid_swaphandles(swp_entry_t, unsigned long *);
extern void swap_free(swp_entry_t);
extern void free_swap_and_cache(swp_entry_t);
struct swap_list_t {
        int head;
        int next;
};
extern struct swap_list_t swap_list;
 long sys_swapoff(const char *);
 long sys_swapon(const char *, int);

extern spinlock_cacheline_t pagemap_lru_lock_cacheline;
#define pagemap_lru_lock pagemap_lru_lock_cacheline.lock

extern void mark_page_accessed(struct page *);





#define DEBUG_LRU_PAGE(page) do { if (!PageLRU(page)) BUG(); if (PageActive(page)) BUG(); } while (0)







extern void delta_nr_active_pages(struct page *page, long delta);
#define inc_nr_active_pages(page) delta_nr_active_pages(page, 1)
#define dec_nr_active_pages(page) delta_nr_active_pages(page, -1)

extern void delta_nr_inactive_pages(struct page *page, long delta);
#define inc_nr_inactive_pages(page) delta_nr_inactive_pages(page, 1)
#define dec_nr_inactive_pages(page) delta_nr_inactive_pages(page, -1)

#define add_page_to_active_list(page) do { DEBUG_LRU_PAGE(page); SetPageActive(page); list_add(&(page)->lru, &active_list); inc_nr_active_pages(page); } while (0)







#define add_page_to_inactive_list(page) do { DEBUG_LRU_PAGE(page); list_add(&(page)->lru, &inactive_list); inc_nr_inactive_pages(page); } while (0)






#define del_page_from_active_list(page) do { list_del(&(page)->lru); ClearPageActive(page); dec_nr_active_pages(page); } while (0)






#define del_page_from_inactive_list(page) do { list_del(&(page)->lru); dec_nr_inactive_pages(page); } while (0)





extern void delta_nr_cache_pages(struct page *page, long delta);
#define inc_nr_cache_pages(page) delta_nr_cache_pages(page, 1)
#define dec_nr_cache_pages(page) delta_nr_cache_pages(page, -1)

extern spinlock_t swaplock;

#define swap_list_lock() spin_lock(&swaplock)
#define swap_list_unlock() spin_unlock(&swaplock)
#define swap_device_lock(p) spin_lock(&p->sdev_lock)
#define swap_device_unlock(p) spin_unlock(&p->sdev_lock)

extern int shmem_unuse(swp_entry_t entry, struct page *page);
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h" 2


extern unsigned long max_mapnr;
extern unsigned long num_physpages;
extern unsigned long num_mappedpages;
extern void * high_memory;
extern int page_cluster;

extern struct list_head active_list;
extern struct list_head inactive_list;


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable.h"
#define _ASM_PGTABLE_H 
# 21 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable.h"
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/fixmap.h" 1
# 14 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/fixmap.h"
#define _ASM_FIXMAP_H 
# 49 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/fixmap.h"
enum fixed_addresses {




        __end_of_fixed_addresses
};

extern void __set_fixmap (enum fixed_addresses idx,
                                        unsigned long phys, pgprot_t flags);

#define set_fixmap(idx,phys) __set_fixmap(idx, phys, PAGE_KERNEL)




#define set_fixmap_nocache(idx,phys) __set_fixmap(idx, phys, PAGE_KERNEL_NOCACHE)
# 74 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/fixmap.h"
#define FIXADDR_TOP (0xffffe000UL)
#define FIXADDR_SIZE (__end_of_fixed_addresses << PAGE_SHIFT)
#define FIXADDR_START (FIXADDR_TOP - FIXADDR_SIZE)

#define __fix_to_virt(x) (FIXADDR_TOP - ((x) << PAGE_SHIFT))

extern void __this_fixmap_does_not_exist(void);






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long fix_to_virt(const unsigned int idx)
{
# 98 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/fixmap.h"
        if (idx >= __end_of_fixed_addresses)
                __this_fixmap_does_not_exist();

        return ((0xffffe000UL) - ((idx) << 14));
}
# 22 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable.h" 2






#define PG_dcache_dirty PG_arch_1

#define Page_dcache_dirty(page) test_bit(PG_dcache_dirty, &(page)->flags)

#define SetPageDcacheDirty(page) set_bit(PG_dcache_dirty, &(page)->flags)

#define ClearPageDcacheDirty(page) clear_bit(PG_dcache_dirty, &(page)->flags)





extern void add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
                               unsigned long entryhi, unsigned long pagemask);
# 50 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable.h"
extern int add_temporary_entry(unsigned long entrylo0, unsigned long entrylo1,
                               unsigned long entryhi, unsigned long pagemask);
# 68 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable.h"
#define PMD_SIZE (1UL << PMD_SHIFT)
#define PMD_MASK (~(PMD_SIZE-1))


#define PGDIR_SHIFT PMD_SHIFT
#define PGDIR_SIZE (1UL << PGDIR_SHIFT)
#define PGDIR_MASK (~(PGDIR_SIZE-1))

#define USER_PTRS_PER_PGD (0x80000000UL/PGDIR_SIZE)
#define FIRST_USER_PGD_NR 0

#define VMALLOC_START KSEG2
#define VMALLOC_VMADDR(x) ((unsigned long)(x))




#define VMALLOC_END (FIXADDR_START-2*PAGE_SIZE)


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable-bits.h" 1
# 11 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable-bits.h"
#define _ASM_PGTABLE_BITS_H 
# 64 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable-bits.h"
#define _PAGE_PRESENT (1<<0)
#define _PAGE_READ (1<<1)
#define _PAGE_WRITE (1<<2)
#define _PAGE_ACCESSED (1<<3)
#define _PAGE_MODIFIED (1<<4)
# 82 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable-bits.h"
#define _PAGE_R4KBUG (1<<5)
#define _PAGE_GLOBAL (1<<6)
#define _PAGE_VALID (1<<7)
#define _PAGE_SILENT_READ (1<<7)
#define _PAGE_DIRTY (1<<8)
#define _PAGE_SILENT_WRITE (1<<8)
#define _CACHE_MASK (7<<9)
# 102 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable-bits.h"
#define _CACHE_CACHABLE_NO_WA (0<<9)
#define _CACHE_CACHABLE_WA (1<<9)
#define _CACHE_UNCACHED (2<<9)
#define _CACHE_CACHABLE_NONCOHERENT (3<<9)
#define _CACHE_CACHABLE_CE (4<<9)
#define _CACHE_CACHABLE_COW (5<<9)
#define _CACHE_CACHABLE_CUW (6<<9)
#define _CACHE_UNCACHED_ACCELERATED (7<<9)





#define __READABLE (_PAGE_READ | _PAGE_SILENT_READ | _PAGE_ACCESSED)
#define __WRITEABLE (_PAGE_WRITE | _PAGE_SILENT_WRITE | _PAGE_MODIFIED)

#define _PAGE_CHG_MASK (PAGE_MASK | _PAGE_ACCESSED | _PAGE_MODIFIED | _CACHE_MASK)




#define PAGE_CACHABLE_DEFAULT _CACHE_CACHABLE_NONCOHERENT







#define CONF_CM_DEFAULT (PAGE_CACHABLE_DEFAULT >> 9)
# 89 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable.h" 2

#define PAGE_NONE __pgprot(_PAGE_PRESENT | _CACHE_CACHABLE_NONCOHERENT)
#define PAGE_SHARED __pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_WRITE | PAGE_CACHABLE_DEFAULT)

#define PAGE_COPY __pgprot(_PAGE_PRESENT | _PAGE_READ | PAGE_CACHABLE_DEFAULT)

#define PAGE_READONLY __pgprot(_PAGE_PRESENT | _PAGE_READ | PAGE_CACHABLE_DEFAULT)

#define PAGE_KERNEL __pgprot(_PAGE_PRESENT | __READABLE | __WRITEABLE | _PAGE_GLOBAL | PAGE_CACHABLE_DEFAULT)

#define PAGE_USERIO __pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_WRITE | PAGE_CACHABLE_DEFAULT)

#define PAGE_KERNEL_UNCACHED __pgprot(_PAGE_PRESENT | __READABLE | __WRITEABLE | _PAGE_GLOBAL | _CACHE_UNCACHED)







#define __P000 PAGE_NONE
#define __P001 PAGE_READONLY
#define __P010 PAGE_COPY
#define __P011 PAGE_COPY
#define __P100 PAGE_READONLY
#define __P101 PAGE_READONLY
#define __P110 PAGE_COPY
#define __P111 PAGE_COPY

#define __S000 PAGE_NONE
#define __S001 PAGE_READONLY
#define __S010 PAGE_SHARED
#define __S011 PAGE_SHARED
#define __S100 PAGE_READONLY
#define __S101 PAGE_READONLY
#define __S110 PAGE_SHARED
#define __S111 PAGE_SHARED




# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable-32.h" 1

#define _MIPS_PGTABLE_32_H 
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable-32.h"
#define PGD_ORDER 0
#define PTE_ORDER 0


#define PMD_SHIFT (2 * PAGE_SHIFT - PTE_T_LOG2)






#define pte_ERROR(e) printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, (e).pte_low)


#define pmd_ERROR(e) printk("%s:%d: bad pmd %08lx.\n", __FILE__, __LINE__, pmd_val(e))

#define pgd_ERROR(e) printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pte_none(pte_t pte) { return !(((pte).pte_low) & ~(1<<6)); }

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t pte_wrprotect(pte_t pte)
{
        ((pte).pte_low) &= ~((1<<2) | (1<<8));
        return pte;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t pte_rdprotect(pte_t pte)
{
        ((pte).pte_low) &= ~((1<<1) | (1<<7));
        return pte;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t pte_mkclean(pte_t pte)
{
        ((pte).pte_low) &= ~((1<<4)|(1<<8));
        return pte;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t pte_mkold(pte_t pte)
{
        ((pte).pte_low) &= ~((1<<3)|(1<<7));
        return pte;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t pte_mkwrite(pte_t pte)
{
        ((pte).pte_low) |= (1<<2);
        if (((pte).pte_low) & (1<<4))
                ((pte).pte_low) |= (1<<8);
        return pte;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t pte_mkread(pte_t pte)
{
        ((pte).pte_low) |= (1<<1);
        if (((pte).pte_low) & (1<<3))
                ((pte).pte_low) |= (1<<7);
        return pte;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t pte_mkdirty(pte_t pte)
{
        ((pte).pte_low) |= (1<<4);
        if (((pte).pte_low) & (1<<2))
                ((pte).pte_low) |= (1<<8);
        return pte;
}







#define pgprot_noncached pgprot_noncached

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pgprot_t pgprot_noncached(pgprot_t _prot)
{
        unsigned long prot = ((_prot).pgprot);

        prot = (prot & ~(7<<9)) | (2<<9);

        return ((pgprot_t) { (prot) } );
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t pte_mkyoung(pte_t pte)
{
        ((pte).pte_low) |= (1<<3);
        if (((pte).pte_low) & (1<<1))
                ((pte).pte_low) |= (1<<7);
        return pte;
}
# 122 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable-32.h"
#define mk_pte(page,pgprot) ({ pte_t __pte; pte_val(__pte) = ((phys_t)(page - mem_map) << PAGE_SHIFT) | pgprot_val(pgprot); __pte; })
# 133 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable-32.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t mk_pte_phys(phys_t physpage, pgprot_t pgprot)
{



        return ((pte_t) { (physpage | ((pgprot).pgprot)) } );

}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t pte_modify(pte_t pte, pgprot_t newprot)
{
        return ((pte_t) { ((((pte).pte_low) & ((~((1L << 14)-1)) | (1<<3) | (1<<4) | (7<<9))) | ((newprot).pgprot)) } );
}





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void set_pte(pte_t *ptep, pte_t pteval)
{
        *ptep = pteval;

        if (((pteval).pte_low) & (1<<6)) {
                pte_t *buddy = ((pte_t *)((unsigned long)(ptep) ^ sizeof(pte_t)));




                if (pte_none(*buddy))
                        ((*buddy).pte_low) = ((*buddy).pte_low) | (1<<6);
        }

}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pte_clear(pte_t *ptep)
{


        if (((*((pte_t *)((unsigned long)(ptep) ^ sizeof(pte_t)))).pte_low) & (1<<6))
                set_pte(ptep, ((pte_t) { ((1<<6)) } ));
        else

                set_pte(ptep, ((pte_t) { (0) } ));
}





#define pte_page(x) (mem_map+((unsigned long)(((x).pte_low >> PAGE_SHIFT))))
#define __mk_pte(page_nr,pgprot) __pte(((page_nr) << PAGE_SHIFT) | pgprot_val(pgprot))
# 131 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable.h" 2




extern unsigned long empty_zero_page;
extern unsigned long zero_page_mask;

#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page + (((unsigned long)(vaddr)) & zero_page_mask)))


extern void load_pgd(unsigned long pg_dir);

extern pmd_t invalid_pte_table[(1L << 14)/sizeof(pmd_t)];





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long pmd_page(pmd_t pmd)
{
        return ((pmd).pmd);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pmd_set(pmd_t * pmdp, pte_t * ptep)
{
        ((*pmdp).pmd) = (((unsigned long) ptep) & (~((1L << 14)-1)));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pte_present(pte_t pte) { return ((pte).pte_low) & (1<<0); }





#define set_pmd(pmdptr,pmdval) (*(pmdptr) = pmdval)
#define set_pgd(pgdptr,pgdval) (*(pgdptr) = pgdval)




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pmd_none(pmd_t pmd)
{
        return ((pmd).pmd) == (unsigned long) invalid_pte_table;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pmd_bad(pmd_t pmd)
{
        return ((pmd_page(pmd) > (unsigned long) high_memory) ||
                (pmd_page(pmd) < 0x80000000UL));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pmd_present(pmd_t pmd)
{
        return (((pmd).pmd) != (unsigned long) invalid_pte_table);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pmd_clear(pmd_t *pmdp)
{
        ((*pmdp).pmd) = ((unsigned long) invalid_pte_table);
}






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pgd_none(pgd_t pgd) { return 0; }
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pgd_bad(pgd_t pgd) { return 0; }
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pgd_present(pgd_t pgd) { return 1; }
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pgd_clear(pgd_t *pgdp) { }






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pte_read(pte_t pte) { return (pte).pte_low & (1<<1); }
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pte_write(pte_t pte) { return (pte).pte_low & (1<<2); }
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pte_dirty(pte_t pte) { return (pte).pte_low & (1<<4); }
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pte_young(pte_t pte) { return (pte).pte_low & (1<<3); }





#define set_pmd(pmdptr,pmdval) (*(pmdptr) = pmdval)
#define set_pgd(pgdptr,pgdval) (*(pgdptr) = pgdval)

#define PGD_T_LOG2 ffz(~sizeof(pgd_t))
#define PMD_T_LOG2 ffz(~sizeof(pmd_t))
#define PTE_T_LOG2 ffz(~sizeof(pte_t))

#define PTRS_PER_PGD ((PAGE_SIZE << PGD_ORDER) / sizeof(pgd_t))
#define PTRS_PER_PMD 1
#define PTRS_PER_PTE ((PAGE_SIZE << PTE_ORDER) / sizeof(pte_t))

#define page_pte(page) page_pte_prot(page, __pgprot(0))

#define __pgd_offset(address) pgd_index(address)
#define __pmd_offset(address) (((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))



#define pgd_offset_k(address) pgd_offset(&init_mm, address)

#define pgd_index(address) ((address) >> PGDIR_SHIFT)


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pgd_t *pgd_offset(struct mm_struct *mm, unsigned long address)
{
        return mm->pgd + ((address) >> (2 * 14 - ffz(~sizeof(pte_t))));
}


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pmd_t *pmd_offset(pgd_t *dir, unsigned long address)
{
        return (pmd_t *) dir;
}


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t *pte_offset(pmd_t * dir, unsigned long address)
{
        return (pte_t *) (pmd_page(*dir)) +
               ((address >> 14) & ((((1L << 14) << 0) / sizeof(pte_t)) - 1));
}

extern int do_check_pgt_cache(int, int);

extern pgd_t swapper_pg_dir[(((1L << 14) << 0) / sizeof(pgd_t))];
extern void paging_init(void);

extern void __update_tlb(struct vm_area_struct *vma, unsigned long address,
        pte_t pte);
extern void __update_cache(struct vm_area_struct *vma, unsigned long address,
        pte_t pte);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void update_mmu_cache(struct vm_area_struct *vma,
        unsigned long address, pte_t pte)
{
        __update_tlb(vma, address, pte);
        __update_cache(vma, address, pte);
}
# 282 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable.h"
#define SWP_TYPE(x) (((x).val >> 1) & 0x1f)
#define SWP_OFFSET(x) ((x).val >> 8)
#define SWP_ENTRY(type,offset) ((swp_entry_t) { ((type) << 1) | ((offset) << 8) })


#define pte_to_swp_entry(pte) ((swp_entry_t) { (pte).pte_low })
#define swp_entry_to_pte(x) ((pte_t) { (x).val })



#define PageSkip(page) (0)
#define kern_addr_valid(addr) (1)

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm-generic/pgtable.h" 1

#define _ASM_GENERIC_PGTABLE_H 

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int ptep_test_and_clear_young(pte_t *ptep)
{
        pte_t pte = *ptep;
        if (!pte_young(pte))
                return 0;
        set_pte(ptep, pte_mkold(pte));
        return 1;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int ptep_test_and_clear_dirty(pte_t *ptep)
{
        pte_t pte = *ptep;
        if (!pte_dirty(pte))
                return 0;
        set_pte(ptep, pte_mkclean(pte));
        return 1;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t ptep_get_and_clear(pte_t *ptep)
{
        pte_t pte = *ptep;
        pte_clear(ptep);
        return pte;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void ptep_set_wrprotect(pte_t *ptep)
{
        pte_t old_pte = *ptep;
        set_pte(ptep, pte_wrprotect(old_pte));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void ptep_mkdirty(pte_t *ptep)
{
        pte_t old_pte = *ptep;
        set_pte(ptep, pte_mkdirty(old_pte));
}

#define pte_same(A,B) (pte_val(A) == pte_val(B))
# 296 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgtable.h" 2







#define HAVE_ARCH_UNMAPPED_AREA 




#define io_remap_page_range remap_page_range





#define pgtable_cache_init() do { } while (0)
# 27 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h" 2
# 44 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h"
struct vm_area_struct {
        struct mm_struct * vm_mm;
        unsigned long vm_start;
        unsigned long vm_end;



        struct vm_area_struct *vm_next;

        pgprot_t vm_page_prot;
        unsigned long vm_flags;

        rb_node_t vm_rb;






        struct vm_area_struct *vm_next_share;
        struct vm_area_struct **vm_pprev_share;


        struct vm_operations_struct * vm_ops;


        unsigned long vm_pgoff;

        struct file * vm_file;
        unsigned long vm_raend;
        void * vm_private_data;
};




#define VM_READ 0x00000001
#define VM_WRITE 0x00000002
#define VM_EXEC 0x00000004
#define VM_SHARED 0x00000008

#define VM_MAYREAD 0x00000010
#define VM_MAYWRITE 0x00000020
#define VM_MAYEXEC 0x00000040
#define VM_MAYSHARE 0x00000080

#define VM_GROWSDOWN 0x00000100
#define VM_GROWSUP 0x00000200
#define VM_SHM 0x00000400
#define VM_DENYWRITE 0x00000800

#define VM_EXECUTABLE 0x00001000
#define VM_LOCKED 0x00002000
#define VM_IO 0x00004000


#define VM_SEQ_READ 0x00008000
#define VM_RAND_READ 0x00010000

#define VM_DONTCOPY 0x00020000
#define VM_DONTEXPAND 0x00040000
#define VM_RESERVED 0x00080000


#define VM_STACK_FLAGS 0x00000177


#define VM_READHINTMASK (VM_SEQ_READ | VM_RAND_READ)
#define VM_ClearReadHint(v) (v)->vm_flags &= ~VM_READHINTMASK
#define VM_NormalReadHint(v) (!((v)->vm_flags & VM_READHINTMASK))
#define VM_SequentialReadHint(v) ((v)->vm_flags & VM_SEQ_READ)
#define VM_RandomReadHint(v) ((v)->vm_flags & VM_RAND_READ)


extern int vm_min_readahead;
extern int vm_max_readahead;
extern unsigned long mmap_min_addr;





extern pgprot_t protection_map[16];







struct vm_operations_struct {
        void (*open)(struct vm_area_struct * area);
        void (*close)(struct vm_area_struct * area);
        struct page * (*nopage)(struct vm_area_struct * area, unsigned long address, int unused);
};
# 155 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h"
typedef struct page {
        struct list_head list;
        struct address_space *mapping;
        unsigned long index;
        struct page *next_hash;

        atomic_t count;
        unsigned long flags;

        struct list_head lru;

        struct page **pprev_hash;
        struct buffer_head * buffers;
# 183 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h"
} mem_map_t;
# 197 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h"
#define get_page(p) atomic_inc(&(p)->count)
#define put_page(p) __free_page(p)
#define put_page_testzero(p) atomic_dec_and_test(&(p)->count)
#define page_count(p) atomic_read(&(p)->count)
#define set_page_count(p,v) atomic_set(&(p)->count, v)

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct page *nth_page(struct page *page, int n)
{
        return page + n;
}
# 293 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h"
#define PG_locked 0
#define PG_error 1
#define PG_referenced 2
#define PG_uptodate 3
#define PG_dirty 4
#define PG_unused 5
#define PG_lru 6
#define PG_active 7
#define PG_slab 8
#define PG_skip 10
#define PG_highmem 11
#define PG_checked 12
#define PG_arch_1 13
#define PG_reserved 14
#define PG_launder 15
#define PG_fs_1 16


#define arch_set_page_uptodate(page) 



#define UnlockPage(page) unlock_page(page)
#define Page_Uptodate(page) test_bit(PG_uptodate, &(page)->flags)

#define SetPageUptodate(page) set_bit(PG_uptodate, &(page)->flags)

#define ClearPageUptodate(page) clear_bit(PG_uptodate, &(page)->flags)
#define PageDirty(page) test_bit(PG_dirty, &(page)->flags)
#define SetPageDirty(page) set_bit(PG_dirty, &(page)->flags)
#define ClearPageDirty(page) clear_bit(PG_dirty, &(page)->flags)
#define PageLocked(page) test_bit(PG_locked, &(page)->flags)
#define LockPage(page) set_bit(PG_locked, &(page)->flags)
#define TryLockPage(page) test_and_set_bit(PG_locked, &(page)->flags)
#define PageChecked(page) test_bit(PG_checked, &(page)->flags)
#define SetPageChecked(page) set_bit(PG_checked, &(page)->flags)
#define ClearPageChecked(page) clear_bit(PG_checked, &(page)->flags)
#define PageLaunder(page) test_bit(PG_launder, &(page)->flags)
#define SetPageLaunder(page) set_bit(PG_launder, &(page)->flags)
#define ClearPageLaunder(page) clear_bit(PG_launder, &(page)->flags)
#define ClearPageArch1(page) clear_bit(PG_arch_1, &(page)->flags)





#define NODE_SHIFT 4
#define ZONE_SHIFT (BITS_PER_LONG - 8)

struct zone_struct;
extern struct zone_struct *zone_table[];

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) zone_t *page_zone(struct page *page)
{
        return zone_table[page->flags >> (32 - 8)];
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void set_page_zone(struct page *page, unsigned long zone_num)
{
        page->flags &= ~(~0UL << (32 - 8));
        page->flags |= zone_num << (32 - 8);
}
# 370 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h"
#define set_page_address(page,address) do { } while(0)
# 383 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/mm.h"
#define page_address(page) __va( (((page) - page_zone(page)->zone_mem_map) << PAGE_SHIFT) + page_zone(page)->zone_start_paddr)





extern void set_page_dirty(struct page *);







#define PageError(page) test_bit(PG_error, &(page)->flags)
#define SetPageError(page) set_bit(PG_error, &(page)->flags)
#define ClearPageError(page) clear_bit(PG_error, &(page)->flags)
#define PageReferenced(page) test_bit(PG_referenced, &(page)->flags)
#define SetPageReferenced(page) set_bit(PG_referenced, &(page)->flags)
#define ClearPageReferenced(page) clear_bit(PG_referenced, &(page)->flags)
#define PageTestandClearReferenced(page) test_and_clear_bit(PG_referenced, &(page)->flags)
#define PageSlab(page) test_bit(PG_slab, &(page)->flags)
#define PageSetSlab(page) set_bit(PG_slab, &(page)->flags)
#define PageClearSlab(page) clear_bit(PG_slab, &(page)->flags)
#define PageReserved(page) test_bit(PG_reserved, &(page)->flags)

#define PageActive(page) test_bit(PG_active, &(page)->flags)
#define SetPageActive(page) set_bit(PG_active, &(page)->flags)
#define ClearPageActive(page) clear_bit(PG_active, &(page)->flags)

#define PageLRU(page) test_bit(PG_lru, &(page)->flags)
#define TestSetPageLRU(page) test_and_set_bit(PG_lru, &(page)->flags)
#define TestClearPageLRU(page) test_and_clear_bit(PG_lru, &(page)->flags)




#define PageHighMem(page) 0


#define SetPageReserved(page) set_bit(PG_reserved, &(page)->flags)
#define ClearPageReserved(page) clear_bit(PG_reserved, &(page)->flags)




#define NOPAGE_SIGBUS (NULL)
#define NOPAGE_OOM ((struct page *) (-1))


extern mem_map_t * mem_map;







extern struct page * _alloc_pages(unsigned int gfp_mask, unsigned int order);
extern struct page * __alloc_pages(unsigned int gfp_mask, unsigned int order, zonelist_t *zonelist);
extern struct page * alloc_pages_node(int nid, unsigned int gfp_mask, unsigned int order);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct page * alloc_pages(unsigned int gfp_mask, unsigned int order)
{



        if (order >= 10)
                return ((void *)0);
        return _alloc_pages(gfp_mask, order);
}

#define alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)

extern unsigned long __get_free_pages(unsigned int gfp_mask, unsigned int order);
extern unsigned long get_zeroed_page(unsigned int gfp_mask);

#define __get_free_page(gfp_mask) __get_free_pages((gfp_mask),0)


#define __get_dma_pages(gfp_mask,order) __get_free_pages((gfp_mask) | GFP_DMA,(order))





#define get_free_page get_zeroed_page




extern void __free_pages(struct page *page, unsigned int order);
extern void free_pages(unsigned long addr, unsigned int order);

#define __free_page(page) __free_pages((page), 0)
#define free_page(addr) free_pages((addr),0)

extern void show_free_areas(void);
extern void show_free_areas_node(pg_data_t *pgdat);

extern void clear_page_tables(struct mm_struct *, unsigned long, int);

extern int fail_writepage(struct page *);
struct page * shmem_nopage(struct vm_area_struct * vma, unsigned long address, int unused);
struct file *shmem_file_setup(char * name, loff_t size);
extern void shmem_lock(struct file * file, int lock);
extern int shmem_zero_setup(struct vm_area_struct *);

extern void zap_page_range(struct mm_struct *mm, unsigned long address, unsigned long size);
extern int copy_page_range(struct mm_struct *dst, struct mm_struct *src, struct vm_area_struct *vma);
extern int remap_page_range(unsigned long from, unsigned long to, unsigned long size, pgprot_t prot);
extern int zeromap_page_range(unsigned long from, unsigned long size, pgprot_t prot);

extern int vmtruncate(struct inode * inode, loff_t offset);
extern pmd_t *__pmd_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address);
extern pte_t *pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address);
extern int handle_mm_fault(struct mm_struct *mm,struct vm_area_struct *vma, unsigned long address, int write_access);
extern int make_pages_present(unsigned long addr, unsigned long end);
extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);
extern int ptrace_readdata(struct task_struct *tsk, unsigned long src, char *dst, int len);
extern int ptrace_writedata(struct task_struct *tsk, char * src, unsigned long dst, int len);
extern int ptrace_attach(struct task_struct *tsk);
extern int ptrace_detach(struct task_struct *, unsigned int);
extern void ptrace_disable(struct task_struct *);
extern int ptrace_check_attach(struct task_struct *task, int kill);

int get_user_pages(struct task_struct *tsk, struct mm_struct *mm, unsigned long start,
                int len, int write, int force, struct page **pages, struct vm_area_struct **vmas);






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pmd_t *pmd_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)
{
        if (pgd_none(*pgd))
                return __pmd_alloc(mm, pgd, address);
        return pmd_offset(pgd, address);
}

extern int pgt_cache_water[2];
extern int check_pgt_cache(void);

extern void free_area_init(unsigned long * zones_size);
extern void free_area_init_node(int nid, pg_data_t *pgdat, struct page *pmap,
        unsigned long * zones_size, unsigned long zone_start_paddr,
        unsigned long *zholes_size);
extern void mem_init(void);
extern void show_mem(void);
extern void si_meminfo(struct sysinfo * val);
extern void swapin_readahead(swp_entry_t);

extern struct address_space swapper_space;
#define PageSwapCache(page) ((page)->mapping == &swapper_space)

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int is_page_cache_freeable(struct page * page)
{
        return ((&(page)->count)->counter) - !!page->buffers == 1;
}

extern int can_share_swap_page(struct page *);
extern int remove_exclusive_swap_page(struct page *);

extern void __free_pte(pte_t);


extern void lock_vma_mappings(struct vm_area_struct *);
extern void unlock_vma_mappings(struct vm_area_struct *);
extern int insert_vm_struct(struct mm_struct *, struct vm_area_struct *);
extern void __insert_vm_struct(struct mm_struct *, struct vm_area_struct *);
extern void build_mmap_rb(struct mm_struct *);
extern void exit_mmap(struct mm_struct *);

extern unsigned long get_unmapped_area(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);

extern unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,
        unsigned long len, unsigned long prot,
        unsigned long flag, unsigned long pgoff);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long do_mmap(struct file *file, unsigned long addr,
        unsigned long len, unsigned long prot,
        unsigned long flag, unsigned long offset)
{
        unsigned long ret = -22;
        if ((offset + (((len) + (1L << 14) - 1) & (~((1L << 14)-1)))) < offset)
                goto out;
        if (!(offset & ~(~((1L << 14)-1))))
                ret = do_mmap_pgoff(file, addr, len, prot, flag, offset >> 14);
out:
        return ret;
}

extern int do_munmap(struct mm_struct *, unsigned long, size_t);

extern unsigned long do_brk(unsigned long, unsigned long);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __vma_unlink(struct mm_struct * mm, struct vm_area_struct * vma, struct vm_area_struct * prev)
{
        prev->vm_next = vma->vm_next;
        rb_erase(&vma->vm_rb, &mm->mm_rb);
        if (mm->mmap_cache == vma)
                mm->mmap_cache = prev;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int can_vma_merge(struct vm_area_struct * vma, unsigned long vm_flags)
{
        if (!vma->vm_file && vma->vm_flags == vm_flags)
                return 1;
        else
                return 0;
}

struct zone_t;

extern void remove_inode_page(struct page *);
extern unsigned long page_unuse(struct page *);
extern void truncate_inode_pages(struct address_space *, loff_t);


extern int filemap_sync(struct vm_area_struct *, unsigned long, size_t, unsigned int);
extern struct page *filemap_nopage(struct vm_area_struct *, unsigned long, int);





#define __GFP_DMA 0x01
#define __GFP_HIGHMEM 0x02


#define __GFP_WAIT 0x10
#define __GFP_HIGH 0x20
#define __GFP_IO 0x40
#define __GFP_HIGHIO 0x80
#define __GFP_FS 0x100

#define GFP_NOHIGHIO (__GFP_HIGH | __GFP_WAIT | __GFP_IO)
#define GFP_NOIO (__GFP_HIGH | __GFP_WAIT)
#define GFP_NOFS (__GFP_HIGH | __GFP_WAIT | __GFP_IO | __GFP_HIGHIO)
#define GFP_ATOMIC (__GFP_HIGH)
#define GFP_USER ( __GFP_WAIT | __GFP_IO | __GFP_HIGHIO | __GFP_FS)
#define GFP_HIGHUSER ( __GFP_WAIT | __GFP_IO | __GFP_HIGHIO | __GFP_FS | __GFP_HIGHMEM)
#define GFP_KERNEL (__GFP_HIGH | __GFP_WAIT | __GFP_IO | __GFP_HIGHIO | __GFP_FS)
#define GFP_NFS (__GFP_HIGH | __GFP_WAIT | __GFP_IO | __GFP_HIGHIO | __GFP_FS)
#define GFP_KSWAPD ( __GFP_WAIT | __GFP_IO | __GFP_HIGHIO | __GFP_FS)




#define GFP_DMA __GFP_DMA

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int pf_gfp_mask(unsigned int gfp_mask)
{

        if (current->flags & 0x00004000)
                gfp_mask &= ~(0x40 | 0x80 | 0x100);

        return gfp_mask;
}



static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int expand_stack(struct vm_area_struct * vma, unsigned long address)
{
        unsigned long grow;






        address &= (~((1L << 14)-1));


        if (address < mmap_min_addr && !capable(17))
                return -1;

        (void)(&vma->vm_mm->page_table_lock);


        if (vma->vm_start <= address) {
                do { } while(0);
                return 0;
        }

        grow = (vma->vm_start - address) >> 14;
        if (vma->vm_end - address > current->rlim[3].rlim_cur ||
            ((vma->vm_mm->total_vm + grow) << 14) > current->rlim[6].rlim_cur) {
                do { } while(0);
                return -12;
        }

        if ((vma->vm_flags & 0x00002000) &&
            ((vma->vm_mm->locked_vm + grow) << 14) > current->rlim[9].rlim_cur) {
                do { } while(0);
                return -12;
        }


        vma->vm_start = address;
        vma->vm_pgoff -= grow;
        vma->vm_mm->total_vm += grow;
        if (vma->vm_flags & 0x00002000)
                vma->vm_mm->locked_vm += grow;
        do { } while(0);
        return 0;
}


extern struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr);
extern struct vm_area_struct * find_vma_prev(struct mm_struct * mm, unsigned long addr,
                                             struct vm_area_struct **pprev);



static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)
{
        struct vm_area_struct * vma = find_vma(mm,start_addr);

        if (vma && end_addr <= vma->vm_start)
                vma = ((void *)0);
        return vma;
}

extern struct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr);

extern struct page * vmalloc_to_page(void *addr);
# 205 "drivers/char/serial.c" 2
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/slab.h" 1







#define _LINUX_SLAB_H 



typedef struct kmem_cache_s kmem_cache_t;





#define SLAB_NOFS GFP_NOFS
#define SLAB_NOIO GFP_NOIO
#define SLAB_NOHIGHIO GFP_NOHIGHIO
#define SLAB_ATOMIC GFP_ATOMIC
#define SLAB_USER GFP_USER
#define SLAB_KERNEL GFP_KERNEL
#define SLAB_NFS GFP_NFS
#define SLAB_DMA GFP_DMA

#define SLAB_LEVEL_MASK (__GFP_WAIT|__GFP_HIGH|__GFP_IO|__GFP_HIGHIO|__GFP_FS)
#define SLAB_NO_GROW 0x00001000UL





#define SLAB_DEBUG_FREE 0x00000100UL
#define SLAB_DEBUG_INITIAL 0x00000200UL
#define SLAB_RED_ZONE 0x00000400UL
#define SLAB_POISON 0x00000800UL
#define SLAB_NO_REAP 0x00001000UL
#define SLAB_HWCACHE_ALIGN 0x00002000UL
#define SLAB_CACHE_DMA 0x00004000UL
#define SLAB_MUST_HWCACHE_ALIGN 0x00008000UL


#define SLAB_CTOR_CONSTRUCTOR 0x001UL
#define SLAB_CTOR_ATOMIC 0x002UL
#define SLAB_CTOR_VERIFY 0x004UL


extern void kmem_cache_init(void);
extern void kmem_cache_sizes_init(void);

extern kmem_cache_t *kmem_find_general_cachep(size_t, int gfpflags);
extern kmem_cache_t *kmem_cache_create(const char *, size_t, size_t, unsigned long,
                                       void (*)(void *, kmem_cache_t *, unsigned long),
                                       void (*)(void *, kmem_cache_t *, unsigned long));
extern int kmem_cache_destroy(kmem_cache_t *);
extern int kmem_cache_shrink(kmem_cache_t *);
extern void *kmem_cache_alloc(kmem_cache_t *, int);
extern void kmem_cache_free(kmem_cache_t *, void *);
extern unsigned int kmem_cache_size(kmem_cache_t *);

extern void *kmalloc(size_t, int);
extern void kfree(const void *);

extern int kmem_cache_reap(int);


extern kmem_cache_t *vm_area_cachep;
extern kmem_cache_t *mm_cachep;
extern kmem_cache_t *names_cachep;
extern kmem_cache_t *files_cachep;
extern kmem_cache_t *filp_cachep;
extern kmem_cache_t *dquot_cachep;
extern kmem_cache_t *bh_cachep;
extern kmem_cache_t *fs_cachep;
extern kmem_cache_t *sigact_cachep;
# 206 "drivers/char/serial.c" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/init.h" 1

#define _LINUX_INIT_H 
# 49 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/init.h"
typedef int (*initcall_t)(void);
typedef void (*exitcall_t)(void);

extern initcall_t __initcall_start, __initcall_end;

#define __initcall(fn) static initcall_t __initcall_ ##fn __attribute_used__ __init_call = fn

#define __exitcall(fn) static exitcall_t __exitcall_ ##fn __exit_call = fn





struct kernel_param {
        const char *str;
        int (*setup_func)(char *);
};

extern struct kernel_param __setup_start, __setup_end;

#define __setup(str,fn) static char __setup_str_ ##fn[] __initdata = str; static struct kernel_param __setup_ ##fn __attribute_used__ __initsetup = { __setup_str_ ##fn, fn }
# 79 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/init.h"
#define __init __attribute__ ((__section__ (".text.init")))
#define __exit __attribute_used__ __attribute__ (( __section__(".text.exit")))
#define __initdata __attribute__ ((__section__ (".data.init")))
#define __exitdata __attribute_used__ __attribute__ ((__section__ (".data.exit")))
#define __initsetup __attribute_used__ __attribute__ ((__section__ (".setup.init")))
#define __init_call __attribute_used__ __attribute__ ((__section__ (".initcall.init")))
#define __exit_call __attribute_used__ __attribute__ ((__section__ (".exitcall.exit")))


#define __INIT .section ".text.init","ax"
#define __FINIT .previous
#define __INITDATA .section ".data.init","aw"
# 102 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/init.h"
#define module_init(x) __initcall(x);
# 113 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/init.h"
#define module_exit(x) __exitcall(x);
# 148 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/init.h"
#define __devinit 
#define __devinitdata 
#define __devexit 
#define __devexitdata 
# 166 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/init.h"
#define __devexit_p(x) x
# 208 "drivers/char/serial.c" 2


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define _ASM_UACCESS_H 
# 26 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __UA_LIMIT 0x80000000UL

#define __UA_ADDR ".word"
#define __UA_LA "la"
#define __UA_ADDU "addu"
#define __UA_t0 "$8"
#define __UA_t1 "$9"
# 56 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define KERNEL_DS ((mm_segment_t) { 0UL })
#define USER_DS ((mm_segment_t) { __UA_LIMIT })

#define VERIFY_READ 0
#define VERIFY_WRITE 1

#define get_ds() (KERNEL_DS)
#define get_fs() (current->thread.current_ds)
#define set_fs(x) (current->thread.current_ds = (x))

#define segment_eq(a,b) ((a).seg == (b).seg)
# 82 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __ua_size(size) ((__builtin_constant_p(size) && (signed long) (size) > 0) ? 0 : (size))
# 105 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __access_mask get_fs().seg

#define __access_ok(addr,size,mask) (((signed long)((mask) & ((addr) | ((addr) + (size)) | __ua_size(size)))) == 0)


#define access_ok(type,addr,size) likely(__access_ok((unsigned long)(addr), (size),__access_mask))
# 130 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int verify_area(int type, const void * addr, unsigned long size)
{
        return __builtin_expect(((((signed long)(((current->thread.current_ds).seg) & (((unsigned long)(addr)) | (((unsigned long)(addr)) + ((size))) | ((__builtin_constant_p((size)) && (signed long) ((size)) > 0) ? 0 : ((size)))))) == 0)),1) ? 0 : -14;
}
# 151 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define put_user(x,ptr) __put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
# 171 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define get_user(x,ptr) __get_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
# 193 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __put_user(x,ptr) __put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
# 216 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __get_user(x,ptr) __get_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))


struct __large_struct { unsigned long buf[100]; };
#define __m(x) (*(struct __large_struct *)(x))
# 229 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __GET_USER_DW(__gu_err) __get_user_asm_ll32(__gu_err)


#define __get_user_nocheck(x,ptr,size) ({ long __gu_err = 0; __typeof(*(ptr)) __gu_val = 0; long __gu_addr; __gu_addr = (long) (ptr); switch (size) { case 1: __get_user_asm("lb", __gu_err); break; case 2: __get_user_asm("lh", __gu_err); break; case 4: __get_user_asm("lw", __gu_err); break; case 8: __GET_USER_DW(__gu_err); break; default: __get_user_unknown(); break; } x = (__typeof__(*(ptr))) __gu_val; __gu_err; })
# 249 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __get_user_check(x,ptr,size) ({ __typeof__(*(ptr)) __gu_val = 0; long __gu_addr = (long) (ptr); long __gu_err; __gu_err = verify_area(VERIFY_READ, (void *) __gu_addr, size); if (likely(!__gu_err)) { switch (size) { case 1: __get_user_asm("lb", __gu_err); break; case 2: __get_user_asm("lh", __gu_err); break; case 4: __get_user_asm("lw", __gu_err); break; case 8: __GET_USER_DW(__gu_err); break; default: __get_user_unknown(); break; } } x = (__typeof__(*(ptr))) __gu_val; __gu_err; })
# 270 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __get_user_asm(insn,__gu_err) ({ __asm__ __volatile__( "1:	" insn "	%1, %3				\n" "2:							\n" "	.section .fixup,\"ax\"				\n" "3:	li	%0, %4					\n" "	j	2b					\n" "	.previous					\n" "	.section __ex_table,\"a\"			\n" "	"__UA_ADDR "\t1b, 3b				\n" "	.previous					\n" : "=r" (__gu_err), "=r" (__gu_val) : "0" (__gu_err), "o" (__m(__gu_addr)), "i" (-EFAULT)); })
# 289 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __get_user_asm_ll32(__gu_err) ({ __asm__ __volatile__( "1:	lw	%1, %3					\n" "2:	lw	%D1, %4					\n" "	move	%0, $0					\n" "3:	.section	.fixup,\"ax\"			\n" "4:	li	%0, %5					\n" "	move	%1, $0					\n" "	move	%D1, $0					\n" "	j	3b					\n" "	.previous					\n" "	.section	__ex_table,\"a\"		\n" "	" __UA_ADDR "	1b, 4b				\n" "	" __UA_ADDR "	2b, 4b				\n" "	.previous					\n" : "=r" (__gu_err), "=&r" (__gu_val) : "0" (__gu_err), "o" (__m(__gu_addr)), "o" (__m(__gu_addr + 4)), "i" (-EFAULT)); })
# 310 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
extern void __get_user_unknown(void);
# 319 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __PUT_USER_DW(__pu_val) __put_user_asm_ll32(__pu_val)


#define __put_user_nocheck(x,ptr,size) ({ long __pu_err = 0; __typeof__(*(ptr)) __pu_val; long __pu_addr; __pu_val = (x); __pu_addr = (long) (ptr); switch (size) { case 1: __put_user_asm("sb", __pu_val); break; case 2: __put_user_asm("sh", __pu_val); break; case 4: __put_user_asm("sw", __pu_val); break; case 8: __PUT_USER_DW(__pu_val); break; default: __put_user_unknown(); break; } __pu_err; })
# 339 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __put_user_check(x,ptr,size) ({ __typeof__(*(ptr)) __pu_val = (x); long __pu_addr = (long) (ptr); long __pu_err; __pu_err = verify_area(VERIFY_WRITE, (void *) __pu_addr, size); if (likely(!__pu_err)) { switch (size) { case 1: __put_user_asm("sb", __pu_val); break; case 2: __put_user_asm("sh", __pu_val); break; case 4: __put_user_asm("sw", __pu_val); break; case 8: __PUT_USER_DW(__pu_val); break; default: __put_user_unknown(); break; } } __pu_err; })
# 359 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __put_user_asm(insn,__pu_val) ({ __asm__ __volatile__( "1:	" insn "	%z2, %3		# __put_user_asm\n" "2:							\n" "	.section	.fixup,\"ax\"			\n" "3:	li	%0, %4					\n" "	j	2b					\n" "	.previous					\n" "	.section	__ex_table,\"a\"		\n" "	" __UA_ADDR "	1b, 3b				\n" "	.previous					\n" : "=r" (__pu_err) : "0" (__pu_err), "Jr" (__pu_val), "o" (__m(__pu_addr)), "i" (-EFAULT)); })
# 376 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __put_user_asm_ll32(__pu_val) ({ __asm__ __volatile__( "1:	sw	%2, %3		# __put_user_asm_ll32	\n" "2:	sw	%D2, %4					\n" "3:							\n" "	.section	.fixup,\"ax\"			\n" "4:	li	%0, %5					\n" "	j	3b					\n" "	.previous					\n" "	.section	__ex_table,\"a\"		\n" "	" __UA_ADDR "	1b, 4b				\n" "	" __UA_ADDR "	2b, 4b				\n" "	.previous" : "=r" (__pu_err) : "0" (__pu_err), "r" (__pu_val), "o" (__m(__pu_addr)), "o" (__m(__pu_addr + 4)), "i" (-EFAULT)); })
# 395 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
extern void __put_user_unknown(void);
# 408 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __MODULE_JAL(destination) "jal\t" #destination "\n\t"



extern size_t __copy_user(void *__to, const void *__from, size_t __n);

#define __invoke_copy_to_user(to,from,n) ({ register void *__cu_to_r __asm__ ("$4"); register const void *__cu_from_r __asm__ ("$5"); register long __cu_len_r __asm__ ("$6"); __cu_to_r = (to); __cu_from_r = (from); __cu_len_r = (n); __asm__ __volatile__( __MODULE_JAL(__copy_user) : "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r) : : "$8", "$9", "$10", "$11", "$12", "$15", "$24", "$31", "memory"); __cu_len_r; })
# 446 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __copy_to_user(to,from,n) ({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = (to); __cu_from = (from); __cu_len = (n); __cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len); __cu_len; })
# 459 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __copy_to_user_inatomic __copy_to_user
#define __copy_from_user_inatomic __copy_from_user
# 475 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define copy_to_user(to,from,n) ({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = (to); __cu_from = (from); __cu_len = (n); if (access_ok(VERIFY_WRITE, __cu_to, __cu_len)) __cu_len = __invoke_copy_to_user(__cu_to, __cu_from, __cu_len); __cu_len; })
# 490 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __invoke_copy_from_user(to,from,n) ({ register void *__cu_to_r __asm__ ("$4"); register const void *__cu_from_r __asm__ ("$5"); register long __cu_len_r __asm__ ("$6"); __cu_to_r = (to); __cu_from_r = (from); __cu_len_r = (n); __asm__ __volatile__( ".set\tnoreorder\n\t" __MODULE_JAL(__copy_user) ".set\tnoat\n\t" __UA_ADDU "\t$1, %1, %2\n\t" ".set\tat\n\t" ".set\treorder" : "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r) : : "$8", "$9", "$10", "$11", "$12", "$15", "$24", "$31", "memory"); __cu_len_r; })
# 529 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define __copy_from_user(to,from,n) ({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = (to); __cu_from = (from); __cu_len = (n); __cu_len = __invoke_copy_from_user(__cu_to, __cu_from, __cu_len); __cu_len; })
# 559 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
#define copy_from_user(to,from,n) ({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = (to); __cu_from = (from); __cu_len = (n); if (access_ok(VERIFY_READ, __cu_from, __cu_len)) __cu_len = __invoke_copy_from_user(__cu_to, __cu_from, __cu_len); __cu_len; })
# 585 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) __kernel_size_t
__clear_user(void *addr, __kernel_size_t size)
{
        __kernel_size_t res;

        __asm__ __volatile__(
                "move\t$4, %1\n\t"
                "move\t$5, $0\n\t"
                "move\t$6, %2\n\t"
                "jal\t" "__bzero" "\n\t"
                "move\t%0, $6"
                : "=r" (res)
                : "r" (addr), "r" (size)
                : "$4", "$5", "$6", "$8", "$9", "$31");

        return res;
}

#define clear_user(addr,n) ({ void * __cl_addr = (addr); unsigned long __cl_size = (n); if (__cl_size && access_ok(VERIFY_WRITE, ((unsigned long)(__cl_addr)), __cl_size)) __cl_size = __clear_user(__cl_addr, __cl_size); __cl_size; })
# 633 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) long
__strncpy_from_user(char *__to, const char *__from, long __len)
{
        long res;

        __asm__ __volatile__(
                "move\t$4, %1\n\t"
                "move\t$5, %2\n\t"
                "move\t$6, %3\n\t"
                "jal\t" "__strncpy_from_user_nocheck_asm" "\n\t"
                "move\t%0, $2"
                : "=r" (res)
                : "r" (__to), "r" (__from), "r" (__len)
                : "$2", "$3", "$4", "$5", "$6", "$8", "$31", "memory");

        return res;
}
# 669 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) long
strncpy_from_user(char *__to, const char *__from, long __len)
{
        long res;

        __asm__ __volatile__(
                "move\t$4, %1\n\t"
                "move\t$5, %2\n\t"
                "move\t$6, %3\n\t"
                "jal\t" "__strncpy_from_user_asm" "\n\t"
                "move\t%0, $2"
                : "=r" (res)
                : "r" (__to), "r" (__from), "r" (__len)
                : "$2", "$3", "$4", "$5", "$6", "$8", "$31", "memory");

        return res;
}


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) long __strlen_user(const char *s)
{
        long res;

        __asm__ __volatile__(
                "move\t$4, %1\n\t"
                "jal\t" "__strlen_user_nocheck_asm" "\n\t"
                "move\t%0, $2"
                : "=r" (res)
                : "r" (s)
                : "$2", "$4", "$8", "$31");

        return res;
}
# 717 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) long strlen_user(const char *s)
{
        long res;

        __asm__ __volatile__(
                "move\t$4, %1\n\t"
                "jal\t" "__strlen_user_asm" "\n\t"
                "move\t%0, $2"
                : "=r" (res)
                : "r" (s)
                : "$2", "$4", "$8", "$31");

        return res;
}


static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) long __strnlen_user(const char *s, long n)
{
        long res;

        __asm__ __volatile__(
                "move\t$4, %1\n\t"
                "move\t$5, %2\n\t"
                "jal\t" "__strnlen_user_nocheck_asm" "\n\t"
                "move\t%0, $2"
                : "=r" (res)
                : "r" (s), "r" (n)
                : "$2", "$4", "$5", "$8", "$31");

        return res;
}
# 763 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/uaccess.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) long strnlen_user(const char *s, long n)
{
        long res;

        __asm__ __volatile__(
                "move\t$4, %1\n\t"
                "move\t$5, %2\n\t"
                "jal\t" "__strnlen_user_asm" "\n\t"
                "move\t%0, $2"
                : "=r" (res)
                : "r" (s), "r" (n)
                : "$2", "$4", "$5", "$8", "$31");

        return res;
}

struct exception_table_entry
{
        unsigned long insn;
        unsigned long nextinsn;
};


extern unsigned long search_exception_table(unsigned long addr);


#define fixup_exception(map_reg,fixup_unit,pc) ({ fixup_unit; })
# 211 "drivers/char/serial.c" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/delay.h" 1

#define _LINUX_DELAY_H 







extern unsigned long loops_per_jiffy;



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/delay.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/delay.h"
#define _ASM_DELAY_H 






extern unsigned long loops_per_jiffy;

static __inline__ __attribute__((always_inline)) void __delay(unsigned long loops)
{
        __asm__ __volatile__ (
                ".set\tnoreorder\n"
                "1:\tbnez\t%0,1b\n\t"
                "subu\t%0,1\n\t"
                ".set\treorder"
                :"=r" (loops)
                :"0" (loops));
}
# 40 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/delay.h"
static __inline__ __attribute__((always_inline)) void __udelay(unsigned long usecs, unsigned long lpj)
{
        unsigned long lo;




        usecs *= (unsigned long) (((0x8000000000000000ULL / (500000 / 100)) +
                                   0x80000000ULL) >> 32);
        __asm__("multu\t%2,%3"
                : "=h" (usecs), "=l" (lo)
                : "r" (usecs), "r" (lpj)
                : "accum");
        __delay(usecs);
}

static __inline__ __attribute__((always_inline)) void __ndelay(unsigned long nsecs, unsigned long lpj)
{
        unsigned long lo;




        nsecs *= (unsigned long) (((0x8000000000000000ULL / (500000000 / 100)) +
                                   0x80000000ULL) >> 32);
        __asm__("multu\t%2,%3"
                : "=h" (nsecs), "=l" (lo)
                : "r" (nsecs), "r" (lpj)
                : "accum");
        __delay(nsecs);
}




#define __udelay_val loops_per_jiffy


#define udelay(usecs) __udelay((usecs),__udelay_val)
#define ndelay(nsecs) __ndelay((nsecs),__udelay_val)
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/delay.h" 2
# 23 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/delay.h"
#define MAX_MSEC_OFFSET (ULONG_MAX - (1000 / HZ) + 1)
# 40 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/delay.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int jiffies_to_msecs(const unsigned long j)
{

        return (1000 / 100) * j;





}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int jiffies_to_usecs(const unsigned long j)
{

        return (1000000 / 100) * j;





}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long msecs_to_jiffies(const unsigned int m)
{
        if (((~0UL) - (1000 / 100) + 1) < (~0U) && m > (unsigned int)((~0UL) - (1000 / 100) + 1))
                return ((~0UL >> 1)-1);

        return ((unsigned long)m + (1000 / 100) - 1) / (1000 / 100);





}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void msleep(unsigned long msecs)
{
        do { current->state = (2); __asm__ __volatile__( ".set	push\n\t" ".set	noreorder\n\t" ".set	mips2\n\t" "sync\n\t" ".set	pop" : : : "memory"); } while (0);
        schedule_timeout(msecs_to_jiffies(msecs) + 1);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void ssleep(unsigned long secs)
{
        do { current->state = (2); __asm__ __volatile__( ".set	push\n\t" ".set	noreorder\n\t" ".set	mips2\n\t" "sync\n\t" ".set	pop" : : : "memory"); } while (0);
        schedule_timeout((100 * secs) + 1);
}
# 98 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/delay.h"
#define MAX_UDELAY_MS 5






#define mdelay(n) ( (__builtin_constant_p(n) && (n)<=MAX_UDELAY_MS) ? udelay((n)*1000) : ({unsigned long msec=(n); while (msec--) udelay(1000);}))
# 213 "drivers/char/serial.c" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/console.h" 1
# 15 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/console.h"
#define _LINUX_CONSOLE_H_ 1





struct vc_data;
struct console_font_op;




#define VT100ID "\033[?1;2c"
#define VT102ID "\033[?6c"

struct consw {
        const char *(*con_startup)(void);
        void (*con_init)(struct vc_data *, int);
        void (*con_deinit)(struct vc_data *);
        void (*con_clear)(struct vc_data *, int, int, int, int);
        void (*con_putc)(struct vc_data *, int, int, int);
        void (*con_putcs)(struct vc_data *, const unsigned short *, int, int, int);
        void (*con_cursor)(struct vc_data *, int);
        int (*con_scroll)(struct vc_data *, int, int, int, int);
        void (*con_bmove)(struct vc_data *, int, int, int, int, int, int);
        int (*con_switch)(struct vc_data *);
        int (*con_blank)(struct vc_data *, int);
        int (*con_font_op)(struct vc_data *, struct console_font_op *);
        int (*con_set_palette)(struct vc_data *, unsigned char *);
        int (*con_scrolldelta)(struct vc_data *, int);
        int (*con_set_origin)(struct vc_data *);
        void (*con_save_screen)(struct vc_data *);
        u8 (*con_build_attr)(struct vc_data *, u8, u8, u8, u8, u8);
        void (*con_invert_region)(struct vc_data *, u16 *, int);
        u16 *(*con_screen_pos)(struct vc_data *, int);
        unsigned long (*con_getxy)(struct vc_data *, unsigned long, int *, int *);
};

extern const struct consw *conswitchp;

extern const struct consw dummy_con;
extern const struct consw fb_con;
extern const struct consw vga_con;
extern const struct consw newport_con;
extern const struct consw prom_con;

void take_over_console(const struct consw *sw, int first, int last, int deflt);
void give_up_console(const struct consw *sw);


#define SM_UP (1)
#define SM_DOWN (2)


#define CM_DRAW (1)
#define CM_ERASE (2)
#define CM_MOVE (3)




struct console_cmdline
{
        char name[8];
        int index;
        char *options;
};
#define MAX_CMDLINECONSOLES 8
extern struct console_cmdline console_cmdline[8];






#define CON_PRINTBUFFER (1)
#define CON_CONSDEV (2)
#define CON_ENABLED (4)
#define CON_BOOT (8)

struct console
{
        char name[8];
        void (*write)(struct console *, const char *, unsigned);
        int (*read)(struct console *, const char *, unsigned);
        kdev_t (*device)(struct console *);
        void (*unblank)(void);
        int (*setup)(struct console *, char *);
        short flags;
        short index;
        int cflag;
        struct console *next;
};

extern void register_console(struct console *);
extern int unregister_console(struct console *);
extern struct console *console_drivers;
extern void acquire_console_sem(void);
extern void release_console_sem(void);
extern void console_conditional_schedule(void);
extern void console_unblank(void);
extern void disable_console_blank(void);


#define VESA_NO_BLANKING 0
#define VESA_VSYNC_SUSPEND 1
#define VESA_HSYNC_SUSPEND 2
#define VESA_POWERDOWN 3
# 215 "drivers/char/serial.c" 2


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h" 1
# 18 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h"
#define LINUX_PCI_H 





#define PCI_VENDOR_ID 0x00
#define PCI_DEVICE_ID 0x02
#define PCI_COMMAND 0x04
#define PCI_COMMAND_IO 0x1
#define PCI_COMMAND_MEMORY 0x2
#define PCI_COMMAND_MASTER 0x4
#define PCI_COMMAND_SPECIAL 0x8
#define PCI_COMMAND_INVALIDATE 0x10
#define PCI_COMMAND_VGA_PALETTE 0x20
#define PCI_COMMAND_PARITY 0x40
#define PCI_COMMAND_WAIT 0x80
#define PCI_COMMAND_SERR 0x100
#define PCI_COMMAND_FAST_BACK 0x200
#define PCI_COMMAND_INTX_DISABLE 0x400

#define PCI_STATUS 0x06
#define PCI_STATUS_CAP_LIST 0x10
#define PCI_STATUS_66MHZ 0x20
#define PCI_STATUS_UDF 0x40
#define PCI_STATUS_FAST_BACK 0x80
#define PCI_STATUS_PARITY 0x100
#define PCI_STATUS_DEVSEL_MASK 0x600
#define PCI_STATUS_DEVSEL_FAST 0x000
#define PCI_STATUS_DEVSEL_MEDIUM 0x200
#define PCI_STATUS_DEVSEL_SLOW 0x400
#define PCI_STATUS_SIG_TARGET_ABORT 0x800
#define PCI_STATUS_REC_TARGET_ABORT 0x1000
#define PCI_STATUS_REC_MASTER_ABORT 0x2000
#define PCI_STATUS_SIG_SYSTEM_ERROR 0x4000
#define PCI_STATUS_DETECTED_PARITY 0x8000

#define PCI_CLASS_REVISION 0x08

#define PCI_REVISION_ID 0x08
#define PCI_CLASS_PROG 0x09
#define PCI_CLASS_DEVICE 0x0a

#define PCI_CACHE_LINE_SIZE 0x0c
#define PCI_LATENCY_TIMER 0x0d
#define PCI_HEADER_TYPE 0x0e
#define PCI_HEADER_TYPE_NORMAL 0
#define PCI_HEADER_TYPE_BRIDGE 1
#define PCI_HEADER_TYPE_CARDBUS 2

#define PCI_BIST 0x0f
#define PCI_BIST_CODE_MASK 0x0f
#define PCI_BIST_START 0x40
#define PCI_BIST_CAPABLE 0x80







#define PCI_BASE_ADDRESS_0 0x10
#define PCI_BASE_ADDRESS_1 0x14
#define PCI_BASE_ADDRESS_2 0x18
#define PCI_BASE_ADDRESS_3 0x1c
#define PCI_BASE_ADDRESS_4 0x20
#define PCI_BASE_ADDRESS_5 0x24
#define PCI_BASE_ADDRESS_SPACE 0x01
#define PCI_BASE_ADDRESS_SPACE_IO 0x01
#define PCI_BASE_ADDRESS_SPACE_MEMORY 0x00
#define PCI_BASE_ADDRESS_MEM_TYPE_MASK 0x06
#define PCI_BASE_ADDRESS_MEM_TYPE_32 0x00
#define PCI_BASE_ADDRESS_MEM_TYPE_1M 0x02
#define PCI_BASE_ADDRESS_MEM_TYPE_64 0x04
#define PCI_BASE_ADDRESS_MEM_PREFETCH 0x08
#define PCI_BASE_ADDRESS_MEM_MASK (~0x0fUL)
#define PCI_BASE_ADDRESS_IO_MASK (~0x03UL)



#define PCI_CARDBUS_CIS 0x28
#define PCI_SUBSYSTEM_VENDOR_ID 0x2c
#define PCI_SUBSYSTEM_ID 0x2e
#define PCI_ROM_ADDRESS 0x30
#define PCI_ROM_ADDRESS_ENABLE 0x01
#define PCI_ROM_ADDRESS_MASK (~0x7ffUL)

#define PCI_CAPABILITY_LIST 0x34


#define PCI_INTERRUPT_LINE 0x3c
#define PCI_INTERRUPT_PIN 0x3d
#define PCI_MIN_GNT 0x3e
#define PCI_MAX_LAT 0x3f


#define PCI_PRIMARY_BUS 0x18
#define PCI_SECONDARY_BUS 0x19
#define PCI_SUBORDINATE_BUS 0x1a
#define PCI_SEC_LATENCY_TIMER 0x1b
#define PCI_IO_BASE 0x1c
#define PCI_IO_LIMIT 0x1d
#define PCI_IO_RANGE_TYPE_MASK 0x0fUL
#define PCI_IO_RANGE_TYPE_16 0x00
#define PCI_IO_RANGE_TYPE_32 0x01
#define PCI_IO_RANGE_MASK (~0x0fUL)
#define PCI_SEC_STATUS 0x1e
#define PCI_MEMORY_BASE 0x20
#define PCI_MEMORY_LIMIT 0x22
#define PCI_MEMORY_RANGE_TYPE_MASK 0x0fUL
#define PCI_MEMORY_RANGE_MASK (~0x0fUL)
#define PCI_PREF_MEMORY_BASE 0x24
#define PCI_PREF_MEMORY_LIMIT 0x26
#define PCI_PREF_RANGE_TYPE_MASK 0x0fUL
#define PCI_PREF_RANGE_TYPE_32 0x00
#define PCI_PREF_RANGE_TYPE_64 0x01
#define PCI_PREF_RANGE_MASK (~0x0fUL)
#define PCI_PREF_BASE_UPPER32 0x28
#define PCI_PREF_LIMIT_UPPER32 0x2c
#define PCI_IO_BASE_UPPER16 0x30
#define PCI_IO_LIMIT_UPPER16 0x32


#define PCI_ROM_ADDRESS1 0x38

#define PCI_BRIDGE_CONTROL 0x3e
#define PCI_BRIDGE_CTL_PARITY 0x01
#define PCI_BRIDGE_CTL_SERR 0x02
#define PCI_BRIDGE_CTL_NO_ISA 0x04
#define PCI_BRIDGE_CTL_VGA 0x08
#define PCI_BRIDGE_CTL_MASTER_ABORT 0x20
#define PCI_BRIDGE_CTL_BUS_RESET 0x40
#define PCI_BRIDGE_CTL_FAST_BACK 0x80


#define PCI_CB_CAPABILITY_LIST 0x14

#define PCI_CB_SEC_STATUS 0x16
#define PCI_CB_PRIMARY_BUS 0x18
#define PCI_CB_CARD_BUS 0x19
#define PCI_CB_SUBORDINATE_BUS 0x1a
#define PCI_CB_LATENCY_TIMER 0x1b
#define PCI_CB_MEMORY_BASE_0 0x1c
#define PCI_CB_MEMORY_LIMIT_0 0x20
#define PCI_CB_MEMORY_BASE_1 0x24
#define PCI_CB_MEMORY_LIMIT_1 0x28
#define PCI_CB_IO_BASE_0 0x2c
#define PCI_CB_IO_BASE_0_HI 0x2e
#define PCI_CB_IO_LIMIT_0 0x30
#define PCI_CB_IO_LIMIT_0_HI 0x32
#define PCI_CB_IO_BASE_1 0x34
#define PCI_CB_IO_BASE_1_HI 0x36
#define PCI_CB_IO_LIMIT_1 0x38
#define PCI_CB_IO_LIMIT_1_HI 0x3a
#define PCI_CB_IO_RANGE_MASK (~0x03UL)

#define PCI_CB_BRIDGE_CONTROL 0x3e
#define PCI_CB_BRIDGE_CTL_PARITY 0x01
#define PCI_CB_BRIDGE_CTL_SERR 0x02
#define PCI_CB_BRIDGE_CTL_ISA 0x04
#define PCI_CB_BRIDGE_CTL_VGA 0x08
#define PCI_CB_BRIDGE_CTL_MASTER_ABORT 0x20
#define PCI_CB_BRIDGE_CTL_CB_RESET 0x40
#define PCI_CB_BRIDGE_CTL_16BIT_INT 0x80
#define PCI_CB_BRIDGE_CTL_PREFETCH_MEM0 0x100
#define PCI_CB_BRIDGE_CTL_PREFETCH_MEM1 0x200
#define PCI_CB_BRIDGE_CTL_POST_WRITES 0x400
#define PCI_CB_SUBSYSTEM_VENDOR_ID 0x40
#define PCI_CB_SUBSYSTEM_ID 0x42
#define PCI_CB_LEGACY_MODE_BASE 0x44




#define PCI_CAP_LIST_ID 0
#define PCI_CAP_ID_PM 0x01
#define PCI_CAP_ID_AGP 0x02
#define PCI_CAP_ID_VPD 0x03
#define PCI_CAP_ID_SLOTID 0x04
#define PCI_CAP_ID_MSI 0x05
#define PCI_CAP_ID_CHSWP 0x06
#define PCI_CAP_ID_PCIX 0x07
#define PCI_CAP_ID_SHPC 0x0C
#define PCI_CAP_ID_EXP 0x10
#define PCI_CAP_LIST_NEXT 1
#define PCI_CAP_FLAGS 2
#define PCI_CAP_SIZEOF 4



#define PCI_PM_PMC 2
#define PCI_PM_CAP_VER_MASK 0x0007
#define PCI_PM_CAP_PME_CLOCK 0x0008
#define PCI_PM_CAP_RESERVED 0x0010
#define PCI_PM_CAP_DSI 0x0020
#define PCI_PM_CAP_AUX_POWER 0x01C0
#define PCI_PM_CAP_D1 0x0200
#define PCI_PM_CAP_D2 0x0400
#define PCI_PM_CAP_PME 0x0800
#define PCI_PM_CAP_PME_MASK 0xF800
#define PCI_PM_CAP_PME_D0 0x0800
#define PCI_PM_CAP_PME_D1 0x1000
#define PCI_PM_CAP_PME_D2 0x2000
#define PCI_PM_CAP_PME_D3 0x4000
#define PCI_PM_CAP_PME_D3cold 0x8000
#define PCI_PM_CTRL 4
#define PCI_PM_CTRL_STATE_MASK 0x0003
#define PCI_PM_CTRL_PME_ENABLE 0x0100
#define PCI_PM_CTRL_DATA_SEL_MASK 0x1e00
#define PCI_PM_CTRL_DATA_SCALE_MASK 0x6000
#define PCI_PM_CTRL_PME_STATUS 0x8000
#define PCI_PM_PPB_EXTENSIONS 6
#define PCI_PM_PPB_B2_B3 0x40
#define PCI_PM_BPCC_ENABLE 0x80
#define PCI_PM_DATA_REGISTER 7
#define PCI_PM_SIZEOF 8



#define PCI_AGP_VERSION 2
#define PCI_AGP_RFU 3
#define PCI_AGP_STATUS 4
#define PCI_AGP_STATUS_RQ_MASK 0xff000000
#define PCI_AGP_STATUS_SBA 0x0200
#define PCI_AGP_STATUS_64BIT 0x0020
#define PCI_AGP_STATUS_FW 0x0010
#define PCI_AGP_STATUS_RATE4 0x0004
#define PCI_AGP_STATUS_RATE2 0x0002
#define PCI_AGP_STATUS_RATE1 0x0001
#define PCI_AGP_COMMAND 8
#define PCI_AGP_COMMAND_RQ_MASK 0xff000000
#define PCI_AGP_COMMAND_SBA 0x0200
#define PCI_AGP_COMMAND_AGP 0x0100
#define PCI_AGP_COMMAND_64BIT 0x0020
#define PCI_AGP_COMMAND_FW 0x0010
#define PCI_AGP_COMMAND_RATE4 0x0004
#define PCI_AGP_COMMAND_RATE2 0x0002
#define PCI_AGP_COMMAND_RATE1 0x0001
#define PCI_AGP_SIZEOF 12



#define PCI_SID_ESR 2
#define PCI_SID_ESR_NSLOTS 0x1f
#define PCI_SID_ESR_FIC 0x20
#define PCI_SID_CHASSIS_NR 3



#define PCI_MSI_FLAGS 2
#define PCI_MSI_FLAGS_64BIT 0x80
#define PCI_MSI_FLAGS_QSIZE 0x70
#define PCI_MSI_FLAGS_QMASK 0x0e
#define PCI_MSI_FLAGS_ENABLE 0x01
#define PCI_MSI_RFU 3
#define PCI_MSI_ADDRESS_LO 4
#define PCI_MSI_ADDRESS_HI 8
#define PCI_MSI_DATA_32 8
#define PCI_MSI_DATA_64 12



#define PCI_CHSWP_CSR 2
#define PCI_CHSWP_DHA 0x01
#define PCI_CHSWP_EIM 0x02
#define PCI_CHSWP_PIE 0x04
#define PCI_CHSWP_LOO 0x08
#define PCI_CHSWP_PI 0x30
#define PCI_CHSWP_EXT 0x40
#define PCI_CHSWP_INS 0x80



#define PCI_X_CMD 2
#define PCI_X_CMD_DPERR_E 0x0001
#define PCI_X_CMD_ERO 0x0002
#define PCI_X_CMD_MAX_READ 0x000c
#define PCI_X_CMD_MAX_SPLIT 0x0070
#define PCI_X_DEVFN 4
#define PCI_X_BUSNR 5
#define PCI_X_STATUS 6
#define PCI_X_STATUS_64BIT 0x0001
#define PCI_X_STATUS_133MHZ 0x0002
#define PCI_X_STATUS_SPL_DISC 0x0004
#define PCI_X_STATUS_UNX_SPL 0x0008
#define PCI_X_STATUS_COMPLEX 0x0010
#define PCI_X_STATUS_MAX_READ 0x0060
#define PCI_X_STATUS_MAX_SPLIT 0x0380
#define PCI_X_STATUS_MAX_CUM 0x1c00
#define PCI_X_STATUS_SPL_ERR 0x2000



# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci_ids.h" 1
# 9 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci_ids.h"
#define PCI_CLASS_NOT_DEFINED 0x0000
#define PCI_CLASS_NOT_DEFINED_VGA 0x0001

#define PCI_BASE_CLASS_STORAGE 0x01
#define PCI_CLASS_STORAGE_SCSI 0x0100
#define PCI_CLASS_STORAGE_IDE 0x0101
#define PCI_CLASS_STORAGE_FLOPPY 0x0102
#define PCI_CLASS_STORAGE_IPI 0x0103
#define PCI_CLASS_STORAGE_RAID 0x0104
#define PCI_CLASS_STORAGE_OTHER 0x0180

#define PCI_BASE_CLASS_NETWORK 0x02
#define PCI_CLASS_NETWORK_ETHERNET 0x0200
#define PCI_CLASS_NETWORK_TOKEN_RING 0x0201
#define PCI_CLASS_NETWORK_FDDI 0x0202
#define PCI_CLASS_NETWORK_ATM 0x0203
#define PCI_CLASS_NETWORK_OTHER 0x0280

#define PCI_BASE_CLASS_DISPLAY 0x03
#define PCI_CLASS_DISPLAY_VGA 0x0300
#define PCI_CLASS_DISPLAY_XGA 0x0301
#define PCI_CLASS_DISPLAY_3D 0x0302
#define PCI_CLASS_DISPLAY_OTHER 0x0380

#define PCI_BASE_CLASS_MULTIMEDIA 0x04
#define PCI_CLASS_MULTIMEDIA_VIDEO 0x0400
#define PCI_CLASS_MULTIMEDIA_AUDIO 0x0401
#define PCI_CLASS_MULTIMEDIA_PHONE 0x0402
#define PCI_CLASS_MULTIMEDIA_OTHER 0x0480

#define PCI_BASE_CLASS_MEMORY 0x05
#define PCI_CLASS_MEMORY_RAM 0x0500
#define PCI_CLASS_MEMORY_FLASH 0x0501
#define PCI_CLASS_MEMORY_OTHER 0x0580

#define PCI_BASE_CLASS_BRIDGE 0x06
#define PCI_CLASS_BRIDGE_HOST 0x0600
#define PCI_CLASS_BRIDGE_ISA 0x0601
#define PCI_CLASS_BRIDGE_EISA 0x0602
#define PCI_CLASS_BRIDGE_MC 0x0603
#define PCI_CLASS_BRIDGE_PCI 0x0604
#define PCI_CLASS_BRIDGE_PCMCIA 0x0605
#define PCI_CLASS_BRIDGE_NUBUS 0x0606
#define PCI_CLASS_BRIDGE_CARDBUS 0x0607
#define PCI_CLASS_BRIDGE_RACEWAY 0x0608
#define PCI_CLASS_BRIDGE_OTHER 0x0680

#define PCI_BASE_CLASS_COMMUNICATION 0x07
#define PCI_CLASS_COMMUNICATION_SERIAL 0x0700
#define PCI_CLASS_COMMUNICATION_PARALLEL 0x0701
#define PCI_CLASS_COMMUNICATION_MULTISERIAL 0x0702
#define PCI_CLASS_COMMUNICATION_MODEM 0x0703
#define PCI_CLASS_COMMUNICATION_OTHER 0x0780

#define PCI_BASE_CLASS_SYSTEM 0x08
#define PCI_CLASS_SYSTEM_PIC 0x0800
#define PCI_CLASS_SYSTEM_DMA 0x0801
#define PCI_CLASS_SYSTEM_TIMER 0x0802
#define PCI_CLASS_SYSTEM_RTC 0x0803
#define PCI_CLASS_SYSTEM_PCI_HOTPLUG 0x0804
#define PCI_CLASS_SYSTEM_OTHER 0x0880

#define PCI_BASE_CLASS_INPUT 0x09
#define PCI_CLASS_INPUT_KEYBOARD 0x0900
#define PCI_CLASS_INPUT_PEN 0x0901
#define PCI_CLASS_INPUT_MOUSE 0x0902
#define PCI_CLASS_INPUT_SCANNER 0x0903
#define PCI_CLASS_INPUT_GAMEPORT 0x0904
#define PCI_CLASS_INPUT_OTHER 0x0980

#define PCI_BASE_CLASS_DOCKING 0x0a
#define PCI_CLASS_DOCKING_GENERIC 0x0a00
#define PCI_CLASS_DOCKING_OTHER 0x0a80

#define PCI_BASE_CLASS_PROCESSOR 0x0b
#define PCI_CLASS_PROCESSOR_386 0x0b00
#define PCI_CLASS_PROCESSOR_486 0x0b01
#define PCI_CLASS_PROCESSOR_PENTIUM 0x0b02
#define PCI_CLASS_PROCESSOR_ALPHA 0x0b10
#define PCI_CLASS_PROCESSOR_POWERPC 0x0b20
#define PCI_CLASS_PROCESSOR_MIPS 0x0b30
#define PCI_CLASS_PROCESSOR_CO 0x0b40

#define PCI_BASE_CLASS_SERIAL 0x0c
#define PCI_CLASS_SERIAL_FIREWIRE 0x0c00
#define PCI_CLASS_SERIAL_ACCESS 0x0c01
#define PCI_CLASS_SERIAL_SSA 0x0c02
#define PCI_CLASS_SERIAL_USB 0x0c03
#define PCI_CLASS_SERIAL_FIBER 0x0c04
#define PCI_CLASS_SERIAL_SMBUS 0x0c05

#define PCI_BASE_CLASS_INTELLIGENT 0x0e
#define PCI_CLASS_INTELLIGENT_I2O 0x0e00

#define PCI_BASE_CLASS_SATELLITE 0x0f
#define PCI_CLASS_SATELLITE_TV 0x0f00
#define PCI_CLASS_SATELLITE_AUDIO 0x0f01
#define PCI_CLASS_SATELLITE_VOICE 0x0f03
#define PCI_CLASS_SATELLITE_DATA 0x0f04

#define PCI_BASE_CLASS_CRYPT 0x10
#define PCI_CLASS_CRYPT_NETWORK 0x1000
#define PCI_CLASS_CRYPT_ENTERTAINMENT 0x1001
#define PCI_CLASS_CRYPT_OTHER 0x1080

#define PCI_BASE_CLASS_SIGNAL_PROCESSING 0x11
#define PCI_CLASS_SP_DPIO 0x1100
#define PCI_CLASS_SP_OTHER 0x1180

#define PCI_CLASS_OTHERS 0xff



#define PCI_VENDOR_ID_DYNALINK 0x0675
#define PCI_DEVICE_ID_DYNALINK_IS64PH 0x1702

#define PCI_VENDOR_ID_BERKOM 0x0871
#define PCI_DEVICE_ID_BERKOM_A1T 0xffa1
#define PCI_DEVICE_ID_BERKOM_T_CONCEPT 0xffa2
#define PCI_DEVICE_ID_BERKOM_A4T 0xffa4
#define PCI_DEVICE_ID_BERKOM_SCITEL_QUADRO 0xffa8

#define PCI_VENDOR_ID_COMPAQ 0x0e11
#define PCI_DEVICE_ID_COMPAQ_TOKENRING 0x0508
#define PCI_DEVICE_ID_COMPAQ_1280 0x3033
#define PCI_DEVICE_ID_COMPAQ_TRIFLEX 0x4000
#define PCI_DEVICE_ID_COMPAQ_6010 0x6010
#define PCI_DEVICE_ID_COMPAQ_TACHYON 0xa0fc
#define PCI_DEVICE_ID_COMPAQ_SMART2P 0xae10
#define PCI_DEVICE_ID_COMPAQ_NETEL100 0xae32
#define PCI_DEVICE_ID_COMPAQ_TRIFLEX_IDE 0xae33
#define PCI_DEVICE_ID_COMPAQ_NETEL10 0xae34
#define PCI_DEVICE_ID_COMPAQ_NETFLEX3I 0xae35
#define PCI_DEVICE_ID_COMPAQ_NETEL100D 0xae40
#define PCI_DEVICE_ID_COMPAQ_NETEL100PI 0xae43
#define PCI_DEVICE_ID_COMPAQ_NETEL100I 0xb011
#define PCI_DEVICE_ID_COMPAQ_CISS 0xb060
#define PCI_DEVICE_ID_COMPAQ_CISSB 0xb178
#define PCI_DEVICE_ID_COMPAQ_CISSC 0x0046
#define PCI_DEVICE_ID_COMPAQ_THUNDER 0xf130
#define PCI_DEVICE_ID_COMPAQ_NETFLEX3B 0xf150

#define PCI_VENDOR_ID_NCR 0x1000
#define PCI_VENDOR_ID_LSI_LOGIC 0x1000
#define PCI_DEVICE_ID_NCR_53C810 0x0001
#define PCI_DEVICE_ID_NCR_53C820 0x0002
#define PCI_DEVICE_ID_NCR_53C825 0x0003
#define PCI_DEVICE_ID_NCR_53C815 0x0004
#define PCI_DEVICE_ID_LSI_53C810AP 0x0005
#define PCI_DEVICE_ID_NCR_53C860 0x0006
#define PCI_DEVICE_ID_LSI_53C1510 0x000a
#define PCI_DEVICE_ID_NCR_53C896 0x000b
#define PCI_DEVICE_ID_NCR_53C895 0x000c
#define PCI_DEVICE_ID_NCR_53C885 0x000d
#define PCI_DEVICE_ID_NCR_53C875 0x000f
#define PCI_DEVICE_ID_NCR_53C1510 0x0010
#define PCI_DEVICE_ID_LSI_53C895A 0x0012
#define PCI_DEVICE_ID_LSI_53C875A 0x0013
#define PCI_DEVICE_ID_LSI_53C1010_33 0x0020
#define PCI_DEVICE_ID_LSI_53C1010_66 0x0021
#define PCI_DEVICE_ID_LSI_53C1030 0x0030
#define PCI_DEVICE_ID_LSI_53C1035 0x0040
#define PCI_DEVICE_ID_NCR_53C875J 0x008f
#define PCI_DEVICE_ID_LSI_FC909 0x0621
#define PCI_DEVICE_ID_LSI_FC929 0x0622
#define PCI_DEVICE_ID_LSI_FC929_LAN 0x0623
#define PCI_DEVICE_ID_LSI_FC919 0x0624
#define PCI_DEVICE_ID_LSI_FC919_LAN 0x0625
#define PCI_DEVICE_ID_LSI_FC929X 0x0626
#define PCI_DEVICE_ID_LSI_FC919X 0x0628
#define PCI_DEVICE_ID_NCR_YELLOWFIN 0x0701
#define PCI_DEVICE_ID_LSI_61C102 0x0901
#define PCI_DEVICE_ID_LSI_63C815 0x1000

#define PCI_VENDOR_ID_ATI 0x1002

#define PCI_DEVICE_ID_ATI_68800 0x4158
#define PCI_DEVICE_ID_ATI_215CT222 0x4354
#define PCI_DEVICE_ID_ATI_210888CX 0x4358
#define PCI_DEVICE_ID_ATI_215ET222 0x4554

#define PCI_DEVICE_ID_ATI_215GB 0x4742
#define PCI_DEVICE_ID_ATI_215GD 0x4744
#define PCI_DEVICE_ID_ATI_215GI 0x4749
#define PCI_DEVICE_ID_ATI_215GP 0x4750
#define PCI_DEVICE_ID_ATI_215GQ 0x4751
#define PCI_DEVICE_ID_ATI_215XL 0x4752
#define PCI_DEVICE_ID_ATI_215GT 0x4754
#define PCI_DEVICE_ID_ATI_215GTB 0x4755
#define PCI_DEVICE_ID_ATI_215_IV 0x4756
#define PCI_DEVICE_ID_ATI_215_IW 0x4757
#define PCI_DEVICE_ID_ATI_215_IZ 0x475A
#define PCI_DEVICE_ID_ATI_210888GX 0x4758
#define PCI_DEVICE_ID_ATI_215_LB 0x4c42
#define PCI_DEVICE_ID_ATI_215_LD 0x4c44
#define PCI_DEVICE_ID_ATI_215_LG 0x4c47
#define PCI_DEVICE_ID_ATI_215_LI 0x4c49
#define PCI_DEVICE_ID_ATI_215_LM 0x4c4D
#define PCI_DEVICE_ID_ATI_215_LN 0x4c4E
#define PCI_DEVICE_ID_ATI_215_LR 0x4c52
#define PCI_DEVICE_ID_ATI_215_LS 0x4c53
#define PCI_DEVICE_ID_ATI_264_LT 0x4c54

#define PCI_DEVICE_ID_ATI_264VT 0x5654
#define PCI_DEVICE_ID_ATI_264VU 0x5655
#define PCI_DEVICE_ID_ATI_264VV 0x5656

#define PCI_DEVICE_ID_ATI_Rage128_PA 0x5041
#define PCI_DEVICE_ID_ATI_Rage128_PB 0x5042
#define PCI_DEVICE_ID_ATI_Rage128_PC 0x5043
#define PCI_DEVICE_ID_ATI_Rage128_PD 0x5044
#define PCI_DEVICE_ID_ATI_Rage128_PE 0x5045
#define PCI_DEVICE_ID_ATI_RAGE128_PF 0x5046

#define PCI_DEVICE_ID_ATI_RAGE128_PG 0x5047
#define PCI_DEVICE_ID_ATI_RAGE128_PH 0x5048
#define PCI_DEVICE_ID_ATI_RAGE128_PI 0x5049
#define PCI_DEVICE_ID_ATI_RAGE128_PJ 0x504A
#define PCI_DEVICE_ID_ATI_RAGE128_PK 0x504B
#define PCI_DEVICE_ID_ATI_RAGE128_PL 0x504C
#define PCI_DEVICE_ID_ATI_RAGE128_PM 0x504D
#define PCI_DEVICE_ID_ATI_RAGE128_PN 0x504E
#define PCI_DEVICE_ID_ATI_RAGE128_PO 0x504F
#define PCI_DEVICE_ID_ATI_RAGE128_PP 0x5050
#define PCI_DEVICE_ID_ATI_RAGE128_PQ 0x5051
#define PCI_DEVICE_ID_ATI_RAGE128_PR 0x5052
#define PCI_DEVICE_ID_ATI_RAGE128_TR 0x5452
#define PCI_DEVICE_ID_ATI_RAGE128_PS 0x5053
#define PCI_DEVICE_ID_ATI_RAGE128_PT 0x5054
#define PCI_DEVICE_ID_ATI_RAGE128_PU 0x5055
#define PCI_DEVICE_ID_ATI_RAGE128_PV 0x5056
#define PCI_DEVICE_ID_ATI_RAGE128_PW 0x5057
#define PCI_DEVICE_ID_ATI_RAGE128_PX 0x5058

#define PCI_DEVICE_ID_ATI_RAGE128_RE 0x5245
#define PCI_DEVICE_ID_ATI_RAGE128_RF 0x5246
#define PCI_DEVICE_ID_ATI_RAGE128_RG 0x534b
#define PCI_DEVICE_ID_ATI_RAGE128_RH 0x534c
#define PCI_DEVICE_ID_ATI_RAGE128_RI 0x534d

#define PCI_DEVICE_ID_ATI_RAGE128_RK 0x524b
#define PCI_DEVICE_ID_ATI_RAGE128_RL 0x524c
#define PCI_DEVICE_ID_ATI_RAGE128_RM 0x5345
#define PCI_DEVICE_ID_ATI_RAGE128_RN 0x5346
#define PCI_DEVICE_ID_ATI_RAGE128_RO 0x5347

#define PCI_DEVICE_ID_ATI_RAGE128_LE 0x4c45
#define PCI_DEVICE_ID_ATI_RAGE128_LF 0x4c46

#define PCI_DEVICE_ID_ATI_RAGE128_U1 0x5446
#define PCI_DEVICE_ID_ATI_RAGE128_U2 0x544C
#define PCI_DEVICE_ID_ATI_RAGE128_U3 0x5452

#define PCI_DEVICE_ID_ATI_RADEON_LE 0x4d45
#define PCI_DEVICE_ID_ATI_RADEON_LF 0x4d46

#define PCI_DEVICE_ID_ATI_RADEON_QD 0x5144
#define PCI_DEVICE_ID_ATI_RADEON_QE 0x5145
#define PCI_DEVICE_ID_ATI_RADEON_QF 0x5146
#define PCI_DEVICE_ID_ATI_RADEON_QG 0x5147

#define PCI_DEVICE_ID_ATI_RADEON_QY 0x5159
#define PCI_DEVICE_ID_ATI_RADEON_QZ 0x515a

#define PCI_DEVICE_ID_ATI_RADEON_QL 0x514c
#define PCI_DEVICE_ID_ATI_RADEON_QN 0x514e
#define PCI_DEVICE_ID_ATI_RADEON_QO 0x514f
#define PCI_DEVICE_ID_ATI_RADEON_Ql 0x516c
#define PCI_DEVICE_ID_ATI_RADEON_BB 0x4242

#define PCI_DEVICE_ID_ATI_RADEON_QM 0x514d

#define PCI_DEVICE_ID_ATI_RADEON_QW 0x5157
#define PCI_DEVICE_ID_ATI_RADEON_QX 0x5158

#define PCI_DEVICE_ID_ATI_RADEON_Id 0x4964
#define PCI_DEVICE_ID_ATI_RADEON_Ie 0x4965
#define PCI_DEVICE_ID_ATI_RADEON_If 0x4966
#define PCI_DEVICE_ID_ATI_RADEON_Ig 0x4967

#define PCI_DEVICE_ID_ATI_RADEON_Y_ 0x5960
#define PCI_DEVICE_ID_ATI_RADEON_Ya 0x5961
#define PCI_DEVICE_ID_ATI_RADEON_Yd 0x5964

#define PCI_DEVICE_ID_ATI_RADEON_ND 0x4e44
#define PCI_DEVICE_ID_ATI_RADEON_NE 0x4e45
#define PCI_DEVICE_ID_ATI_RADEON_NF 0x4e46
#define PCI_DEVICE_ID_ATI_RADEON_NG 0x4e47
#define PCI_DEVICE_ID_ATI_RADEON_AE 0x4145
#define PCI_DEVICE_ID_ATI_RADEON_AF 0x4146

#define PCI_DEVICE_ID_ATI_RADEON_AD 0x4144

#define PCI_DEVICE_ID_ATI_RADEON_NH 0x4e48
#define PCI_DEVICE_ID_ATI_RADEON_NI 0x4e49

#define PCI_DEVICE_ID_ATI_RADEON_AP 0x4150
#define PCI_DEVICE_ID_ATI_RADEON_AQ 0x4151
#define PCI_DEVICE_ID_ATI_RADEON_AR 0x4152

#define PCI_DEVICE_ID_ATI_RADEON_LY 0x4c59
#define PCI_DEVICE_ID_ATI_RADEON_LZ 0x4c5a

#define PCI_DEVICE_ID_ATI_RADEON_LW 0x4c57
#define PCI_DEVICE_ID_ATI_RADEON_LX 0x4c58

#define PCI_DEVICE_ID_ATI_RADEON_Ld 0x4c64
#define PCI_DEVICE_ID_ATI_RADEON_Le 0x4c65
#define PCI_DEVICE_ID_ATI_RADEON_Lf 0x4c66
#define PCI_DEVICE_ID_ATI_RADEON_Lg 0x4c67

#define PCI_DEVICE_ID_ATI_RADEON_IGP 0xCAB0

#define PCI_DEVICE_ID_ATI_IXP200_IDE 0x4349
#define PCI_DEVICE_ID_ATI_IXP300_IDE 0x4369
#define PCI_DEVICE_ID_ATI_IXP300_SATA 0x436e
#define PCI_DEVICE_ID_ATI_IXP400_IDE 0x4376
#define PCI_DEVICE_ID_ATI_IXP400_SATA 0x4379

#define PCI_VENDOR_ID_VLSI 0x1004
#define PCI_DEVICE_ID_VLSI_82C592 0x0005
#define PCI_DEVICE_ID_VLSI_82C593 0x0006
#define PCI_DEVICE_ID_VLSI_82C594 0x0007
#define PCI_DEVICE_ID_VLSI_82C597 0x0009
#define PCI_DEVICE_ID_VLSI_82C541 0x000c
#define PCI_DEVICE_ID_VLSI_82C543 0x000d
#define PCI_DEVICE_ID_VLSI_82C532 0x0101
#define PCI_DEVICE_ID_VLSI_82C534 0x0102
#define PCI_DEVICE_ID_VLSI_82C535 0x0104
#define PCI_DEVICE_ID_VLSI_82C147 0x0105
#define PCI_DEVICE_ID_VLSI_VAS96011 0x0702

#define PCI_VENDOR_ID_ADL 0x1005
#define PCI_DEVICE_ID_ADL_2301 0x2301

#define PCI_VENDOR_ID_NS 0x100b
#define PCI_DEVICE_ID_NS_87415 0x0002
#define PCI_DEVICE_ID_NS_87560_LIO 0x000e
#define PCI_DEVICE_ID_NS_87560_USB 0x0012
#define PCI_DEVICE_ID_NS_83815 0x0020
#define PCI_DEVICE_ID_NS_83820 0x0022
#define PCI_DEVICE_ID_NS_CS5535_ISA 0x002b
#define PCI_DEVICE_ID_NS_SCx200_BRIDGE 0x0500
#define PCI_DEVICE_ID_NS_SCx200_SMI 0x0501
#define PCI_DEVICE_ID_NS_SCx200_IDE 0x0502
#define PCI_DEVICE_ID_NS_SCx200_AUDIO 0x0503
#define PCI_DEVICE_ID_NS_SCx200_VIDEO 0x0504
#define PCI_DEVICE_ID_NS_SCx200_XBUS 0x0505
#define PCI_DEVICE_ID_NS_87410 0xd001

#define PCI_VENDOR_ID_TSENG 0x100c
#define PCI_DEVICE_ID_TSENG_W32P_2 0x3202
#define PCI_DEVICE_ID_TSENG_W32P_b 0x3205
#define PCI_DEVICE_ID_TSENG_W32P_c 0x3206
#define PCI_DEVICE_ID_TSENG_W32P_d 0x3207
#define PCI_DEVICE_ID_TSENG_ET6000 0x3208

#define PCI_VENDOR_ID_WEITEK 0x100e
#define PCI_DEVICE_ID_WEITEK_P9000 0x9001
#define PCI_DEVICE_ID_WEITEK_P9100 0x9100

#define PCI_VENDOR_ID_DEC 0x1011
#define PCI_DEVICE_ID_DEC_BRD 0x0001
#define PCI_DEVICE_ID_DEC_TULIP 0x0002
#define PCI_DEVICE_ID_DEC_TGA 0x0004
#define PCI_DEVICE_ID_DEC_TULIP_FAST 0x0009
#define PCI_DEVICE_ID_DEC_TGA2 0x000D
#define PCI_DEVICE_ID_DEC_FDDI 0x000F
#define PCI_DEVICE_ID_DEC_TULIP_PLUS 0x0014
#define PCI_DEVICE_ID_DEC_21142 0x0019
#define PCI_DEVICE_ID_DEC_21052 0x0021
#define PCI_DEVICE_ID_DEC_21150 0x0022
#define PCI_DEVICE_ID_DEC_21152 0x0024
#define PCI_DEVICE_ID_DEC_21153 0x0025
#define PCI_DEVICE_ID_DEC_21154 0x0026
#define PCI_DEVICE_ID_DEC_21285 0x1065
#define PCI_DEVICE_ID_COMPAQ_42XX 0x0046

#define PCI_VENDOR_ID_CIRRUS 0x1013
#define PCI_DEVICE_ID_CIRRUS_7548 0x0038
#define PCI_DEVICE_ID_CIRRUS_5430 0x00a0
#define PCI_DEVICE_ID_CIRRUS_5434_4 0x00a4
#define PCI_DEVICE_ID_CIRRUS_5434_8 0x00a8
#define PCI_DEVICE_ID_CIRRUS_5436 0x00ac
#define PCI_DEVICE_ID_CIRRUS_5446 0x00b8
#define PCI_DEVICE_ID_CIRRUS_5480 0x00bc
#define PCI_DEVICE_ID_CIRRUS_5462 0x00d0
#define PCI_DEVICE_ID_CIRRUS_5464 0x00d4
#define PCI_DEVICE_ID_CIRRUS_5465 0x00d6
#define PCI_DEVICE_ID_CIRRUS_6729 0x1100
#define PCI_DEVICE_ID_CIRRUS_6832 0x1110
#define PCI_DEVICE_ID_CIRRUS_7542 0x1200
#define PCI_DEVICE_ID_CIRRUS_7543 0x1202
#define PCI_DEVICE_ID_CIRRUS_7541 0x1204

#define PCI_VENDOR_ID_IBM 0x1014
#define PCI_DEVICE_ID_IBM_FIRE_CORAL 0x000a
#define PCI_DEVICE_ID_IBM_TR 0x0018
#define PCI_DEVICE_ID_IBM_82G2675 0x001d
#define PCI_DEVICE_ID_IBM_MCA 0x0020
#define PCI_DEVICE_ID_IBM_82351 0x0022
#define PCI_DEVICE_ID_IBM_PYTHON 0x002d
#define PCI_DEVICE_ID_IBM_SERVERAID 0x002e
#define PCI_DEVICE_ID_IBM_TR_WAKE 0x003e
#define PCI_DEVICE_ID_IBM_MPIC 0x0046
#define PCI_DEVICE_ID_IBM_3780IDSP 0x007d
#define PCI_DEVICE_ID_IBM_CHUKAR 0x0096
#define PCI_DEVICE_ID_IBM_CPC710_PCI64 0x00fc
#define PCI_DEVICE_ID_IBM_CPC710_PCI32 0x0105
#define PCI_DEVICE_ID_IBM_405GP 0x0156
#define PCI_DEVICE_ID_IBM_SERVERAIDI960 0x01bd
#define PCI_DEVICE_ID_IBM_MPIC_2 0xffff

#define PCI_VENDOR_ID_COMPEX2 0x101a
#define PCI_DEVICE_ID_COMPEX2_100VG 0x0005

#define PCI_VENDOR_ID_WD 0x101c
#define PCI_DEVICE_ID_WD_7197 0x3296
#define PCI_DEVICE_ID_WD_90C 0xc24a

#define PCI_VENDOR_ID_AMI 0x101e
#define PCI_DEVICE_ID_AMI_MEGARAID3 0x1960
#define PCI_DEVICE_ID_AMI_MEGARAID 0x9010
#define PCI_DEVICE_ID_AMI_MEGARAID2 0x9060

#define PCI_VENDOR_ID_AMD 0x1022
#define PCI_DEVICE_ID_AMD_LANCE 0x2000
#define PCI_DEVICE_ID_AMD_LANCE_HOME 0x2001
#define PCI_DEVICE_ID_AMD_SCSI 0x2020
#define PCI_DEVICE_ID_AMD_LX_AES 0x2082
#define PCI_DEVICE_ID_AMD_CS5536_ISA 0x2090
#define PCI_DEVICE_ID_AMD_CS5536_IDE 0x209A
#define PCI_DEVICE_ID_AMD_SERENADE 0x36c0
#define PCI_DEVICE_ID_AMD_FE_GATE_7006 0x7006
#define PCI_DEVICE_ID_AMD_FE_GATE_7007 0x7007
#define PCI_DEVICE_ID_AMD_FE_GATE_700C 0x700C
#define PCI_DEVICE_ID_AMD_FE_GATE_700D 0x700D
#define PCI_DEVICE_ID_AMD_FE_GATE_700E 0x700E
#define PCI_DEVICE_ID_AMD_FE_GATE_700F 0x700F
#define PCI_DEVICE_ID_AMD_COBRA_7400 0x7400
#define PCI_DEVICE_ID_AMD_COBRA_7401 0x7401
#define PCI_DEVICE_ID_AMD_COBRA_7403 0x7403
#define PCI_DEVICE_ID_AMD_COBRA_7404 0x7404
#define PCI_DEVICE_ID_AMD_VIPER_7408 0x7408
#define PCI_DEVICE_ID_AMD_VIPER_7409 0x7409
#define PCI_DEVICE_ID_AMD_VIPER_740B 0x740B
#define PCI_DEVICE_ID_AMD_VIPER_740C 0x740C
#define PCI_DEVICE_ID_AMD_VIPER_7410 0x7410
#define PCI_DEVICE_ID_AMD_VIPER_7411 0x7411
#define PCI_DEVICE_ID_AMD_VIPER_7413 0x7413
#define PCI_DEVICE_ID_AMD_VIPER_7414 0x7414
#define PCI_DEVICE_ID_AMD_OPUS_7440 0x7440
#define PCI_DEVICE_ID_AMD_VIPER_7440 PCI_DEVICE_ID_AMD_OPUS_7440
#define PCI_DEVICE_ID_AMD_OPUS_7441 0x7441
#define PCI_DEVICE_ID_AMD_VIPER_7441 PCI_DEVICE_ID_AMD_OPUS_7441
#define PCI_DEVICE_ID_AMD_OPUS_7443 0x7443
#define PCI_DEVICE_ID_AMD_VIPER_7443 PCI_DEVICE_ID_AMD_OPUS_7443
#define PCI_DEVICE_ID_AMD_OPUS_7445 0x7445
#define PCI_DEVICE_ID_AMD_OPUS_7448 0x7448
#define PCI_DEVICE_ID_AMD_VIPER_7448 PCI_DEVICE_ID_AMD_OPUS_7448
#define PCI_DEVICE_ID_AMD_OPUS_7449 0x7449
#define PCI_DEVICE_ID_AMD_VIPER_7449 PCI_DEVICE_ID_AMD_OPUS_7449
#define PCI_DEVICE_ID_AMD_8111_LAN 0x7462
#define PCI_DEVICE_ID_AMD_8111_IDE 0x7469
#define PCI_DEVICE_ID_AMD_8111_AUDIO 0x746d
#define PCI_DEVICE_ID_AMD_8131_APIC 0x7450

#define PCI_VENDOR_ID_TRIDENT 0x1023
#define PCI_DEVICE_ID_TRIDENT_4DWAVE_DX 0x2000
#define PCI_DEVICE_ID_TRIDENT_4DWAVE_NX 0x2001
#define PCI_DEVICE_ID_TRIDENT_9320 0x9320
#define PCI_DEVICE_ID_TRIDENT_9388 0x9388
#define PCI_DEVICE_ID_TRIDENT_9397 0x9397
#define PCI_DEVICE_ID_TRIDENT_939A 0x939A
#define PCI_DEVICE_ID_TRIDENT_9520 0x9520
#define PCI_DEVICE_ID_TRIDENT_9525 0x9525
#define PCI_DEVICE_ID_TRIDENT_9420 0x9420
#define PCI_DEVICE_ID_TRIDENT_9440 0x9440
#define PCI_DEVICE_ID_TRIDENT_9660 0x9660
#define PCI_DEVICE_ID_TRIDENT_9750 0x9750
#define PCI_DEVICE_ID_TRIDENT_9850 0x9850
#define PCI_DEVICE_ID_TRIDENT_9880 0x9880
#define PCI_DEVICE_ID_TRIDENT_8400 0x8400
#define PCI_DEVICE_ID_TRIDENT_8420 0x8420
#define PCI_DEVICE_ID_TRIDENT_8500 0x8500

#define PCI_VENDOR_ID_AI 0x1025
#define PCI_DEVICE_ID_AI_M1435 0x1435

#define PCI_VENDOR_ID_DELL 0x1028

#define PCI_VENDOR_ID_MATROX 0x102B
#define PCI_DEVICE_ID_MATROX_MGA_2 0x0518
#define PCI_DEVICE_ID_MATROX_MIL 0x0519
#define PCI_DEVICE_ID_MATROX_MYS 0x051A
#define PCI_DEVICE_ID_MATROX_MIL_2 0x051b
#define PCI_DEVICE_ID_MATROX_MIL_2_AGP 0x051f
#define PCI_DEVICE_ID_MATROX_MGA_IMP 0x0d10
#define PCI_DEVICE_ID_MATROX_G100_MM 0x1000
#define PCI_DEVICE_ID_MATROX_G100_AGP 0x1001
#define PCI_DEVICE_ID_MATROX_G200_PCI 0x0520
#define PCI_DEVICE_ID_MATROX_G200_AGP 0x0521
#define PCI_DEVICE_ID_MATROX_G400 0x0525
#define PCI_DEVICE_ID_MATROX_G550 0x2527
#define PCI_DEVICE_ID_MATROX_VIA 0x4536

#define PCI_VENDOR_ID_CT 0x102c
#define PCI_DEVICE_ID_CT_65545 0x00d8
#define PCI_DEVICE_ID_CT_65548 0x00dc
#define PCI_DEVICE_ID_CT_65550 0x00e0
#define PCI_DEVICE_ID_CT_65554 0x00e4
#define PCI_DEVICE_ID_CT_65555 0x00e5

#define PCI_VENDOR_ID_MIRO 0x1031
#define PCI_DEVICE_ID_MIRO_36050 0x5601

#define PCI_VENDOR_ID_NEC 0x1033
#define PCI_DEVICE_ID_NEC_NAPCCARD 0x003e
#define PCI_DEVICE_ID_NEC_PCX2 0x0046
#define PCI_DEVICE_ID_NEC_NILE4 0x005a
#define PCI_DEVICE_ID_NEC_VRC5476 0x009b
#define PCI_DEVICE_ID_NEC_VRC4173 0x00a5
#define PCI_DEVICE_ID_NEC_VRC5477_AC97 0x00a6

#define PCI_VENDOR_ID_FD 0x1036
#define PCI_DEVICE_ID_FD_36C70 0x0000

#define PCI_VENDOR_ID_SI 0x1039
#define PCI_DEVICE_ID_SI_5591_AGP 0x0001
#define PCI_DEVICE_ID_SI_6202 0x0002
#define PCI_DEVICE_ID_SI_503 0x0008
#define PCI_DEVICE_ID_SI_ACPI 0x0009
#define PCI_DEVICE_ID_SI_5597_VGA 0x0200
#define PCI_DEVICE_ID_SI_6205 0x0205
#define PCI_DEVICE_ID_SI_501 0x0406
#define PCI_DEVICE_ID_SI_496 0x0496
#define PCI_DEVICE_ID_SI_300 0x0300
#define PCI_DEVICE_ID_SI_315H 0x0310
#define PCI_DEVICE_ID_SI_315 0x0315
#define PCI_DEVICE_ID_SI_315PRO 0x0325
#define PCI_DEVICE_ID_SI_530 0x0530
#define PCI_DEVICE_ID_SI_540 0x0540
#define PCI_DEVICE_ID_SI_550 0x0550
#define PCI_DEVICE_ID_SI_540_VGA 0x5300
#define PCI_DEVICE_ID_SI_550_VGA 0x5315
#define PCI_DEVICE_ID_SI_601 0x0601
#define PCI_DEVICE_ID_SI_620 0x0620
#define PCI_DEVICE_ID_SI_630 0x0630
#define PCI_DEVICE_ID_SI_633 0x0633
#define PCI_DEVICE_ID_SI_635 0x0635
#define PCI_DEVICE_ID_SI_640 0x0640
#define PCI_DEVICE_ID_SI_645 0x0645
#define PCI_DEVICE_ID_SI_646 0x0646
#define PCI_DEVICE_ID_SI_648 0x0648
#define PCI_DEVICE_ID_SI_650 0x0650
#define PCI_DEVICE_ID_SI_651 0x0651
#define PCI_DEVICE_ID_SI_652 0x0652
#define PCI_DEVICE_ID_SI_655 0x0655
#define PCI_DEVICE_ID_SI_730 0x0730
#define PCI_DEVICE_ID_SI_733 0x0733
#define PCI_DEVICE_ID_SI_630_VGA 0x6300
#define PCI_DEVICE_ID_SI_730_VGA 0x7300
#define PCI_DEVICE_ID_SI_735 0x0735
#define PCI_DEVICE_ID_SI_740 0x0740
#define PCI_DEVICE_ID_SI_745 0x0745
#define PCI_DEVICE_ID_SI_746 0x0746
#define PCI_DEVICE_ID_SI_748 0x0748
#define PCI_DEVICE_ID_SI_750 0x0750
#define PCI_DEVICE_ID_SI_751 0x0751
#define PCI_DEVICE_ID_SI_752 0x0752
#define PCI_DEVICE_ID_SI_755 0x0755
#define PCI_DEVICE_ID_SI_900 0x0900
#define PCI_DEVICE_ID_SI_5107 0x5107
#define PCI_DEVICE_ID_SI_5300 0x5300
#define PCI_DEVICE_ID_SI_5511 0x5511
#define PCI_DEVICE_ID_SI_5513 0x5513
#define PCI_DEVICE_ID_SI_5518 0x5518
#define PCI_DEVICE_ID_SI_5571 0x5571
#define PCI_DEVICE_ID_SI_5581 0x5581
#define PCI_DEVICE_ID_SI_5582 0x5582
#define PCI_DEVICE_ID_SI_5591 0x5591
#define PCI_DEVICE_ID_SI_5596 0x5596
#define PCI_DEVICE_ID_SI_5597 0x5597
#define PCI_DEVICE_ID_SI_5598 0x5598
#define PCI_DEVICE_ID_SI_5600 0x5600
#define PCI_DEVICE_ID_SI_6300 0x6300
#define PCI_DEVICE_ID_SI_6306 0x6306
#define PCI_DEVICE_ID_SI_6326 0x6326
#define PCI_DEVICE_ID_SI_7001 0x7001
#define PCI_DEVICE_ID_SI_7012 0x7012
#define PCI_DEVICE_ID_SI_7016 0x7016

#define PCI_VENDOR_ID_HP 0x103c
#define PCI_DEVICE_ID_HP_DONNER_GFX 0x1008
#define PCI_DEVICE_ID_HP_TACHYON 0x1028
#define PCI_DEVICE_ID_HP_TACHLITE 0x1029
#define PCI_DEVICE_ID_HP_J2585A 0x1030
#define PCI_DEVICE_ID_HP_J2585B 0x1031
#define PCI_DEVICE_ID_HP_SAS 0x1048
#define PCI_DEVICE_ID_HP_DIVA1 0x1049
#define PCI_DEVICE_ID_HP_DIVA2 0x104A
#define PCI_DEVICE_ID_HP_SP2_0 0x104B
#define PCI_DEVICE_ID_HP_PCI_LBA 0x1054
#define PCI_DEVICE_ID_HP_REO_SBA 0x10f0
#define PCI_DEVICE_ID_HP_REO_IOC 0x10f1
#define PCI_DEVICE_ID_HP_ZX1_SBA 0x1229
#define PCI_DEVICE_ID_HP_ZX1_IOC 0x122a
#define PCI_DEVICE_ID_HP_PCIX_LBA 0x122e
#define PCI_DEVICE_ID_HP_SX1000_IOC 0x127c
#define PCI_DEVICE_ID_HP_CISS 0x3210
#define PCI_DEVICE_ID_HP_CISSA 0x3220
#define PCI_DEVICE_ID_HP_CISSB 0x3222
#define PCI_DEVICE_ID_HP_CISSC 0x3230
#define PCI_DEVICE_ID_HP_CISSD 0x3238

#define PCI_VENDOR_ID_PCTECH 0x1042
#define PCI_DEVICE_ID_PCTECH_RZ1000 0x1000
#define PCI_DEVICE_ID_PCTECH_RZ1001 0x1001
#define PCI_DEVICE_ID_PCTECH_SAMURAI_0 0x3000
#define PCI_DEVICE_ID_PCTECH_SAMURAI_1 0x3010
#define PCI_DEVICE_ID_PCTECH_SAMURAI_IDE 0x3020

#define PCI_VENDOR_ID_ASUSTEK 0x1043
#define PCI_DEVICE_ID_ASUSTEK_0675 0x0675

#define PCI_VENDOR_ID_DPT 0x1044
#define PCI_DEVICE_ID_DPT 0xa400

#define PCI_VENDOR_ID_OPTI 0x1045
#define PCI_DEVICE_ID_OPTI_92C178 0xc178
#define PCI_DEVICE_ID_OPTI_82C557 0xc557
#define PCI_DEVICE_ID_OPTI_82C558 0xc558
#define PCI_DEVICE_ID_OPTI_82C621 0xc621
#define PCI_DEVICE_ID_OPTI_82C700 0xc700
#define PCI_DEVICE_ID_OPTI_82C701 0xc701
#define PCI_DEVICE_ID_OPTI_82C814 0xc814
#define PCI_DEVICE_ID_OPTI_82C822 0xc822
#define PCI_DEVICE_ID_OPTI_82C861 0xc861
#define PCI_DEVICE_ID_OPTI_82C825 0xd568

#define PCI_VENDOR_ID_ELSA 0x1048
#define PCI_DEVICE_ID_ELSA_MICROLINK 0x1000
#define PCI_DEVICE_ID_ELSA_QS3000 0x3000

#define PCI_VENDOR_ID_SGS 0x104a
#define PCI_DEVICE_ID_SGS_2000 0x0008
#define PCI_DEVICE_ID_SGS_1764 0x0009

#define PCI_VENDOR_ID_BUSLOGIC 0x104B
#define PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC 0x0140
#define PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER 0x1040
#define PCI_DEVICE_ID_BUSLOGIC_FLASHPOINT 0x8130

#define PCI_VENDOR_ID_TI 0x104c
#define PCI_DEVICE_ID_TI_TVP4010 0x3d04
#define PCI_DEVICE_ID_TI_TVP4020 0x3d07
#define PCI_DEVICE_ID_TI_1130 0xac12
#define PCI_DEVICE_ID_TI_1031 0xac13
#define PCI_DEVICE_ID_TI_1131 0xac15
#define PCI_DEVICE_ID_TI_1250 0xac16
#define PCI_DEVICE_ID_TI_1220 0xac17
#define PCI_DEVICE_ID_TI_1221 0xac19
#define PCI_DEVICE_ID_TI_1210 0xac1a
#define PCI_DEVICE_ID_TI_1410 0xac50
#define PCI_DEVICE_ID_TI_1450 0xac1b
#define PCI_DEVICE_ID_TI_1225 0xac1c
#define PCI_DEVICE_ID_TI_1251A 0xac1d
#define PCI_DEVICE_ID_TI_1211 0xac1e
#define PCI_DEVICE_ID_TI_1251B 0xac1f
#define PCI_DEVICE_ID_TI_4410 0xac41
#define PCI_DEVICE_ID_TI_4451 0xac42
#define PCI_DEVICE_ID_TI_1420 0xac51
#define PCI_DEVICE_ID_TI_1520 0xac55
#define PCI_DEVICE_ID_TI_1510 0xac56

#define PCI_VENDOR_ID_SONY 0x104d
#define PCI_DEVICE_ID_SONY_CXD3222 0x8039

#define PCI_VENDOR_ID_OAK 0x104e
#define PCI_DEVICE_ID_OAK_OTI107 0x0107


#define PCI_VENDOR_ID_WINBOND2 0x1050
#define PCI_DEVICE_ID_WINBOND2_89C940 0x0940
#define PCI_DEVICE_ID_WINBOND2_89C940F 0x5a5a
#define PCI_DEVICE_ID_WINBOND2_6692 0x6692

#define PCI_VENDOR_ID_ANIGMA 0x1051
#define PCI_DEVICE_ID_ANIGMA_MC145575 0x0100

#define PCI_VENDOR_ID_EFAR 0x1055
#define PCI_DEVICE_ID_EFAR_SLC90E66_1 0x9130
#define PCI_DEVICE_ID_EFAR_SLC90E66_0 0x9460
#define PCI_DEVICE_ID_EFAR_SLC90E66_2 0x9462
#define PCI_DEVICE_ID_EFAR_SLC90E66_3 0x9463

#define PCI_VENDOR_ID_MOTOROLA 0x1057
#define PCI_VENDOR_ID_MOTOROLA_OOPS 0x1507
#define PCI_DEVICE_ID_MOTOROLA_MPC105 0x0001
#define PCI_DEVICE_ID_MOTOROLA_MPC106 0x0002
#define PCI_DEVICE_ID_MOTOROLA_MPC107 0x0004
#define PCI_DEVICE_ID_MOTOROLA_RAVEN 0x4801
#define PCI_DEVICE_ID_MOTOROLA_FALCON 0x4802
#define PCI_DEVICE_ID_MOTOROLA_HAWK 0x4803
#define PCI_DEVICE_ID_MOTOROLA_CPX8216 0x4806

#define PCI_VENDOR_ID_PROMISE 0x105a
#define PCI_DEVICE_ID_PROMISE_20265 0x0d30
#define PCI_DEVICE_ID_PROMISE_20267 0x4d30
#define PCI_DEVICE_ID_PROMISE_20246 0x4d33
#define PCI_DEVICE_ID_PROMISE_20262 0x4d38
#define PCI_DEVICE_ID_PROMISE_20263 0x0D38
#define PCI_DEVICE_ID_PROMISE_20268 0x4d68
#define PCI_DEVICE_ID_PROMISE_20270 0x6268
#define PCI_DEVICE_ID_PROMISE_20269 0x4d69
#define PCI_DEVICE_ID_PROMISE_20271 0x6269
#define PCI_DEVICE_ID_PROMISE_20275 0x1275
#define PCI_DEVICE_ID_PROMISE_20276 0x5275
#define PCI_DEVICE_ID_PROMISE_20277 0x7275
#define PCI_DEVICE_ID_PROMISE_5300 0x5300

#define PCI_VENDOR_ID_N9 0x105d
#define PCI_DEVICE_ID_N9_I128 0x2309
#define PCI_DEVICE_ID_N9_I128_2 0x2339
#define PCI_DEVICE_ID_N9_I128_T2R 0x493d

#define PCI_VENDOR_ID_UMC 0x1060
#define PCI_DEVICE_ID_UMC_UM8673F 0x0101
#define PCI_DEVICE_ID_UMC_UM8891A 0x0891
#define PCI_DEVICE_ID_UMC_UM8886BF 0x673a
#define PCI_DEVICE_ID_UMC_UM8886A 0x886a
#define PCI_DEVICE_ID_UMC_UM8881F 0x8881
#define PCI_DEVICE_ID_UMC_UM8886F 0x8886
#define PCI_DEVICE_ID_UMC_UM9017F 0x9017
#define PCI_DEVICE_ID_UMC_UM8886N 0xe886
#define PCI_DEVICE_ID_UMC_UM8891N 0xe891

#define PCI_VENDOR_ID_X 0x1061
#define PCI_DEVICE_ID_X_AGX016 0x0001

#define PCI_VENDOR_ID_MYLEX 0x1069
#define PCI_DEVICE_ID_MYLEX_DAC960_P 0x0001
#define PCI_DEVICE_ID_MYLEX_DAC960_PD 0x0002
#define PCI_DEVICE_ID_MYLEX_DAC960_PG 0x0010
#define PCI_DEVICE_ID_MYLEX_DAC960_LA 0x0020
#define PCI_DEVICE_ID_MYLEX_DAC960_LP 0x0050
#define PCI_DEVICE_ID_MYLEX_DAC960_BA 0xBA56

#define PCI_VENDOR_ID_PICOP 0x1066
#define PCI_DEVICE_ID_PICOP_PT86C52X 0x0001
#define PCI_DEVICE_ID_PICOP_PT80C524 0x8002

#define PCI_VENDOR_ID_APPLE 0x106b
#define PCI_DEVICE_ID_APPLE_BANDIT 0x0001
#define PCI_DEVICE_ID_APPLE_GC 0x0002
#define PCI_DEVICE_ID_APPLE_HYDRA 0x000e
#define PCI_DEVICE_ID_APPLE_UNI_N_FW 0x0018
#define PCI_DEVICE_ID_APPLE_KL_USB 0x0019
#define PCI_DEVICE_ID_APPLE_UNI_N_AGP 0x0020
#define PCI_DEVICE_ID_APPLE_UNI_N_GMAC 0x0021
#define PCI_DEVICE_ID_APPLE_KEYLARGO 0x0022
#define PCI_DEVICE_ID_APPLE_UNI_N_GMACP 0x0024
#define PCI_DEVICE_ID_APPLE_KEYLARGO_P 0x0025
#define PCI_DEVICE_ID_APPLE_KL_USB_P 0x0026
#define PCI_DEVICE_ID_APPLE_UNI_N_AGP_P 0x0027
#define PCI_DEVICE_ID_APPLE_UNI_N_AGP15 0x002d
#define PCI_DEVICE_ID_APPLE_UNI_N_FW2 0x0030
#define PCI_DEVICE_ID_APPLE_UNI_N_GMAC2 0x0032
#define PCI_DEVICE_ID_APPLE_TIGON3 0x1645

#define PCI_VENDOR_ID_YAMAHA 0x1073
#define PCI_DEVICE_ID_YAMAHA_724 0x0004
#define PCI_DEVICE_ID_YAMAHA_724F 0x000d
#define PCI_DEVICE_ID_YAMAHA_740 0x000a
#define PCI_DEVICE_ID_YAMAHA_740C 0x000c
#define PCI_DEVICE_ID_YAMAHA_744 0x0010
#define PCI_DEVICE_ID_YAMAHA_754 0x0012

#define PCI_VENDOR_ID_NEXGEN 0x1074
#define PCI_DEVICE_ID_NEXGEN_82C501 0x4e78

#define PCI_VENDOR_ID_QLOGIC 0x1077
#define PCI_DEVICE_ID_QLOGIC_ISP1020 0x1020
#define PCI_DEVICE_ID_QLOGIC_ISP1022 0x1022
#define PCI_DEVICE_ID_QLOGIC_ISP2100 0x2100
#define PCI_DEVICE_ID_QLOGIC_ISP2200 0x2200

#define PCI_VENDOR_ID_CYRIX 0x1078
#define PCI_DEVICE_ID_CYRIX_5510 0x0000
#define PCI_DEVICE_ID_CYRIX_PCI_MASTER 0x0001
#define PCI_DEVICE_ID_CYRIX_5520 0x0002
#define PCI_DEVICE_ID_CYRIX_5530_LEGACY 0x0100
#define PCI_DEVICE_ID_CYRIX_5530_SMI 0x0101
#define PCI_DEVICE_ID_CYRIX_5530_IDE 0x0102
#define PCI_DEVICE_ID_CYRIX_5530_AUDIO 0x0103
#define PCI_DEVICE_ID_CYRIX_5530_VIDEO 0x0104

#define PCI_VENDOR_ID_LEADTEK 0x107d
#define PCI_DEVICE_ID_LEADTEK_805 0x0000

#define PCI_VENDOR_ID_INTERPHASE 0x107e
#define PCI_DEVICE_ID_INTERPHASE_5526 0x0004
#define PCI_DEVICE_ID_INTERPHASE_55x6 0x0005
#define PCI_DEVICE_ID_INTERPHASE_5575 0x0008

#define PCI_VENDOR_ID_CONTAQ 0x1080
#define PCI_DEVICE_ID_CONTAQ_82C599 0x0600
#define PCI_DEVICE_ID_CONTAQ_82C693 0xc693

#define PCI_VENDOR_ID_FOREX 0x1083

#define PCI_VENDOR_ID_OLICOM 0x108d
#define PCI_DEVICE_ID_OLICOM_OC3136 0x0001
#define PCI_DEVICE_ID_OLICOM_OC2315 0x0011
#define PCI_DEVICE_ID_OLICOM_OC2325 0x0012
#define PCI_DEVICE_ID_OLICOM_OC2183 0x0013
#define PCI_DEVICE_ID_OLICOM_OC2326 0x0014
#define PCI_DEVICE_ID_OLICOM_OC6151 0x0021

#define PCI_VENDOR_ID_SUN 0x108e
#define PCI_DEVICE_ID_SUN_EBUS 0x1000
#define PCI_DEVICE_ID_SUN_HAPPYMEAL 0x1001
#define PCI_DEVICE_ID_SUN_RIO_EBUS 0x1100
#define PCI_DEVICE_ID_SUN_RIO_GEM 0x1101
#define PCI_DEVICE_ID_SUN_RIO_1394 0x1102
#define PCI_DEVICE_ID_SUN_RIO_USB 0x1103
#define PCI_DEVICE_ID_SUN_GEM 0x2bad
#define PCI_DEVICE_ID_SUN_SIMBA 0x5000
#define PCI_DEVICE_ID_SUN_PBM 0x8000
#define PCI_DEVICE_ID_SUN_SCHIZO 0x8001
#define PCI_DEVICE_ID_SUN_SABRE 0xa000
#define PCI_DEVICE_ID_SUN_HUMMINGBIRD 0xa001
#define PCI_DEVICE_ID_SUN_TOMATILLO 0xa801

#define PCI_VENDOR_ID_CMD 0x1095
#define PCI_DEVICE_ID_SII_1210SA 0x0240

#define PCI_DEVICE_ID_CMD_640 0x0640
#define PCI_DEVICE_ID_CMD_643 0x0643
#define PCI_DEVICE_ID_CMD_646 0x0646
#define PCI_DEVICE_ID_CMD_647 0x0647
#define PCI_DEVICE_ID_CMD_648 0x0648
#define PCI_DEVICE_ID_CMD_649 0x0649
#define PCI_DEVICE_ID_CMD_670 0x0670

#define PCI_DEVICE_ID_SII_680 0x0680
#define PCI_DEVICE_ID_SII_3112 0x3112

#define PCI_VENDOR_ID_VISION 0x1098
#define PCI_DEVICE_ID_VISION_QD8500 0x0001
#define PCI_DEVICE_ID_VISION_QD8580 0x0002

#define PCI_VENDOR_ID_BROOKTREE 0x109e
#define PCI_DEVICE_ID_BROOKTREE_848 0x0350
#define PCI_DEVICE_ID_BROOKTREE_849A 0x0351
#define PCI_DEVICE_ID_BROOKTREE_878_1 0x036e
#define PCI_DEVICE_ID_BROOKTREE_878 0x0878
#define PCI_DEVICE_ID_BROOKTREE_8474 0x8474

#define PCI_VENDOR_ID_SIERRA 0x10a8
#define PCI_DEVICE_ID_SIERRA_STB 0x0000

#define PCI_VENDOR_ID_SGI 0x10a9
#define PCI_DEVICE_ID_SGI_IOC3 0x0003
#define PCI_DEVICE_ID_SGI_IOC4 0x100a

#define PCI_VENDOR_ID_ACC 0x10aa
#define PCI_DEVICE_ID_ACC_2056 0x0000

#define PCI_VENDOR_ID_WINBOND 0x10ad
#define PCI_DEVICE_ID_WINBOND_83769 0x0001
#define PCI_DEVICE_ID_WINBOND_82C105 0x0105
#define PCI_DEVICE_ID_WINBOND_83C553 0x0565

#define PCI_VENDOR_ID_DATABOOK 0x10b3
#define PCI_DEVICE_ID_DATABOOK_87144 0xb106

#define PCI_VENDOR_ID_PLX 0x10b5
#define PCI_DEVICE_ID_PLX_R685 0x1030
#define PCI_DEVICE_ID_PLX_ROMULUS 0x106a
#define PCI_DEVICE_ID_PLX_SPCOM800 0x1076
#define PCI_DEVICE_ID_PLX_1077 0x1077
#define PCI_DEVICE_ID_PLX_SPCOM200 0x1103
#define PCI_DEVICE_ID_PLX_DJINN_ITOO 0x1151
#define PCI_DEVICE_ID_PLX_R753 0x1152
#define PCI_DEVICE_ID_PLX_9050 0x9050
#define PCI_DEVICE_ID_PLX_9060 0x9060
#define PCI_DEVICE_ID_PLX_9060ES 0x906E
#define PCI_DEVICE_ID_PLX_9060SD 0x906D
#define PCI_DEVICE_ID_PLX_9080 0x9080
#define PCI_DEVICE_ID_PLX_GTEK_SERIAL2 0xa001

#define PCI_VENDOR_ID_MADGE 0x10b6
#define PCI_DEVICE_ID_MADGE_MK2 0x0002
#define PCI_DEVICE_ID_MADGE_C155S 0x1001

#define PCI_VENDOR_ID_3COM 0x10b7
#define PCI_DEVICE_ID_3COM_3C985 0x0001
#define PCI_DEVICE_ID_3COM_3C339 0x3390
#define PCI_DEVICE_ID_3COM_3C590 0x5900
#define PCI_DEVICE_ID_3COM_3C595TX 0x5950
#define PCI_DEVICE_ID_3COM_3C595T4 0x5951
#define PCI_DEVICE_ID_3COM_3C595MII 0x5952
#define PCI_DEVICE_ID_3COM_3C900TPO 0x9000
#define PCI_DEVICE_ID_3COM_3C900COMBO 0x9001
#define PCI_DEVICE_ID_3COM_3C905TX 0x9050
#define PCI_DEVICE_ID_3COM_3C905T4 0x9051
#define PCI_DEVICE_ID_3COM_3C905B_TX 0x9055
#define PCI_DEVICE_ID_3COM_3CR990 0x9900
#define PCI_DEVICE_ID_3COM_3CR990_TX_95 0x9902
#define PCI_DEVICE_ID_3COM_3CR990_TX_97 0x9903
#define PCI_DEVICE_ID_3COM_3CR990B 0x9904
#define PCI_DEVICE_ID_3COM_3CR990_FX 0x9905
#define PCI_DEVICE_ID_3COM_3CR990SVR95 0x9908
#define PCI_DEVICE_ID_3COM_3CR990SVR97 0x9909
#define PCI_DEVICE_ID_3COM_3CR990SVR 0x990a

#define PCI_VENDOR_ID_SMC 0x10b8
#define PCI_DEVICE_ID_SMC_EPIC100 0x0005

#define PCI_VENDOR_ID_AL 0x10b9
#define PCI_DEVICE_ID_AL_M1445 0x1445
#define PCI_DEVICE_ID_AL_M1449 0x1449
#define PCI_DEVICE_ID_AL_M1451 0x1451
#define PCI_DEVICE_ID_AL_M1461 0x1461
#define PCI_DEVICE_ID_AL_M1489 0x1489
#define PCI_DEVICE_ID_AL_M1511 0x1511
#define PCI_DEVICE_ID_AL_M1513 0x1513
#define PCI_DEVICE_ID_AL_M1521 0x1521
#define PCI_DEVICE_ID_AL_M1523 0x1523
#define PCI_DEVICE_ID_AL_M1531 0x1531
#define PCI_DEVICE_ID_AL_M1533 0x1533
#define PCI_DEVICE_ID_AL_M1535 0x1535
#define PCI_DEVICE_ID_AL_M1541 0x1541
#define PCI_DEVICE_ID_AL_M1621 0x1621
#define PCI_DEVICE_ID_AL_M1631 0x1631
#define PCI_DEVICE_ID_AL_M1641 0x1641
#define PCI_DEVICE_ID_AL_M1644 0x1644
#define PCI_DEVICE_ID_AL_M1647 0x1647
#define PCI_DEVICE_ID_AL_M1651 0x1651
#define PCI_DEVICE_ID_AL_M1543 0x1543
#define PCI_DEVICE_ID_AL_M3307 0x3307
#define PCI_DEVICE_ID_AL_M4803 0x5215
#define PCI_DEVICE_ID_AL_M5219 0x5219
#define PCI_DEVICE_ID_AL_M5229 0x5229
#define PCI_DEVICE_ID_AL_M5237 0x5237
#define PCI_DEVICE_ID_AL_M5243 0x5243
#define PCI_DEVICE_ID_AL_M5451 0x5451
#define PCI_DEVICE_ID_AL_M7101 0x7101

#define PCI_VENDOR_ID_MITSUBISHI 0x10ba

#define PCI_VENDOR_ID_SURECOM 0x10bd
#define PCI_DEVICE_ID_SURECOM_NE34 0x0e34

#define PCI_VENDOR_ID_NEOMAGIC 0x10c8
#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_NM2070 0x0001
#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128V 0x0002
#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128ZV 0x0003
#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_NM2160 0x0004
#define PCI_DEVICE_ID_NEOMAGIC_MAGICMEDIA_256AV 0x0005
#define PCI_DEVICE_ID_NEOMAGIC_MAGICGRAPH_128ZVPLUS 0x0083

#define PCI_VENDOR_ID_ASP 0x10cd
#define PCI_DEVICE_ID_ASP_ABP940 0x1200
#define PCI_DEVICE_ID_ASP_ABP940U 0x1300
#define PCI_DEVICE_ID_ASP_ABP940UW 0x2300

#define PCI_VENDOR_ID_MACRONIX 0x10d9
#define PCI_DEVICE_ID_MACRONIX_MX98713 0x0512
#define PCI_DEVICE_ID_MACRONIX_MX987x5 0x0531

#define PCI_VENDOR_ID_TCONRAD 0x10da
#define PCI_DEVICE_ID_TCONRAD_TOKENRING 0x0508

#define PCI_VENDOR_ID_CERN 0x10dc
#define PCI_DEVICE_ID_CERN_SPSB_PMC 0x0001
#define PCI_DEVICE_ID_CERN_SPSB_PCI 0x0002
#define PCI_DEVICE_ID_CERN_HIPPI_DST 0x0021
#define PCI_DEVICE_ID_CERN_HIPPI_SRC 0x0022

#define PCI_VENDOR_ID_NVIDIA 0x10de
#define PCI_DEVICE_ID_NVIDIA_TNT 0x0020
#define PCI_DEVICE_ID_NVIDIA_TNT2 0x0028
#define PCI_DEVICE_ID_NVIDIA_UTNT2 0x0029
#define PCI_DEVICE_ID_NVIDIA_VTNT2 0x002C
#define PCI_DEVICE_ID_NVIDIA_UVTNT2 0x002D
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP04_IDE 0x0035
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP04_SATA 0x0036
#define PCI_DEVICE_ID_NVIDIA_NVENET_10 0x0037
#define PCI_DEVICE_ID_NVIDIA_NVENET_11 0x0038
#define PCI_DEVICE_ID_NVIDIA_MCP04_AUDIO 0x003a
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP04_SATA2 0x003e
#define PCI_DEVICE_ID_NVIDIA_NFORCE_CK804_IDE 0x0053
#define PCI_DEVICE_ID_NVIDIA_NFORCE_CK804_SATA 0x0054
#define PCI_DEVICE_ID_NVIDIA_NFORCE_CK804_SATA2 0x0055
#define PCI_DEVICE_ID_NVIDIA_NVENET_8 0x0056
#define PCI_DEVICE_ID_NVIDIA_NVENET_9 0x0057
#define PCI_DEVICE_ID_NVIDIA_CK804_AUDIO 0x0059
#define PCI_DEVICE_ID_NVIDIA_NFORCE2_IDE 0x0065
#define PCI_DEVICE_ID_NVIDIA_NVENET_2 0x0066
#define PCI_DEVICE_ID_NVIDIA_MCP2_AUDIO 0x006a
#define PCI_DEVICE_ID_NVIDIA_NFORCE2S_IDE 0x0085
#define PCI_DEVICE_ID_NVIDIA_NVENET_4 0x0086
#define PCI_DEVICE_ID_NVIDIA_NVENET_5 0x008c
#define PCI_DEVICE_ID_NVIDIA_MCP2S_AUDIO 0x008a
#define PCI_DEVICE_ID_NVIDIA_NFORCE2S_SATA 0x008e
#define PCI_DEVICE_ID_NVIDIA_ITNT2 0x00A0
#define PCI_DEVICE_ID_NVIDIA_NFORCE3 0x00d1
#define PCI_DEVICE_ID_NVIDIA_NFORCE3_IDE 0x00d5
#define PCI_DEVICE_ID_NVIDIA_NVENET_3 0x00d6
#define PCI_DEVICE_ID_NVIDIA_MCP3_AUDIO 0x00da
#define PCI_DEVICE_ID_NVIDIA_NVENET_7 0x00df
#define PCI_DEVICE_ID_NVIDIA_NFORCE3S 0x00e1
#define PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA 0x00e3
#define PCI_DEVICE_ID_NVIDIA_NFORCE3S_IDE 0x00e5
#define PCI_DEVICE_ID_NVIDIA_NVENET_6 0x00e6
#define PCI_DEVICE_ID_NVIDIA_CK8S_AUDIO 0x00ea
#define PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA2 0x00ee
#define PCI_DEVICE_ID_NVIDIA_GEFORCE_SDR 0x0100
#define PCI_DEVICE_ID_NVIDIA_GEFORCE_DDR 0x0101
#define PCI_DEVICE_ID_NVIDIA_QUADRO 0x0103
#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX 0x0110
#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX2 0x0111
#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_GO 0x0112
#define PCI_DEVICE_ID_NVIDIA_QUADRO2_MXR 0x0113
#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS 0x0150
#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS2 0x0151
#define PCI_DEVICE_ID_NVIDIA_GEFORCE2_ULTRA 0x0152
#define PCI_DEVICE_ID_NVIDIA_QUADRO2_PRO 0x0153
#define PCI_DEVICE_ID_NVIDIA_IGEFORCE2 0x01a0
#define PCI_DEVICE_ID_NVIDIA_NFORCE 0x01a4
#define PCI_DEVICE_ID_NVIDIA_MCP1_AUDIO 0x01b1
#define PCI_DEVICE_ID_NVIDIA_NFORCE_IDE 0x01bc
#define PCI_DEVICE_ID_NVIDIA_NVENET_1 0x01c3
#define PCI_DEVICE_ID_NVIDIA_NFORCE2 0x01e0
#define PCI_DEVICE_ID_NVIDIA_GEFORCE3 0x0200
#define PCI_DEVICE_ID_NVIDIA_GEFORCE3_1 0x0201
#define PCI_DEVICE_ID_NVIDIA_GEFORCE3_2 0x0202
#define PCI_DEVICE_ID_NVIDIA_QUADRO_DDC 0x0203
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_IDE 0x0265
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SATA 0x0266
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_SATA2 0x0267
#define PCI_DEVICE_ID_NVIDIA_NVENET_12 0x0268
#define PCI_DEVICE_ID_NVIDIA_NVENET_13 0x0269
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_IDE 0x036E
#define PCI_DEVICE_ID_NVIDIA_NVENET_14 0x0372
#define PCI_DEVICE_ID_NVIDIA_NVENET_15 0x0373
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SATA 0x037E
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP55_SATA2 0x037F
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP61_IDE 0x03EC
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP65_IDE 0x0448
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP67_IDE 0x0560
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP73_IDE 0x056C
#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP77_IDE 0x0759

#define PCI_VENDOR_ID_IMS 0x10e0
#define PCI_DEVICE_ID_IMS_8849 0x8849
#define PCI_DEVICE_ID_IMS_TT128 0x9128
#define PCI_DEVICE_ID_IMS_TT3D 0x9135

#define PCI_VENDOR_ID_TEKRAM2 0x10e1
#define PCI_DEVICE_ID_TEKRAM2_690c 0x690c

#define PCI_VENDOR_ID_TUNDRA 0x10e3
#define PCI_DEVICE_ID_TUNDRA_CA91C042 0x0000

#define PCI_VENDOR_ID_AMCC 0x10e8
#define PCI_DEVICE_ID_AMCC_MYRINET 0x8043
#define PCI_DEVICE_ID_AMCC_PARASTATION 0x8062
#define PCI_DEVICE_ID_AMCC_S5933 0x807d
#define PCI_DEVICE_ID_AMCC_S5933_HEPC3 0x809c

#define PCI_VENDOR_ID_INTERG 0x10ea
#define PCI_DEVICE_ID_INTERG_1680 0x1680
#define PCI_DEVICE_ID_INTERG_1682 0x1682
#define PCI_DEVICE_ID_INTERG_2000 0x2000
#define PCI_DEVICE_ID_INTERG_2010 0x2010
#define PCI_DEVICE_ID_INTERG_5000 0x5000
#define PCI_DEVICE_ID_INTERG_5050 0x5050

#define PCI_VENDOR_ID_REALTEK 0x10ec
#define PCI_DEVICE_ID_REALTEK_8029 0x8029
#define PCI_DEVICE_ID_REALTEK_8129 0x8129
#define PCI_DEVICE_ID_REALTEK_8139 0x8139
#define PCI_DEVICE_ID_REALTEK_8169 0x8169

#define PCI_VENDOR_ID_XILINX 0x10ee
#define PCI_DEVICE_ID_TURBOPAM 0x4020

#define PCI_VENDOR_ID_TRUEVISION 0x10fa
#define PCI_DEVICE_ID_TRUEVISION_T1000 0x000c

#define PCI_VENDOR_ID_INIT 0x1101
#define PCI_DEVICE_ID_INIT_320P 0x9100
#define PCI_DEVICE_ID_INIT_360P 0x9500

#define PCI_VENDOR_ID_CREATIVE 0x1102
#define PCI_DEVICE_ID_CREATIVE_EMU10K1 0x0002

#define PCI_VENDOR_ID_ECTIVA 0x1102
#define PCI_DEVICE_ID_ECTIVA_EV1938 0x8938

#define PCI_VENDOR_ID_TTI 0x1103
#define PCI_DEVICE_ID_TTI_HPT343 0x0003
#define PCI_DEVICE_ID_TTI_HPT366 0x0004
#define PCI_DEVICE_ID_TTI_HPT372 0x0005
#define PCI_DEVICE_ID_TTI_HPT302 0x0006
#define PCI_DEVICE_ID_TTI_HPT371 0x0007
#define PCI_DEVICE_ID_TTI_HPT374 0x0008
#define PCI_DEVICE_ID_TTI_HPT372N 0x0009

#define PCI_VENDOR_ID_VIA 0x1106
#define PCI_DEVICE_ID_VIA_8363_0 0x0305
#define PCI_DEVICE_ID_VIA_8371_0 0x0391
#define PCI_DEVICE_ID_VIA_8501_0 0x0501
#define PCI_DEVICE_ID_VIA_82C505 0x0505
#define PCI_DEVICE_ID_VIA_82C561 0x0561
#define PCI_DEVICE_ID_VIA_82C586_1 0x0571
#define PCI_DEVICE_ID_VIA_82C576 0x0576
#define PCI_DEVICE_ID_VIA_82C585 0x0585
#define PCI_DEVICE_ID_VIA_82C586_0 0x0586
#define PCI_DEVICE_ID_VIA_82C595 0x0595
#define PCI_DEVICE_ID_VIA_82C596 0x0596
#define PCI_DEVICE_ID_VIA_82C597_0 0x0597
#define PCI_DEVICE_ID_VIA_82C598_0 0x0598
#define PCI_DEVICE_ID_VIA_8601_0 0x0601
#define PCI_DEVICE_ID_VIA_8605_0 0x0605
#define PCI_DEVICE_ID_VIA_82C680 0x0680
#define PCI_DEVICE_ID_VIA_82C686 0x0686
#define PCI_DEVICE_ID_VIA_82C691 0x0691
#define PCI_DEVICE_ID_VIA_82C693 0x0693
#define PCI_DEVICE_ID_VIA_82C693_1 0x0698
#define PCI_DEVICE_ID_VIA_82C926 0x0926
#define PCI_DEVICE_ID_VIA_82C576_1 0x1571
#define PCI_DEVICE_ID_VIA_82C595_97 0x1595
#define PCI_DEVICE_ID_VIA_82C586_2 0x3038
#define PCI_DEVICE_ID_VIA_82C586_3 0x3040
#define PCI_DEVICE_ID_VIA_6305 0x3044
#define PCI_DEVICE_ID_VIA_82C596_3 0x3050
#define PCI_DEVICE_ID_VIA_82C596B_3 0x3051
#define PCI_DEVICE_ID_VIA_82C686_4 0x3057
#define PCI_DEVICE_ID_VIA_82C686_5 0x3058
#define PCI_DEVICE_ID_VIA_8233_5 0x3059
#define PCI_DEVICE_ID_VIA_8233_7 0x3065
#define PCI_DEVICE_ID_VIA_82C686_6 0x3068
#define PCI_DEVICE_ID_VIA_8233_0 0x3074
#define PCI_DEVICE_ID_VIA_8633_0 0x3091
#define PCI_DEVICE_ID_VIA_8367_0 0x3099
#define PCI_DEVICE_ID_VIA_8622 0x3102
#define PCI_DEVICE_ID_VIA_8233C_0 0x3109
#define PCI_DEVICE_ID_VIA_8361 0x3112
#define PCI_DEVICE_ID_VIA_8375 0x3116
#define PCI_DEVICE_ID_VIA_CLE266 0x3123
#define PCI_DEVICE_ID_VIA_8233A 0x3147
#define PCI_DEVICE_ID_VIA_P4M266 0x3148
#define PCI_DEVICE_ID_VIA_8237_SATA 0x3149
#define PCI_DEVICE_ID_VIA_P4X333 0x3168
#define PCI_DEVICE_ID_VIA_8235 0x3177
#define PCI_DEVICE_ID_VIA_8377_0 0x3189
#define PCI_DEVICE_ID_VIA_K8T400M_0 0x3188
#define PCI_DEVICE_ID_VIA_8237 0x3227
#define PCI_DEVICE_ID_VIA_8237A 0x3337
#define PCI_DEVICE_ID_VIA_86C100A 0x6100
#define PCI_DEVICE_ID_VIA_8231 0x8231
#define PCI_DEVICE_ID_VIA_8231_4 0x8235
#define PCI_DEVICE_ID_VIA_8365_1 0x8305
#define PCI_DEVICE_ID_VIA_8371_1 0x8391
#define PCI_DEVICE_ID_VIA_8501_1 0x8501
#define PCI_DEVICE_ID_VIA_82C597_1 0x8597
#define PCI_DEVICE_ID_VIA_82C598_1 0x8598
#define PCI_DEVICE_ID_VIA_8601_1 0x8601
#define PCI_DEVICE_ID_VIA_8505_1 0x8605
#define PCI_DEVICE_ID_VIA_8633_1 0xB091
#define PCI_DEVICE_ID_VIA_8367_1 0xB099

#define PCI_VENDOR_ID_SIEMENS 0x110A
#define PCI_DEVICE_ID_SIEMENS_DSCC4 0x2102

#define PCI_VENDOR_ID_SMC2 0x1113
#define PCI_DEVICE_ID_SMC2_1211TX 0x1211

#define PCI_VENDOR_ID_VORTEX 0x1119
#define PCI_DEVICE_ID_VORTEX_GDT60x0 0x0000
#define PCI_DEVICE_ID_VORTEX_GDT6000B 0x0001
#define PCI_DEVICE_ID_VORTEX_GDT6x10 0x0002
#define PCI_DEVICE_ID_VORTEX_GDT6x20 0x0003
#define PCI_DEVICE_ID_VORTEX_GDT6530 0x0004
#define PCI_DEVICE_ID_VORTEX_GDT6550 0x0005
#define PCI_DEVICE_ID_VORTEX_GDT6x17 0x0006
#define PCI_DEVICE_ID_VORTEX_GDT6x27 0x0007
#define PCI_DEVICE_ID_VORTEX_GDT6537 0x0008
#define PCI_DEVICE_ID_VORTEX_GDT6557 0x0009
#define PCI_DEVICE_ID_VORTEX_GDT6x15 0x000a
#define PCI_DEVICE_ID_VORTEX_GDT6x25 0x000b
#define PCI_DEVICE_ID_VORTEX_GDT6535 0x000c
#define PCI_DEVICE_ID_VORTEX_GDT6555 0x000d
#define PCI_DEVICE_ID_VORTEX_GDT6x17RP 0x0100
#define PCI_DEVICE_ID_VORTEX_GDT6x27RP 0x0101
#define PCI_DEVICE_ID_VORTEX_GDT6537RP 0x0102
#define PCI_DEVICE_ID_VORTEX_GDT6557RP 0x0103
#define PCI_DEVICE_ID_VORTEX_GDT6x11RP 0x0104
#define PCI_DEVICE_ID_VORTEX_GDT6x21RP 0x0105
#define PCI_DEVICE_ID_VORTEX_GDT6x17RP1 0x0110
#define PCI_DEVICE_ID_VORTEX_GDT6x27RP1 0x0111
#define PCI_DEVICE_ID_VORTEX_GDT6537RP1 0x0112
#define PCI_DEVICE_ID_VORTEX_GDT6557RP1 0x0113
#define PCI_DEVICE_ID_VORTEX_GDT6x11RP1 0x0114
#define PCI_DEVICE_ID_VORTEX_GDT6x21RP1 0x0115
#define PCI_DEVICE_ID_VORTEX_GDT6x17RP2 0x0120
#define PCI_DEVICE_ID_VORTEX_GDT6x27RP2 0x0121
#define PCI_DEVICE_ID_VORTEX_GDT6537RP2 0x0122
#define PCI_DEVICE_ID_VORTEX_GDT6557RP2 0x0123
#define PCI_DEVICE_ID_VORTEX_GDT6x11RP2 0x0124
#define PCI_DEVICE_ID_VORTEX_GDT6x21RP2 0x0125

#define PCI_VENDOR_ID_EF 0x111a
#define PCI_DEVICE_ID_EF_ATM_FPGA 0x0000
#define PCI_DEVICE_ID_EF_ATM_ASIC 0x0002

#define PCI_VENDOR_ID_IDT 0x111d
#define PCI_DEVICE_ID_IDT_IDT77201 0x0001

#define PCI_VENDOR_ID_FORE 0x1127
#define PCI_DEVICE_ID_FORE_PCA200PC 0x0210
#define PCI_DEVICE_ID_FORE_PCA200E 0x0300

#define PCI_VENDOR_ID_IMAGINGTECH 0x112f
#define PCI_DEVICE_ID_IMAGINGTECH_ICPCI 0x0000

#define PCI_VENDOR_ID_PHILIPS 0x1131
#define PCI_DEVICE_ID_PHILIPS_SAA7145 0x7145
#define PCI_DEVICE_ID_PHILIPS_SAA7146 0x7146
#define PCI_DEVICE_ID_PHILIPS_SAA9730 0x9730

#define PCI_VENDOR_ID_EICON 0x1133
#define PCI_DEVICE_ID_EICON_DIVA20PRO 0xe001
#define PCI_DEVICE_ID_EICON_DIVA20 0xe002
#define PCI_DEVICE_ID_EICON_DIVA20PRO_U 0xe003
#define PCI_DEVICE_ID_EICON_DIVA20_U 0xe004
#define PCI_DEVICE_ID_EICON_DIVA201 0xe005
#define PCI_DEVICE_ID_EICON_DIVA202 0xe00b
#define PCI_DEVICE_ID_EICON_MAESTRA 0xe010
#define PCI_DEVICE_ID_EICON_MAESTRAQ 0xe012
#define PCI_DEVICE_ID_EICON_MAESTRAQ_U 0xe013
#define PCI_DEVICE_ID_EICON_MAESTRAP 0xe014

#define PCI_VENDOR_ID_CYCLONE 0x113c
#define PCI_DEVICE_ID_CYCLONE_SDK 0x0001

#define PCI_VENDOR_ID_ALLIANCE 0x1142
#define PCI_DEVICE_ID_ALLIANCE_PROMOTIO 0x3210
#define PCI_DEVICE_ID_ALLIANCE_PROVIDEO 0x6422
#define PCI_DEVICE_ID_ALLIANCE_AT24 0x6424
#define PCI_DEVICE_ID_ALLIANCE_AT3D 0x643d

#define PCI_VENDOR_ID_SYSKONNECT 0x1148
#define PCI_DEVICE_ID_SYSKONNECT_FP 0x4000
#define PCI_DEVICE_ID_SYSKONNECT_TR 0x4200
#define PCI_DEVICE_ID_SYSKONNECT_GE 0x4300
#define PCI_DEVICE_ID_SYSKONNECT_YU 0x4320
#define PCI_DEVICE_ID_SYSKONNECT_9DXX 0x4400
#define PCI_DEVICE_ID_SYSKONNECT_9MXX 0x4500

#define PCI_VENDOR_ID_VMIC 0x114a
#define PCI_DEVICE_ID_VMIC_VME 0x7587

#define PCI_VENDOR_ID_DIGI 0x114f
#define PCI_DEVICE_ID_DIGI_EPC 0x0002
#define PCI_DEVICE_ID_DIGI_RIGHTSWITCH 0x0003
#define PCI_DEVICE_ID_DIGI_XEM 0x0004
#define PCI_DEVICE_ID_DIGI_XR 0x0005
#define PCI_DEVICE_ID_DIGI_CX 0x0006
#define PCI_DEVICE_ID_DIGI_XRJ 0x0009
#define PCI_DEVICE_ID_DIGI_EPCJ 0x000a
#define PCI_DEVICE_ID_DIGI_XR_920 0x0027
#define PCI_DEVICE_ID_DIGI_DF_M_IOM2_E 0x0070
#define PCI_DEVICE_ID_DIGI_DF_M_E 0x0071
#define PCI_DEVICE_ID_DIGI_DF_M_IOM2_A 0x0072
#define PCI_DEVICE_ID_DIGI_DF_M_A 0x0073

#define PCI_VENDOR_ID_MUTECH 0x1159
#define PCI_DEVICE_ID_MUTECH_MV1000 0x0001

#define PCI_VENDOR_ID_XIRCOM 0x115d
#define PCI_DEVICE_ID_XIRCOM_X3201_ETH 0x0003
#define PCI_DEVICE_ID_XIRCOM_X3201_MDM 0x0103

#define PCI_VENDOR_ID_RENDITION 0x1163
#define PCI_DEVICE_ID_RENDITION_VERITE 0x0001
#define PCI_DEVICE_ID_RENDITION_VERITE2100 0x2000

#define PCI_VENDOR_ID_SERVERWORKS 0x1166
#define PCI_DEVICE_ID_SERVERWORKS_HE 0x0008
#define PCI_DEVICE_ID_SERVERWORKS_LE 0x0009
#define PCI_DEVICE_ID_SERVERWORKS_CIOB30 0x0010
#define PCI_DEVICE_ID_SERVERWORKS_CMIC_HE 0x0011
#define PCI_DEVICE_ID_SERVERWORKS_GCNB_LE 0x0017
#define PCI_DEVICE_ID_SERVERWORKS_OSB4 0x0200
#define PCI_DEVICE_ID_SERVERWORKS_CSB5 0x0201
#define PCI_DEVICE_ID_SERVERWORKS_CSB6 0x0203
#define PCI_DEVICE_ID_SERVERWORKS_OSB4IDE 0x0211
#define PCI_DEVICE_ID_SERVERWORKS_CSB5IDE 0x0212
#define PCI_DEVICE_ID_SERVERWORKS_CSB6IDE 0x0213
#define PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2 0x0217
#define PCI_DEVICE_ID_SERVERWORKS_OSB4USB 0x0220
#define PCI_DEVICE_ID_SERVERWORKS_CSB5USB PCI_DEVICE_ID_SERVERWORKS_OSB4USB
#define PCI_DEVICE_ID_SERVERWORKS_CSB6USB 0x0221
#define PCI_DEVICE_ID_SERVERWORKS_GCLE 0x0225
#define PCI_DEVICE_ID_SERVERWORKS_GCLE2 0x0227
#define PCI_DEVICE_ID_SERVERWORKS_CSB5ISA 0x0230

#define PCI_VENDOR_ID_SBE 0x1176
#define PCI_DEVICE_ID_SBE_WANXL100 0x0301
#define PCI_DEVICE_ID_SBE_WANXL200 0x0302
#define PCI_DEVICE_ID_SBE_WANXL400 0x0104

#define PCI_VENDOR_ID_TOSHIBA 0x1179
#define PCI_DEVICE_ID_TOSHIBA_PICCOLO 0x0102
#define PCI_DEVICE_ID_TOSHIBA_PICCOLO_1 0x0103
#define PCI_DEVICE_ID_TOSHIBA_PICCOLO_2 0x0105
#define PCI_DEVICE_ID_TOSHIBA_601 0x0601
#define PCI_DEVICE_ID_TOSHIBA_TOPIC95 0x060a
#define PCI_DEVICE_ID_TOSHIBA_TOPIC97 0x060f

#define PCI_VENDOR_ID_TOSHIBA_2 0x102f
#define PCI_DEVICE_ID_TOSHIBA_TX3927 0x000a
#define PCI_DEVICE_ID_TOSHIBA_TC35815CF 0x0030
#define PCI_DEVICE_ID_TOSHIBA_TX4927 0x0180

#define PCI_VENDOR_ID_RICOH 0x1180
#define PCI_DEVICE_ID_RICOH_RL5C465 0x0465
#define PCI_DEVICE_ID_RICOH_RL5C466 0x0466
#define PCI_DEVICE_ID_RICOH_RL5C475 0x0475
#define PCI_DEVICE_ID_RICOH_RL5C476 0x0476
#define PCI_DEVICE_ID_RICOH_RL5C478 0x0478

#define PCI_VENDOR_ID_ARTOP 0x1191
#define PCI_DEVICE_ID_ARTOP_ATP8400 0x0004
#define PCI_DEVICE_ID_ARTOP_ATP850UF 0x0005
#define PCI_DEVICE_ID_ARTOP_ATP860 0x0006
#define PCI_DEVICE_ID_ARTOP_ATP860R 0x0007
#define PCI_DEVICE_ID_ARTOP_ATP865 0x0008
#define PCI_DEVICE_ID_ARTOP_ATP865R 0x0009
#define PCI_DEVICE_ID_ARTOP_AEC7610 0x8002
#define PCI_DEVICE_ID_ARTOP_AEC7612UW 0x8010
#define PCI_DEVICE_ID_ARTOP_AEC7612U 0x8020
#define PCI_DEVICE_ID_ARTOP_AEC7612S 0x8030
#define PCI_DEVICE_ID_ARTOP_AEC7612D 0x8040
#define PCI_DEVICE_ID_ARTOP_AEC7612SUW 0x8050
#define PCI_DEVICE_ID_ARTOP_8060 0x8060

#define PCI_VENDOR_ID_ZEITNET 0x1193
#define PCI_DEVICE_ID_ZEITNET_1221 0x0001
#define PCI_DEVICE_ID_ZEITNET_1225 0x0002

#define PCI_VENDOR_ID_OMEGA 0x119b
#define PCI_DEVICE_ID_OMEGA_82C092G 0x1221

#define PCI_VENDOR_ID_FUJITSU_ME 0x119e
#define PCI_DEVICE_ID_FUJITSU_FS155 0x0001
#define PCI_DEVICE_ID_FUJITSU_FS50 0x0003

#define PCI_SUBVENDOR_ID_KEYSPAN 0x11a9
#define PCI_SUBDEVICE_ID_KEYSPAN_SX2 0x5334

#define PCI_VENDOR_ID_GALILEO 0x11ab
#define PCI_DEVICE_ID_GALILEO_GT64011 0x4146
#define PCI_DEVICE_ID_GALILEO_GT64111 0x4146
#define PCI_DEVICE_ID_GALILEO_GT96100 0x9652
#define PCI_DEVICE_ID_GALILEO_GT96100A 0x9653

#define PCI_VENDOR_ID_LITEON 0x11ad
#define PCI_DEVICE_ID_LITEON_LNE100TX 0x0002

#define PCI_VENDOR_ID_V3 0x11b0
#define PCI_DEVICE_ID_V3_V960 0x0001
#define PCI_DEVICE_ID_V3_V350 0x0001
#define PCI_DEVICE_ID_V3_V961 0x0002
#define PCI_DEVICE_ID_V3_V351 0x0002

#define PCI_VENDOR_ID_NP 0x11bc
#define PCI_DEVICE_ID_NP_PCI_FDDI 0x0001

#define PCI_VENDOR_ID_ATT 0x11c1
#define PCI_DEVICE_ID_ATT_L56XMF 0x0440
#define PCI_DEVICE_ID_ATT_VENUS_MODEM 0x480

#define PCI_VENDOR_ID_SPECIALIX 0x11cb
#define PCI_DEVICE_ID_SPECIALIX_IO8 0x2000
#define PCI_DEVICE_ID_SPECIALIX_XIO 0x4000
#define PCI_DEVICE_ID_SPECIALIX_RIO 0x8000
#define PCI_SUBDEVICE_ID_SPECIALIX_SPEED4 0xa004

#define PCI_VENDOR_ID_AURAVISION 0x11d1
#define PCI_DEVICE_ID_AURAVISION_VXP524 0x01f7

#define PCI_VENDOR_ID_ANALOG_DEVICES 0x11d4
#define PCI_DEVICE_ID_AD1889JS 0x1889

#define PCI_VENDOR_ID_IKON 0x11d5
#define PCI_DEVICE_ID_IKON_10115 0x0115
#define PCI_DEVICE_ID_IKON_10117 0x0117

#define PCI_VENDOR_ID_ZORAN 0x11de
#define PCI_DEVICE_ID_ZORAN_36057 0x6057
#define PCI_DEVICE_ID_ZORAN_36120 0x6120

#define PCI_VENDOR_ID_KINETIC 0x11f4
#define PCI_DEVICE_ID_KINETIC_2915 0x2915

#define PCI_VENDOR_ID_COMPEX 0x11f6
#define PCI_DEVICE_ID_COMPEX_ENET100VG4 0x0112
#define PCI_DEVICE_ID_COMPEX_RL2000 0x1401

#define PCI_VENDOR_ID_RP 0x11fe
#define PCI_DEVICE_ID_RP32INTF 0x0001
#define PCI_DEVICE_ID_RP8INTF 0x0002
#define PCI_DEVICE_ID_RP16INTF 0x0003
#define PCI_DEVICE_ID_RP4QUAD 0x0004
#define PCI_DEVICE_ID_RP8OCTA 0x0005
#define PCI_DEVICE_ID_RP8J 0x0006
#define PCI_DEVICE_ID_RPP4 0x000A
#define PCI_DEVICE_ID_RPP8 0x000B
#define PCI_DEVICE_ID_RP8M 0x000C

#define PCI_VENDOR_ID_CYCLADES 0x120e
#define PCI_DEVICE_ID_CYCLOM_Y_Lo 0x0100
#define PCI_DEVICE_ID_CYCLOM_Y_Hi 0x0101
#define PCI_DEVICE_ID_CYCLOM_4Y_Lo 0x0102
#define PCI_DEVICE_ID_CYCLOM_4Y_Hi 0x0103
#define PCI_DEVICE_ID_CYCLOM_8Y_Lo 0x0104
#define PCI_DEVICE_ID_CYCLOM_8Y_Hi 0x0105
#define PCI_DEVICE_ID_CYCLOM_Z_Lo 0x0200
#define PCI_DEVICE_ID_CYCLOM_Z_Hi 0x0201
#define PCI_DEVICE_ID_PC300_RX_2 0x0300
#define PCI_DEVICE_ID_PC300_RX_1 0x0301
#define PCI_DEVICE_ID_PC300_TE_2 0x0310
#define PCI_DEVICE_ID_PC300_TE_1 0x0311

#define PCI_VENDOR_ID_ESSENTIAL 0x120f
#define PCI_DEVICE_ID_ESSENTIAL_ROADRUNNER 0x0001

#define PCI_VENDOR_ID_O2 0x1217
#define PCI_DEVICE_ID_O2_6729 0x6729
#define PCI_DEVICE_ID_O2_6730 0x673a
#define PCI_DEVICE_ID_O2_6832 0x6832
#define PCI_DEVICE_ID_O2_6836 0x6836

#define PCI_VENDOR_ID_3DFX 0x121a
#define PCI_DEVICE_ID_3DFX_VOODOO 0x0001
#define PCI_DEVICE_ID_3DFX_VOODOO2 0x0002
#define PCI_DEVICE_ID_3DFX_BANSHEE 0x0003
#define PCI_DEVICE_ID_3DFX_VOODOO3 0x0005

#define PCI_VENDOR_ID_SIGMADES 0x1236
#define PCI_DEVICE_ID_SIGMADES_6425 0x6401

#define PCI_VENDOR_ID_CCUBE 0x123f

#define PCI_VENDOR_ID_AVM 0x1244
#define PCI_DEVICE_ID_AVM_B1 0x0700
#define PCI_DEVICE_ID_AVM_C4 0x0800
#define PCI_DEVICE_ID_AVM_A1 0x0a00
#define PCI_DEVICE_ID_AVM_A1_V2 0x0e00
#define PCI_DEVICE_ID_AVM_C2 0x1100
#define PCI_DEVICE_ID_AVM_T1 0x1200

#define PCI_VENDOR_ID_DIPIX 0x1246

#define PCI_VENDOR_ID_STALLION 0x124d
#define PCI_DEVICE_ID_STALLION_ECHPCI832 0x0000
#define PCI_DEVICE_ID_STALLION_ECHPCI864 0x0002
#define PCI_DEVICE_ID_STALLION_EIOPCI 0x0003

#define PCI_VENDOR_ID_OPTIBASE 0x1255
#define PCI_DEVICE_ID_OPTIBASE_FORGE 0x1110
#define PCI_DEVICE_ID_OPTIBASE_FUSION 0x1210
#define PCI_DEVICE_ID_OPTIBASE_VPLEX 0x2110
#define PCI_DEVICE_ID_OPTIBASE_VPLEXCC 0x2120
#define PCI_DEVICE_ID_OPTIBASE_VQUEST 0x2130

#define PCI_VENDOR_ID_ESS 0x125d
#define PCI_DEVICE_ID_ESS_ESS1968 0x1968
#define PCI_DEVICE_ID_ESS_AUDIOPCI 0x1969
#define PCI_DEVICE_ID_ESS_ESS1978 0x1978

#define PCI_VENDOR_ID_SATSAGEM 0x1267
#define PCI_DEVICE_ID_SATSAGEM_NICCY 0x1016
#define PCI_DEVICE_ID_SATSAGEM_PCR2101 0x5352
#define PCI_DEVICE_ID_SATSAGEM_TELSATTURBO 0x5a4b

#define PCI_VENDOR_ID_HUGHES 0x1273
#define PCI_DEVICE_ID_HUGHES_DIRECPC 0x0002

#define PCI_VENDOR_ID_ENSONIQ 0x1274
#define PCI_DEVICE_ID_ENSONIQ_CT5880 0x5880
#define PCI_DEVICE_ID_ENSONIQ_ES1370 0x5000
#define PCI_DEVICE_ID_ENSONIQ_ES1371 0x1371

#define PCI_VENDOR_ID_ROCKWELL 0x127A

#define PCI_VENDOR_ID_ITE 0x1283
#define PCI_DEVICE_ID_ITE_IT8172G 0x8172
#define PCI_DEVICE_ID_ITE_IT8172G_AUDIO 0x0801
#define PCI_DEVICE_ID_ITE_IT8181 0x8181
#define PCI_DEVICE_ID_ITE_8872 0x8872

#define PCI_DEVICE_ID_ITE_IT8330G_0 0xe886


#define PCI_VENDOR_ID_ESS_OLD 0x1285
#define PCI_DEVICE_ID_ESS_ESS0100 0x0100

#define PCI_VENDOR_ID_ALTEON 0x12ae
#define PCI_DEVICE_ID_ALTEON_ACENIC 0x0001

#define PCI_VENDOR_ID_USR 0x12B9

#define PCI_SUBVENDOR_ID_CONNECT_TECH 0x12c4
#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_232 0x0001
#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_232 0x0002
#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_232 0x0003
#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485 0x0004
#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_4_4 0x0005
#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485 0x0006
#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH4_485_2_2 0x0007
#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH2_485 0x0008
#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH8_485_2_6 0x0009
#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH081101V1 0x000A
#define PCI_SUBDEVICE_ID_CONNECT_TECH_BH041101V1 0x000B

#define PCI_VENDOR_ID_PICTUREL 0x12c5
#define PCI_DEVICE_ID_PICTUREL_PCIVST 0x0081

#define PCI_VENDOR_ID_NVIDIA_SGS 0x12d2
#define PCI_DEVICE_ID_NVIDIA_SGS_RIVA128 0x0018

#define PCI_SUBVENDOR_ID_CHASE_PCIFAST 0x12E0
#define PCI_SUBDEVICE_ID_CHASE_PCIFAST4 0x0031
#define PCI_SUBDEVICE_ID_CHASE_PCIFAST8 0x0021
#define PCI_SUBDEVICE_ID_CHASE_PCIFAST16 0x0011
#define PCI_SUBDEVICE_ID_CHASE_PCIFAST16FMC 0x0041
#define PCI_SUBVENDOR_ID_CHASE_PCIRAS 0x124D
#define PCI_SUBDEVICE_ID_CHASE_PCIRAS4 0xF001
#define PCI_SUBDEVICE_ID_CHASE_PCIRAS8 0xF010

#define PCI_VENDOR_ID_AUREAL 0x12eb
#define PCI_DEVICE_ID_AUREAL_VORTEX_1 0x0001
#define PCI_DEVICE_ID_AUREAL_VORTEX_2 0x0002

#define PCI_VENDOR_ID_CBOARDS 0x1307
#define PCI_DEVICE_ID_CBOARDS_DAS1602_16 0x0001

#define PCI_VENDOR_ID_SIIG 0x131f
#define PCI_DEVICE_ID_SIIG_1S_10x_550 0x1000
#define PCI_DEVICE_ID_SIIG_1S_10x_650 0x1001
#define PCI_DEVICE_ID_SIIG_1S_10x_850 0x1002
#define PCI_DEVICE_ID_SIIG_1S1P_10x_550 0x1010
#define PCI_DEVICE_ID_SIIG_1S1P_10x_650 0x1011
#define PCI_DEVICE_ID_SIIG_1S1P_10x_850 0x1012
#define PCI_DEVICE_ID_SIIG_1P_10x 0x1020
#define PCI_DEVICE_ID_SIIG_2P_10x 0x1021
#define PCI_DEVICE_ID_SIIG_2S_10x_550 0x1030
#define PCI_DEVICE_ID_SIIG_2S_10x_650 0x1031
#define PCI_DEVICE_ID_SIIG_2S_10x_850 0x1032
#define PCI_DEVICE_ID_SIIG_2S1P_10x_550 0x1034
#define PCI_DEVICE_ID_SIIG_2S1P_10x_650 0x1035
#define PCI_DEVICE_ID_SIIG_2S1P_10x_850 0x1036
#define PCI_DEVICE_ID_SIIG_4S_10x_550 0x1050
#define PCI_DEVICE_ID_SIIG_4S_10x_650 0x1051
#define PCI_DEVICE_ID_SIIG_4S_10x_850 0x1052
#define PCI_DEVICE_ID_SIIG_1S_20x_550 0x2000
#define PCI_DEVICE_ID_SIIG_1S_20x_650 0x2001
#define PCI_DEVICE_ID_SIIG_1S_20x_850 0x2002
#define PCI_DEVICE_ID_SIIG_1P_20x 0x2020
#define PCI_DEVICE_ID_SIIG_2P_20x 0x2021
#define PCI_DEVICE_ID_SIIG_2S_20x_550 0x2030
#define PCI_DEVICE_ID_SIIG_2S_20x_650 0x2031
#define PCI_DEVICE_ID_SIIG_2S_20x_850 0x2032
#define PCI_DEVICE_ID_SIIG_2P1S_20x_550 0x2040
#define PCI_DEVICE_ID_SIIG_2P1S_20x_650 0x2041
#define PCI_DEVICE_ID_SIIG_2P1S_20x_850 0x2042
#define PCI_DEVICE_ID_SIIG_1S1P_20x_550 0x2010
#define PCI_DEVICE_ID_SIIG_1S1P_20x_650 0x2011
#define PCI_DEVICE_ID_SIIG_1S1P_20x_850 0x2012
#define PCI_DEVICE_ID_SIIG_4S_20x_550 0x2050
#define PCI_DEVICE_ID_SIIG_4S_20x_650 0x2051
#define PCI_DEVICE_ID_SIIG_4S_20x_850 0x2052
#define PCI_DEVICE_ID_SIIG_2S1P_20x_550 0x2060
#define PCI_DEVICE_ID_SIIG_2S1P_20x_650 0x2061
#define PCI_DEVICE_ID_SIIG_2S1P_20x_850 0x2062

#define PCI_VENDOR_ID_DOMEX 0x134a
#define PCI_DEVICE_ID_DOMEX_DMX3191D 0x0001

#define PCI_VENDOR_ID_QUATECH 0x135C
#define PCI_DEVICE_ID_QUATECH_QSC100 0x0010
#define PCI_DEVICE_ID_QUATECH_DSC100 0x0020
#define PCI_DEVICE_ID_QUATECH_DSC200 0x0030
#define PCI_DEVICE_ID_QUATECH_QSC200 0x0040
#define PCI_DEVICE_ID_QUATECH_ESC100D 0x0050
#define PCI_DEVICE_ID_QUATECH_ESC100M 0x0060

#define PCI_VENDOR_ID_SEALEVEL 0x135e
#define PCI_DEVICE_ID_SEALEVEL_U530 0x7101
#define PCI_DEVICE_ID_SEALEVEL_UCOMM2 0x7201
#define PCI_DEVICE_ID_SEALEVEL_UCOMM422 0x7402
#define PCI_DEVICE_ID_SEALEVEL_UCOMM232 0x7202
#define PCI_DEVICE_ID_SEALEVEL_COMM4 0x7401
#define PCI_DEVICE_ID_SEALEVEL_COMM8 0x7801

#define PCI_VENDOR_ID_HYPERCOPE 0x1365
#define PCI_DEVICE_ID_HYPERCOPE_PLX 0x9050
#define PCI_SUBDEVICE_ID_HYPERCOPE_OLD_ERGO 0x0104
#define PCI_SUBDEVICE_ID_HYPERCOPE_ERGO 0x0106
#define PCI_SUBDEVICE_ID_HYPERCOPE_METRO 0x0107
#define PCI_SUBDEVICE_ID_HYPERCOPE_CHAMP2 0x0108
#define PCI_SUBDEVICE_ID_HYPERCOPE_PLEXUS 0x0109

#define PCI_VENDOR_ID_KAWASAKI 0x136b
#define PCI_DEVICE_ID_MCHIP_KL5A72002 0xff01

#define PCI_VENDOR_ID_LMC 0x1376
#define PCI_DEVICE_ID_LMC_HSSI 0x0003
#define PCI_DEVICE_ID_LMC_DS3 0x0004
#define PCI_DEVICE_ID_LMC_SSI 0x0005
#define PCI_DEVICE_ID_LMC_T1 0x0006

#define PCI_VENDOR_ID_NETGEAR 0x1385
#define PCI_DEVICE_ID_NETGEAR_GA620 0x620a
#define PCI_DEVICE_ID_NETGEAR_GA622 0x622a

#define PCI_VENDOR_ID_APPLICOM 0x1389
#define PCI_DEVICE_ID_APPLICOM_PCIGENERIC 0x0001
#define PCI_DEVICE_ID_APPLICOM_PCI2000IBS_CAN 0x0002
#define PCI_DEVICE_ID_APPLICOM_PCI2000PFB 0x0003

#define PCI_VENDOR_ID_MOXA 0x1393
#define PCI_DEVICE_ID_MOXA_C104 0x1040
#define PCI_DEVICE_ID_MOXA_C168 0x1680
#define PCI_DEVICE_ID_MOXA_CP204J 0x2040
#define PCI_DEVICE_ID_MOXA_C218 0x2180
#define PCI_DEVICE_ID_MOXA_C320 0x3200

#define PCI_VENDOR_ID_CCD 0x1397
#define PCI_DEVICE_ID_CCD_2BD0 0x2bd0
#define PCI_DEVICE_ID_CCD_B000 0xb000
#define PCI_DEVICE_ID_CCD_B006 0xb006
#define PCI_DEVICE_ID_CCD_B007 0xb007
#define PCI_DEVICE_ID_CCD_B008 0xb008
#define PCI_DEVICE_ID_CCD_B009 0xb009
#define PCI_DEVICE_ID_CCD_B00A 0xb00a
#define PCI_DEVICE_ID_CCD_B00B 0xb00b
#define PCI_DEVICE_ID_CCD_B00C 0xb00c
#define PCI_DEVICE_ID_CCD_B100 0xb100

#define PCI_VENDOR_ID_3WARE 0x13C1
#define PCI_DEVICE_ID_3WARE_1000 0x1000

#define PCI_VENDOR_ID_ABOCOM 0x13D1
#define PCI_DEVICE_ID_ABOCOM_2BD1 0x2BD1

#define PCI_VENDOR_ID_CMEDIA 0x13f6
#define PCI_DEVICE_ID_CMEDIA_CM8338A 0x0100
#define PCI_DEVICE_ID_CMEDIA_CM8338B 0x0101
#define PCI_DEVICE_ID_CMEDIA_CM8738 0x0111
#define PCI_DEVICE_ID_CMEDIA_CM8738B 0x0112

#define PCI_VENDOR_ID_LAVA 0x1407
#define PCI_DEVICE_ID_LAVA_DSERIAL 0x0100
#define PCI_DEVICE_ID_LAVA_QUATRO_A 0x0101
#define PCI_DEVICE_ID_LAVA_QUATRO_B 0x0102
#define PCI_DEVICE_ID_LAVA_OCTO_A 0x0180
#define PCI_DEVICE_ID_LAVA_OCTO_B 0x0181
#define PCI_DEVICE_ID_LAVA_PORT_PLUS 0x0200
#define PCI_DEVICE_ID_LAVA_QUAD_A 0x0201
#define PCI_DEVICE_ID_LAVA_QUAD_B 0x0202
#define PCI_DEVICE_ID_LAVA_SSERIAL 0x0500
#define PCI_DEVICE_ID_LAVA_PORT_650 0x0600
#define PCI_DEVICE_ID_LAVA_PARALLEL 0x8000
#define PCI_DEVICE_ID_LAVA_DUAL_PAR_A 0x8002
#define PCI_DEVICE_ID_LAVA_DUAL_PAR_B 0x8003
#define PCI_DEVICE_ID_LAVA_BOCA_IOPPAR 0x8800

#define PCI_VENDOR_ID_TIMEDIA 0x1409
#define PCI_DEVICE_ID_TIMEDIA_1889 0x7168

#define PCI_VENDOR_ID_OXSEMI 0x1415
#define PCI_DEVICE_ID_OXSEMI_12PCI840 0x8403
#define PCI_DEVICE_ID_OXSEMI_16PCI954 0x9501
#define PCI_DEVICE_ID_OXSEMI_16PCI95N 0x9511
#define PCI_DEVICE_ID_OXSEMI_16PCI954PP 0x9513
#define PCI_DEVICE_ID_OXSEMI_16PCI952 0x9521

#define PCI_VENDOR_ID_AIRONET 0x14b9
#define PCI_DEVICE_ID_AIRONET_4800_1 0x0001
#define PCI_DEVICE_ID_AIRONET_4800 0x4500
#define PCI_DEVICE_ID_AIRONET_4500 0x4800

#define PCI_VENDOR_ID_TITAN 0x14D2
#define PCI_DEVICE_ID_TITAN_010L 0x8001
#define PCI_DEVICE_ID_TITAN_100L 0x8010
#define PCI_DEVICE_ID_TITAN_110L 0x8011
#define PCI_DEVICE_ID_TITAN_200L 0x8020
#define PCI_DEVICE_ID_TITAN_210L 0x8021
#define PCI_DEVICE_ID_TITAN_400L 0x8040
#define PCI_DEVICE_ID_TITAN_800L 0x8080
#define PCI_DEVICE_ID_TITAN_100 0xA001
#define PCI_DEVICE_ID_TITAN_200 0xA005
#define PCI_DEVICE_ID_TITAN_400 0xA003
#define PCI_DEVICE_ID_TITAN_800B 0xA004

#define PCI_VENDOR_ID_PANACOM 0x14d4
#define PCI_DEVICE_ID_PANACOM_QUADMODEM 0x0400
#define PCI_DEVICE_ID_PANACOM_DUALMODEM 0x0402

#define PCI_VENDOR_ID_AFAVLAB 0x14db
#define PCI_DEVICE_ID_AFAVLAB_P028 0x2180

#define PCI_VENDOR_ID_BROADCOM 0x14e4
#define PCI_DEVICE_ID_TIGON3_5752 0x1600
#define PCI_DEVICE_ID_TIGON3_5752M 0x1601
#define PCI_DEVICE_ID_TIGON3_5700 0x1644
#define PCI_DEVICE_ID_TIGON3_5701 0x1645
#define PCI_DEVICE_ID_TIGON3_5702 0x1646
#define PCI_DEVICE_ID_TIGON3_5703 0x1647
#define PCI_DEVICE_ID_TIGON3_5704 0x1648
#define PCI_DEVICE_ID_TIGON3_5704S_2 0x1649
#define PCI_DEVICE_ID_TIGON3_5702FE 0x164d
#define PCI_DEVICE_ID_TIGON3_5705 0x1653
#define PCI_DEVICE_ID_TIGON3_5705_2 0x1654
#define PCI_DEVICE_ID_TIGON3_5720 0x1658
#define PCI_DEVICE_ID_TIGON3_5721 0x1659
#define PCI_DEVICE_ID_TIGON3_5705M 0x165d
#define PCI_DEVICE_ID_TIGON3_5705M_2 0x165e
#define PCI_DEVICE_ID_TIGON3_5705F 0x166e
#define PCI_DEVICE_ID_TIGON3_5750 0x1676
#define PCI_DEVICE_ID_TIGON3_5751 0x1677
#define PCI_DEVICE_ID_TIGON3_5750M 0x167c
#define PCI_DEVICE_ID_TIGON3_5751M 0x167d
#define PCI_DEVICE_ID_TIGON3_5751F 0x167e
#define PCI_DEVICE_ID_TIGON3_5782 0x1696
#define PCI_DEVICE_ID_TIGON3_5788 0x169c
#define PCI_DEVICE_ID_TIGON3_5789 0x169d
#define PCI_DEVICE_ID_TIGON3_5702X 0x16a6
#define PCI_DEVICE_ID_TIGON3_5703X 0x16a7
#define PCI_DEVICE_ID_TIGON3_5704S 0x16a8
#define PCI_DEVICE_ID_TIGON3_5702A3 0x16c6
#define PCI_DEVICE_ID_TIGON3_5703A3 0x16c7
#define PCI_DEVICE_ID_TIGON3_5781 0x16dd
#define PCI_DEVICE_ID_TIGON3_5753 0x16f7
#define PCI_DEVICE_ID_TIGON3_5753M 0x16fd
#define PCI_DEVICE_ID_TIGON3_5753F 0x16fe
#define PCI_DEVICE_ID_TIGON3_5901 0x170d
#define PCI_DEVICE_ID_BCM4401B1 0x170c
#define PCI_DEVICE_ID_TIGON3_5901_2 0x170e
#define PCI_DEVICE_ID_BCM4401 0x4401
#define PCI_DEVICE_ID_BCM4401B0 0x4402

#define PCI_VENDOR_ID_ENE 0x1524
#define PCI_DEVICE_ID_ENE_1211 0x1211
#define PCI_DEVICE_ID_ENE_1225 0x1225
#define PCI_DEVICE_ID_ENE_1410 0x1410
#define PCI_DEVICE_ID_ENE_1420 0x1420

#define PCI_VENDOR_ID_SYBA 0x1592
#define PCI_DEVICE_ID_SYBA_2P_EPP 0x0782
#define PCI_DEVICE_ID_SYBA_1P_ECP 0x0783

#define PCI_VENDOR_ID_MORETON 0x15aa
#define PCI_DEVICE_ID_RASTEL_2PORT 0x2000

#define PCI_VENDOR_ID_ZOLTRIX 0x15b0
#define PCI_DEVICE_ID_ZOLTRIX_2BD0 0x2bd0

#define PCI_VENDOR_ID_PDC 0x15e9
#define PCI_DEVICE_ID_PDC_ADMA100 0x1841

#define PCI_VENDOR_ID_FARSITE 0x1619
#define PCI_DEVICE_ID_FARSITE_T2P 0x0400
#define PCI_DEVICE_ID_FARSITE_T4P 0x0440
#define PCI_DEVICE_ID_FARSITE_T1U 0x0610
#define PCI_DEVICE_ID_FARSITE_T2U 0x0620
#define PCI_DEVICE_ID_FARSITE_T4U 0x0640
#define PCI_DEVICE_ID_FARSITE_TE1 0x1610
#define PCI_DEVICE_ID_FARSITE_TE1C 0x1612

#define PCI_VENDOR_ID_ALTIMA 0x173b
#define PCI_DEVICE_ID_ALTIMA_AC1000 0x03e8
#define PCI_DEVICE_ID_ALTIMA_AC1001 0x03e9
#define PCI_DEVICE_ID_ALTIMA_AC9100 0x03ea
#define PCI_DEVICE_ID_ALTIMA_AC1003 0x03eb

#define PCI_VENDOR_ID_SYMPHONY 0x1c1c
#define PCI_DEVICE_ID_SYMPHONY_101 0x0001

#define PCI_VENDOR_ID_TEKRAM 0x1de1
#define PCI_DEVICE_ID_TEKRAM_DC290 0xdc29

#define PCI_VENDOR_ID_HINT 0x3388
#define PCI_DEVICE_ID_HINT_VXPROII_IDE 0x8013

#define PCI_VENDOR_ID_3DLABS 0x3d3d
#define PCI_DEVICE_ID_3DLABS_300SX 0x0001
#define PCI_DEVICE_ID_3DLABS_500TX 0x0002
#define PCI_DEVICE_ID_3DLABS_DELTA 0x0003
#define PCI_DEVICE_ID_3DLABS_PERMEDIA 0x0004
#define PCI_DEVICE_ID_3DLABS_MX 0x0006
#define PCI_DEVICE_ID_3DLABS_PERMEDIA2 0x0007
#define PCI_DEVICE_ID_3DLABS_GAMMA 0x0008
#define PCI_DEVICE_ID_3DLABS_PERMEDIA2V 0x0009

#define PCI_VENDOR_ID_AVANCE 0x4005
#define PCI_DEVICE_ID_AVANCE_ALG2064 0x2064
#define PCI_DEVICE_ID_AVANCE_2302 0x2302

#define PCI_VENDOR_ID_AKS 0x416c
#define PCI_DEVICE_ID_AKS_ALADDINCARD 0x0100
#define PCI_DEVICE_ID_AKS_CPC 0x0200

#define PCI_VENDOR_ID_REDCREEK 0x4916
#define PCI_DEVICE_ID_RC45 0x1960

#define PCI_VENDOR_ID_NETVIN 0x4a14
#define PCI_DEVICE_ID_NETVIN_NV5000SC 0x5000

#define PCI_VENDOR_ID_S3 0x5333
#define PCI_DEVICE_ID_S3_PLATO_PXS 0x0551
#define PCI_DEVICE_ID_S3_ViRGE 0x5631
#define PCI_DEVICE_ID_S3_TRIO 0x8811
#define PCI_DEVICE_ID_S3_AURORA64VP 0x8812
#define PCI_DEVICE_ID_S3_TRIO64UVP 0x8814
#define PCI_DEVICE_ID_S3_ViRGE_VX 0x883d
#define PCI_DEVICE_ID_S3_868 0x8880
#define PCI_DEVICE_ID_S3_928 0x88b0
#define PCI_DEVICE_ID_S3_864_1 0x88c0
#define PCI_DEVICE_ID_S3_864_2 0x88c1
#define PCI_DEVICE_ID_S3_964_1 0x88d0
#define PCI_DEVICE_ID_S3_964_2 0x88d1
#define PCI_DEVICE_ID_S3_968 0x88f0
#define PCI_DEVICE_ID_S3_TRIO64V2 0x8901
#define PCI_DEVICE_ID_S3_PLATO_PXG 0x8902
#define PCI_DEVICE_ID_S3_ViRGE_DXGX 0x8a01
#define PCI_DEVICE_ID_S3_ViRGE_GX2 0x8a10
#define PCI_DEVICE_ID_S3_ViRGE_MX 0x8c01
#define PCI_DEVICE_ID_S3_ViRGE_MXP 0x8c02
#define PCI_DEVICE_ID_S3_ViRGE_MXPMV 0x8c03
#define PCI_DEVICE_ID_S3_SONICVIBES 0xca00

#define PCI_VENDOR_ID_DUNORD 0x5544
#define PCI_DEVICE_ID_DUNORD_I3000 0x0001
#define PCI_VENDOR_ID_GENROCO 0x5555
#define PCI_DEVICE_ID_GENROCO_HFP832 0x0003

#define PCI_VENDOR_ID_DCI 0x6666
#define PCI_DEVICE_ID_DCI_PCCOM4 0x0001
#define PCI_DEVICE_ID_DCI_PCCOM8 0x0002

#define PCI_VENDOR_ID_INTEL 0x8086
#define PCI_DEVICE_ID_INTEL_21145 0x0039
#define PCI_DEVICE_ID_INTEL_82375 0x0482
#define PCI_DEVICE_ID_INTEL_82424 0x0483
#define PCI_DEVICE_ID_INTEL_82378 0x0484
#define PCI_DEVICE_ID_INTEL_82430 0x0486
#define PCI_DEVICE_ID_INTEL_82434 0x04a3
#define PCI_DEVICE_ID_INTEL_I960 0x0960
#define PCI_DEVICE_ID_INTEL_I960RM 0x0962
#define PCI_DEVICE_ID_INTEL_82562ET 0x1031

#define PCI_DEVICE_ID_INTEL_82815_MC 0x1130

#define PCI_DEVICE_ID_INTEL_82559ER 0x1209
#define PCI_DEVICE_ID_INTEL_82092AA_0 0x1221
#define PCI_DEVICE_ID_INTEL_82092AA_1 0x1222
#define PCI_DEVICE_ID_INTEL_7116 0x1223
#define PCI_DEVICE_ID_INTEL_7205_0 0x255d
#define PCI_DEVICE_ID_INTEL_82596 0x1226
#define PCI_DEVICE_ID_INTEL_82865 0x1227
#define PCI_DEVICE_ID_INTEL_82557 0x1229
#define PCI_DEVICE_ID_INTEL_82437 0x122d
#define PCI_DEVICE_ID_INTEL_82371FB_0 0x122e
#define PCI_DEVICE_ID_INTEL_82371FB_1 0x1230
#define PCI_DEVICE_ID_INTEL_82371MX 0x1234
#define PCI_DEVICE_ID_INTEL_82437MX 0x1235
#define PCI_DEVICE_ID_INTEL_82441 0x1237
#define PCI_DEVICE_ID_INTEL_82380FB 0x124b
#define PCI_DEVICE_ID_INTEL_82439 0x1250
#define PCI_DEVICE_ID_INTEL_80960_RP 0x1960
#define PCI_DEVICE_ID_INTEL_82845_HB 0x1a30
#define PCI_DEVICE_ID_INTEL_82371SB_0 0x7000
#define PCI_DEVICE_ID_INTEL_82371SB_1 0x7010
#define PCI_DEVICE_ID_INTEL_82371SB_2 0x7020
#define PCI_DEVICE_ID_INTEL_82437VX 0x7030
#define PCI_DEVICE_ID_INTEL_82439TX 0x7100
#define PCI_DEVICE_ID_INTEL_82371AB_0 0x7110
#define PCI_DEVICE_ID_INTEL_82371AB 0x7111
#define PCI_DEVICE_ID_INTEL_82371AB_2 0x7112
#define PCI_DEVICE_ID_INTEL_82371AB_3 0x7113
#define PCI_DEVICE_ID_INTEL_82801AA_0 0x2410
#define PCI_DEVICE_ID_INTEL_82801AA_1 0x2411
#define PCI_DEVICE_ID_INTEL_82801AA_2 0x2412
#define PCI_DEVICE_ID_INTEL_82801AA_3 0x2413
#define PCI_DEVICE_ID_INTEL_82801AA_5 0x2415
#define PCI_DEVICE_ID_INTEL_82801AA_6 0x2416
#define PCI_DEVICE_ID_INTEL_82801AA_8 0x2418
#define PCI_DEVICE_ID_INTEL_82801AB_0 0x2420
#define PCI_DEVICE_ID_INTEL_82801AB_1 0x2421
#define PCI_DEVICE_ID_INTEL_82801AB_2 0x2422
#define PCI_DEVICE_ID_INTEL_82801AB_3 0x2423
#define PCI_DEVICE_ID_INTEL_82801AB_5 0x2425
#define PCI_DEVICE_ID_INTEL_82801AB_6 0x2426
#define PCI_DEVICE_ID_INTEL_82801AB_8 0x2428
#define PCI_DEVICE_ID_INTEL_82801BA_0 0x2440
#define PCI_DEVICE_ID_INTEL_82801BA_1 0x2442
#define PCI_DEVICE_ID_INTEL_82801BA_2 0x2443
#define PCI_DEVICE_ID_INTEL_82801BA_3 0x2444
#define PCI_DEVICE_ID_INTEL_82801BA_4 0x2445
#define PCI_DEVICE_ID_INTEL_82801BA_5 0x2446
#define PCI_DEVICE_ID_INTEL_82801BA_6 0x2448
#define PCI_DEVICE_ID_INTEL_82801BA_7 0x2449
#define PCI_DEVICE_ID_INTEL_82801BA_8 0x244a
#define PCI_DEVICE_ID_INTEL_82801BA_9 0x244b
#define PCI_DEVICE_ID_INTEL_82801BA_10 0x244c
#define PCI_DEVICE_ID_INTEL_82801BA_11 0x244e
#define PCI_DEVICE_ID_INTEL_82801E_0 0x2450
#define PCI_DEVICE_ID_INTEL_82801E_2 0x2452
#define PCI_DEVICE_ID_INTEL_82801E_3 0x2453
#define PCI_DEVICE_ID_INTEL_82801E_9 0x2459
#define PCI_DEVICE_ID_INTEL_82801E_11 0x245B
#define PCI_DEVICE_ID_INTEL_82801E_14 0x245D
#define PCI_DEVICE_ID_INTEL_82801E_15 0x245E
#define PCI_DEVICE_ID_INTEL_82801CA_0 0x2480
#define PCI_DEVICE_ID_INTEL_82801CA_2 0x2482
#define PCI_DEVICE_ID_INTEL_82801CA_3 0x2483
#define PCI_DEVICE_ID_INTEL_82801CA_4 0x2484
#define PCI_DEVICE_ID_INTEL_82801CA_5 0x2485
#define PCI_DEVICE_ID_INTEL_82801CA_6 0x2486
#define PCI_DEVICE_ID_INTEL_82801CA_7 0x2487
#define PCI_DEVICE_ID_INTEL_82801CA_10 0x248a
#define PCI_DEVICE_ID_INTEL_82801CA_11 0x248b
#define PCI_DEVICE_ID_INTEL_82801CA_12 0x248c
#define PCI_DEVICE_ID_INTEL_82801DB_0 0x24c0
#define PCI_DEVICE_ID_INTEL_82801DB_2 0x24c2
#define PCI_DEVICE_ID_INTEL_82801DB_3 0x24c3
#define PCI_DEVICE_ID_INTEL_82801DB_4 0x24c4
#define PCI_DEVICE_ID_INTEL_82801DB_5 0x24c5
#define PCI_DEVICE_ID_INTEL_82801DB_6 0x24c6
#define PCI_DEVICE_ID_INTEL_82801DB_7 0x24c7
#define PCI_DEVICE_ID_INTEL_82801DB_10 0x24ca
#define PCI_DEVICE_ID_INTEL_82801DB_11 0x24cb
#define PCI_DEVICE_ID_INTEL_82801DB_12 0x24cc
#define PCI_DEVICE_ID_INTEL_82801DB_13 0x24cd
#define PCI_DEVICE_ID_INTEL_82801EB_0 0x24d0
#define PCI_DEVICE_ID_INTEL_82801EB_1 0x24d1
#define PCI_DEVICE_ID_INTEL_82801EB_2 0x24d2
#define PCI_DEVICE_ID_INTEL_82801EB_3 0x24d3
#define PCI_DEVICE_ID_INTEL_82801EB_4 0x24d4
#define PCI_DEVICE_ID_INTEL_82801EB_5 0x24d5
#define PCI_DEVICE_ID_INTEL_82801EB_6 0x24d6
#define PCI_DEVICE_ID_INTEL_82801EB_7 0x24d7
#define PCI_DEVICE_ID_INTEL_82801EB_11 0x24db
#define PCI_DEVICE_ID_INTEL_82801EB_13 0x24dd
#define PCI_DEVICE_ID_INTEL_ESB_0 0x25a0
#define PCI_DEVICE_ID_INTEL_ESB_1 0x25a1
#define PCI_DEVICE_ID_INTEL_ESB_2 0x25a2
#define PCI_DEVICE_ID_INTEL_ESB_3 0x25a3
#define PCI_DEVICE_ID_INTEL_ESB_31 0x25b0
#define PCI_DEVICE_ID_INTEL_ESB_4 0x25a4
#define PCI_DEVICE_ID_INTEL_ESB_5 0x25a6
#define PCI_DEVICE_ID_INTEL_ESB_6 0x25a7
#define PCI_DEVICE_ID_INTEL_ESB_7 0x25a9
#define PCI_DEVICE_ID_INTEL_ESB_8 0x25aa
#define PCI_DEVICE_ID_INTEL_ESB_9 0x25ab
#define PCI_DEVICE_ID_INTEL_ESB_11 0x25ac
#define PCI_DEVICE_ID_INTEL_ESB_12 0x25ad
#define PCI_DEVICE_ID_INTEL_ESB_13 0x25ae
#define PCI_DEVICE_ID_INTEL_ICH6_0 0x2640
#define PCI_DEVICE_ID_INTEL_ICH6_1 0x2641
#define PCI_DEVICE_ID_INTEL_ICH6_2 0x266f
#define PCI_DEVICE_ID_INTEL_ICH6_18 0x266e
#define PCI_DEVICE_ID_INTEL_ICH7_21 0x27df
#define PCI_DEVICE_ID_INTEL_82850_HB 0x2530
#define PCI_DEVICE_ID_INTEL_82845G_HB 0x2560
#define PCI_DEVICE_ID_INTEL_SMCH 0x3590
#define PCI_DEVICE_ID_INTEL_80310 0x530d
#define PCI_DEVICE_ID_INTEL_82810_MC1 0x7120
#define PCI_DEVICE_ID_INTEL_82810_IG1 0x7121
#define PCI_DEVICE_ID_INTEL_82810_MC3 0x7122
#define PCI_DEVICE_ID_INTEL_82810_IG3 0x7123
#define PCI_DEVICE_ID_INTEL_82443LX_0 0x7180
#define PCI_DEVICE_ID_INTEL_82443LX_1 0x7181
#define PCI_DEVICE_ID_INTEL_82443BX_0 0x7190
#define PCI_DEVICE_ID_INTEL_82443BX_1 0x7191
#define PCI_DEVICE_ID_INTEL_82443BX_2 0x7192
#define PCI_DEVICE_ID_INTEL_440MX 0x7195
#define PCI_DEVICE_ID_INTEL_82443MX_0 0x7198
#define PCI_DEVICE_ID_INTEL_82443MX_1 0x7199
#define PCI_DEVICE_ID_INTEL_82443MX_2 0x719a
#define PCI_DEVICE_ID_INTEL_82443MX_3 0x719b
#define PCI_DEVICE_ID_INTEL_82443GX_0 0x71a0
#define PCI_DEVICE_ID_INTEL_82443GX_1 0x71a1
#define PCI_DEVICE_ID_INTEL_82443GX_2 0x71a2
#define PCI_DEVICE_ID_INTEL_82372FB_0 0x7600
#define PCI_DEVICE_ID_INTEL_82372FB_1 0x7601
#define PCI_DEVICE_ID_INTEL_82372FB_2 0x7602
#define PCI_DEVICE_ID_INTEL_82372FB_3 0x7603
#define PCI_DEVICE_ID_INTEL_82454GX 0x84c4
#define PCI_DEVICE_ID_INTEL_82450GX 0x84c5
#define PCI_DEVICE_ID_INTEL_82451NX 0x84ca
#define PCI_DEVICE_ID_INTEL_82454NX 0x84cb

#define PCI_VENDOR_ID_COMPUTONE 0x8e0e
#define PCI_DEVICE_ID_COMPUTONE_IP2EX 0x0291
#define PCI_DEVICE_ID_COMPUTONE_PG 0x0302
#define PCI_SUBVENDOR_ID_COMPUTONE 0x8e0e
#define PCI_SUBDEVICE_ID_COMPUTONE_PG4 0x0001
#define PCI_SUBDEVICE_ID_COMPUTONE_PG8 0x0002
#define PCI_SUBDEVICE_ID_COMPUTONE_PG6 0x0003

#define PCI_VENDOR_ID_KTI 0x8e2e
#define PCI_DEVICE_ID_KTI_ET32P2 0x3000

#define PCI_VENDOR_ID_ADAPTEC 0x9004
#define PCI_DEVICE_ID_ADAPTEC_7810 0x1078
#define PCI_DEVICE_ID_ADAPTEC_7821 0x2178
#define PCI_DEVICE_ID_ADAPTEC_38602 0x3860
#define PCI_DEVICE_ID_ADAPTEC_7850 0x5078
#define PCI_DEVICE_ID_ADAPTEC_7855 0x5578
#define PCI_DEVICE_ID_ADAPTEC_5800 0x5800
#define PCI_DEVICE_ID_ADAPTEC_3860 0x6038
#define PCI_DEVICE_ID_ADAPTEC_1480A 0x6075
#define PCI_DEVICE_ID_ADAPTEC_7860 0x6078
#define PCI_DEVICE_ID_ADAPTEC_7861 0x6178
#define PCI_DEVICE_ID_ADAPTEC_7870 0x7078
#define PCI_DEVICE_ID_ADAPTEC_7871 0x7178
#define PCI_DEVICE_ID_ADAPTEC_7872 0x7278
#define PCI_DEVICE_ID_ADAPTEC_7873 0x7378
#define PCI_DEVICE_ID_ADAPTEC_7874 0x7478
#define PCI_DEVICE_ID_ADAPTEC_7895 0x7895
#define PCI_DEVICE_ID_ADAPTEC_7880 0x8078
#define PCI_DEVICE_ID_ADAPTEC_7881 0x8178
#define PCI_DEVICE_ID_ADAPTEC_7882 0x8278
#define PCI_DEVICE_ID_ADAPTEC_7883 0x8378
#define PCI_DEVICE_ID_ADAPTEC_7884 0x8478
#define PCI_DEVICE_ID_ADAPTEC_7885 0x8578
#define PCI_DEVICE_ID_ADAPTEC_7886 0x8678
#define PCI_DEVICE_ID_ADAPTEC_7887 0x8778
#define PCI_DEVICE_ID_ADAPTEC_7888 0x8878
#define PCI_DEVICE_ID_ADAPTEC_1030 0x8b78

#define PCI_VENDOR_ID_ADAPTEC2 0x9005
#define PCI_DEVICE_ID_ADAPTEC2_2940U2 0x0010
#define PCI_DEVICE_ID_ADAPTEC2_2930U2 0x0011
#define PCI_DEVICE_ID_ADAPTEC2_7890B 0x0013
#define PCI_DEVICE_ID_ADAPTEC2_7890 0x001f
#define PCI_DEVICE_ID_ADAPTEC2_3940U2 0x0050
#define PCI_DEVICE_ID_ADAPTEC2_3950U2D 0x0051
#define PCI_DEVICE_ID_ADAPTEC2_7896 0x005f
#define PCI_DEVICE_ID_ADAPTEC2_7892A 0x0080
#define PCI_DEVICE_ID_ADAPTEC2_7892B 0x0081
#define PCI_DEVICE_ID_ADAPTEC2_7892D 0x0083
#define PCI_DEVICE_ID_ADAPTEC2_7892P 0x008f
#define PCI_DEVICE_ID_ADAPTEC2_7899A 0x00c0
#define PCI_DEVICE_ID_ADAPTEC2_7899B 0x00c1
#define PCI_DEVICE_ID_ADAPTEC2_7899D 0x00c3
#define PCI_DEVICE_ID_ADAPTEC2_7899P 0x00cf

#define PCI_VENDOR_ID_ATRONICS 0x907f
#define PCI_DEVICE_ID_ATRONICS_2015 0x2015

#define PCI_VENDOR_ID_HOLTEK 0x9412
#define PCI_DEVICE_ID_HOLTEK_6565 0x6565

#define PCI_VENDOR_ID_NETMOS 0x9710
#define PCI_DEVICE_ID_NETMOS_9705 0x9705
#define PCI_DEVICE_ID_NETMOS_9735 0x9735
#define PCI_DEVICE_ID_NETMOS_9805 0x9805
#define PCI_DEVICE_ID_NETMOS_9815 0x9815
#define PCI_DEVICE_ID_NETMOS_9835 0x9835
#define PCI_DEVICE_ID_NETMOS_9855 0x9855

#define PCI_SUBVENDOR_ID_EXSYS 0xd84d
#define PCI_SUBDEVICE_ID_EXSYS_4014 0x4014

#define PCI_VENDOR_ID_TIGERJET 0xe159
#define PCI_DEVICE_ID_TIGERJET_300 0x0001
#define PCI_DEVICE_ID_TIGERJET_100 0x0002

#define PCI_VENDOR_ID_TTTECH 0x0357
#define PCI_DEVICE_ID_TTTECH_MC322 0x000A

#define PCI_VENDOR_ID_ARK 0xedd8
#define PCI_DEVICE_ID_ARK_STING 0xa091
#define PCI_DEVICE_ID_ARK_STINGARK 0xa099
#define PCI_DEVICE_ID_ARK_2000MT 0xa0a1

#define PCI_VENDOR_ID_MICROGATE 0x13c0
#define PCI_DEVICE_ID_MICROGATE_USC 0x0010
#define PCI_DEVICE_ID_MICROGATE_SCC 0x0020
#define PCI_DEVICE_ID_MICROGATE_SCA 0x0030

#define PCI_VENDOR_ID_WORKBIT 0x1145
#define PCI_DEVICE_ID_WORKBIT_CB 0xf021

#define PCI_VENDOR_ID_JMICRON 0x197b
#define PCI_DEVICE_ID_JMICRON_20363 0x2363
#define PCI_DEVICE_ID_JMICRON_JMB368 0x2368

#define PCI_VENDOR_ID_MARVELL 0x11ab
#define PCI_DEVICE_ID_MARVELL_6101 0x6101
#define PCI_DEVICE_ID_MARVELL_6145 0x6145
# 312 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h" 2
# 321 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h"
#define PCI_DEVFN(slot,func) ((((slot) & 0x1f) << 3) | ((func) & 0x07))
#define PCI_SLOT(devfn) (((devfn) >> 3) & 0x1f)
#define PCI_FUNC(devfn) ((devfn) & 0x07)


#define PCIIOC_BASE ('P' << 24 | 'C' << 16 | 'I' << 8)
#define PCIIOC_CONTROLLER (PCIIOC_BASE | 0x00)
#define PCIIOC_MMAP_IS_IO (PCIIOC_BASE | 0x01)
#define PCIIOC_MMAP_IS_MEM (PCIIOC_BASE | 0x02)
#define PCIIOC_WRITE_COMBINE (PCIIOC_BASE | 0x03)
# 341 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h"
enum pci_mmap_state {
        pci_mmap_io,
        pci_mmap_mem
};


#define PCI_DMA_BIDIRECTIONAL 0
#define PCI_DMA_TODEVICE 1
#define PCI_DMA_FROMDEVICE 2
#define PCI_DMA_NONE 3

#define DEVICE_COUNT_COMPATIBLE 4
#define DEVICE_COUNT_IRQ 2
#define DEVICE_COUNT_DMA 2
#define DEVICE_COUNT_RESOURCE 12

#define PCI_ANY_ID (~0)

#define pci_present pcibios_present


#define pci_for_each_dev_reverse(dev) for(dev = pci_dev_g(pci_devices.prev); dev != pci_dev_g(&pci_devices); dev = pci_dev_g(dev->global_list.prev))


#define pci_for_each_bus(bus) for(bus = pci_bus_b(pci_root_buses.next); bus != pci_bus_b(&pci_root_buses); bus = pci_bus_b(bus->node.next))





struct pci_dev {
        struct list_head global_list;
        struct list_head bus_list;
        struct pci_bus *bus;
        struct pci_bus *subordinate;

        void *sysdata;
        struct proc_dir_entry *procent;

        unsigned int devfn;
        unsigned short vendor;
        unsigned short device;
        unsigned short subsystem_vendor;
        unsigned short subsystem_device;
        unsigned int class;
        u8 hdr_type;
        u8 rom_base_reg;

        struct pci_driver *driver;
        void *driver_data;
        u64 dma_mask;





        u32 current_state;




        unsigned short vendor_compatible[4];
        unsigned short device_compatible[4];





        unsigned int irq;
        struct resource resource[12];
        struct resource dma_resource[2];
        struct resource irq_resource[2];

        char name[90];
        char slot_name[8];
        int active;
        int ro;
        unsigned short regs;


        unsigned short transparent:1;

        int (*prepare)(struct pci_dev *dev);
        int (*activate)(struct pci_dev *dev);
        int (*deactivate)(struct pci_dev *dev);
};

#define pci_dev_g(n) list_entry(n, struct pci_dev, global_list)
#define pci_dev_b(n) list_entry(n, struct pci_dev, bus_list)
# 439 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h"
#define PCI_ROM_RESOURCE 6
#define PCI_BRIDGE_RESOURCES 7
#define PCI_NUM_RESOURCES 11

#define PCI_REGION_FLAG_MASK 0x0fU

struct pci_bus {
        struct list_head node;
        struct pci_bus *parent;
        struct list_head children;
        struct list_head devices;
        struct pci_dev *self;
        struct resource *resource[4];

        struct pci_ops *ops;
        void *sysdata;
        struct proc_dir_entry *procdir;

        unsigned char number;
        unsigned char primary;
        unsigned char secondary;
        unsigned char subordinate;

        char name[48];
        unsigned short vendor;
        unsigned short device;
        unsigned int serial;
        unsigned char pnpver;
        unsigned char productver;
        unsigned char checksum;
        unsigned char pad1;
};

#define pci_bus_b(n) list_entry(n, struct pci_bus, node)

extern struct list_head pci_root_buses;
extern struct list_head pci_devices;

extern struct proc_dir_entry *proc_bus_pci_dir;



#define PCIBIOS_SUCCESSFUL 0x00
#define PCIBIOS_FUNC_NOT_SUPPORTED 0x81
#define PCIBIOS_BAD_VENDOR_ID 0x83
#define PCIBIOS_DEVICE_NOT_FOUND 0x86
#define PCIBIOS_BAD_REGISTER_NUMBER 0x87
#define PCIBIOS_SET_FAILED 0x88
#define PCIBIOS_BUFFER_TOO_SMALL 0x89



struct pci_ops {
        int (*read_byte)(struct pci_dev *, int where, u8 *val);
        int (*read_word)(struct pci_dev *, int where, u16 *val);
        int (*read_dword)(struct pci_dev *, int where, u32 *val);
        int (*write_byte)(struct pci_dev *, int where, u8 val);
        int (*write_word)(struct pci_dev *, int where, u16 val);
        int (*write_dword)(struct pci_dev *, int where, u32 val);
};

struct pbus_set_ranges_data
{
        unsigned long io_start, io_end;
        unsigned long mem_start, mem_end;
        unsigned long prefetch_start, prefetch_end;
};

struct pci_device_id {
        unsigned int vendor, device;
        unsigned int subvendor, subdevice;
        unsigned int class, class_mask;
        unsigned long driver_data;
};

struct pci_driver {
        struct list_head node;
        char *name;
        const struct pci_device_id *id_table;
        int (*probe) (struct pci_dev *dev, const struct pci_device_id *id);
        void (*remove) (struct pci_dev *dev);
        int (*save_state) (struct pci_dev *dev, u32 state);
        int (*suspend) (struct pci_dev *dev, u32 state);
        int (*resume) (struct pci_dev *dev);
        int (*enable_wake) (struct pci_dev *dev, u32 state, int enable);
};
# 535 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h"
#define PCI_DEVICE(vend,dev) .vendor = (vend), .device = (dev), .subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID
# 548 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h"
#define PCI_DEVICE_CLASS(dev_class,dev_class_mask) .class = (dev_class), .class_mask = (dev_class_mask), .vendor = PCI_ANY_ID, .device = PCI_ANY_ID, .subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID







#define pci_for_each_dev(dev) for(dev = pci_dev_g(pci_devices.next); dev != pci_dev_g(&pci_devices); dev = pci_dev_g(dev->global_list.next))


void pcibios_init(void);
void pcibios_fixup_bus(struct pci_bus *);
int pcibios_enable_device(struct pci_dev *, int mask);
char *pcibios_setup (char *str);


void pcibios_align_resource(void *, struct resource *,
                            unsigned long, unsigned long);
void pcibios_update_resource(struct pci_dev *, struct resource *,
                             struct resource *, int);
void pcibios_update_irq(struct pci_dev *, int irq);
void pcibios_fixup_pbus_ranges(struct pci_bus *, struct pbus_set_ranges_data *);



int pcibios_present(void);
int pcibios_read_config_byte (unsigned char bus, unsigned char dev_fn,
                              unsigned char where, unsigned char *val);
int pcibios_read_config_word (unsigned char bus, unsigned char dev_fn,
                              unsigned char where, unsigned short *val);
int pcibios_read_config_dword (unsigned char bus, unsigned char dev_fn,
                               unsigned char where, unsigned int *val);
int pcibios_write_config_byte (unsigned char bus, unsigned char dev_fn,
                               unsigned char where, unsigned char val);
int pcibios_write_config_word (unsigned char bus, unsigned char dev_fn,
                               unsigned char where, unsigned short val);
int pcibios_write_config_dword (unsigned char bus, unsigned char dev_fn,
                                unsigned char where, unsigned int val);
int pcibios_find_class (unsigned int class_code, unsigned short index, unsigned char *bus, unsigned char *dev_fn);
int pcibios_find_device (unsigned short vendor, unsigned short dev_id,
                         unsigned short index, unsigned char *bus,
                         unsigned char *dev_fn);



void pci_init(void);
int pci_bus_exists(const struct list_head *list, int nr);
struct pci_bus *pci_scan_bus(int bus, struct pci_ops *ops, void *sysdata);
struct pci_bus *pci_alloc_primary_bus(int bus);
struct pci_dev *pci_scan_device(struct pci_dev *temp);
struct pci_dev *pci_scan_slot(struct pci_dev *temp);
int pci_proc_attach_device(struct pci_dev *dev);
int pci_proc_detach_device(struct pci_dev *dev);
int pci_proc_attach_bus(struct pci_bus *bus);
int pci_proc_detach_bus(struct pci_bus *bus);
void pci_name_device(struct pci_dev *dev);
char *pci_class_name(u32 class);
void pci_read_bridge_bases(struct pci_bus *child);
struct resource *pci_find_parent_resource(const struct pci_dev *dev, struct resource *res);
int pci_setup_device(struct pci_dev *dev);
int pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge);



struct pci_dev *pci_find_device (unsigned int vendor, unsigned int device, const struct pci_dev *from);
struct pci_dev *pci_find_subsys (unsigned int vendor, unsigned int device,
                                 unsigned int ss_vendor, unsigned int ss_device,
                                 const struct pci_dev *from);
struct pci_dev *pci_find_class (unsigned int class, const struct pci_dev *from);
struct pci_dev *pci_find_slot (unsigned int bus, unsigned int devfn);
int pci_find_capability (struct pci_dev *dev, int cap);

int pci_read_config_byte(struct pci_dev *dev, int where, u8 *val);
int pci_read_config_word(struct pci_dev *dev, int where, u16 *val);
int pci_read_config_dword(struct pci_dev *dev, int where, u32 *val);
int pci_write_config_byte(struct pci_dev *dev, int where, u8 val);
int pci_write_config_word(struct pci_dev *dev, int where, u16 val);
int pci_write_config_dword(struct pci_dev *dev, int where, u32 val);

int pci_enable_device(struct pci_dev *dev);
int pci_enable_device_bars(struct pci_dev *dev, int mask);
void pci_disable_device(struct pci_dev *dev);
void pci_set_master(struct pci_dev *dev);
#define HAVE_PCI_SET_MWI 
int pci_set_mwi(struct pci_dev *dev);
void pci_clear_mwi(struct pci_dev *dev);
int pci_set_dma_mask(struct pci_dev *dev, u64 mask);
int pci_dac_set_dma_mask(struct pci_dev *dev, u64 mask);
int pci_assign_resource(struct pci_dev *dev, int i);


int pci_save_state(struct pci_dev *dev, u32 *buffer);
int pci_restore_state(struct pci_dev *dev, u32 *buffer);
int pci_set_power_state(struct pci_dev *dev, int state);
int pci_enable_wake(struct pci_dev *dev, u32 state, int enable);



int pci_claim_resource(struct pci_dev *, int);
void pci_assign_unassigned_resources(void);
void pdev_enable_device(struct pci_dev *);
void pdev_sort_resources(struct pci_dev *, struct resource_list *);
unsigned long pci_bridge_check_io(struct pci_dev *);
void pci_fixup_irqs(u8 (*)(struct pci_dev *, u8 *),
                    int (*)(struct pci_dev *, u8, u8));
#define HAVE_PCI_REQ_REGIONS 2
int pci_request_regions(struct pci_dev *, char *);
void pci_release_regions(struct pci_dev *);
int pci_request_region(struct pci_dev *, int, char *);
void pci_release_region(struct pci_dev *, int);


int pci_register_driver(struct pci_driver *);
void pci_unregister_driver(struct pci_driver *);
void pci_insert_device(struct pci_dev *, struct pci_bus *);
void pci_remove_device(struct pci_dev *);
struct pci_driver *pci_dev_driver(const struct pci_dev *);
const struct pci_device_id *pci_match_device(const struct pci_device_id *ids, const struct pci_dev *dev);
void pci_announce_device_to_drivers(struct pci_dev *);
unsigned int pci_do_scan_bus(struct pci_bus *bus);
struct pci_bus * pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr);


struct pci_pool *pci_pool_create (const char *name, struct pci_dev *dev,
                size_t size, size_t align, size_t allocation, int flags);
void pci_pool_destroy (struct pci_pool *pool);

void *pci_pool_alloc (struct pci_pool *pool, int flags, dma_addr_t *handle);
void pci_pool_free (struct pci_pool *pool, void *vaddr, dma_addr_t addr);





# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h" 1






#define _ASM_PCI_H 
# 18 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h"
extern unsigned int pcibios_assign_all_busses(void);



#define pcibios_scan_all_fns() 0

#define PCIBIOS_MIN_IO 0x1000
#define PCIBIOS_MIN_MEM 0x10000000

extern void pcibios_set_master(struct pci_dev *dev);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pcibios_penalize_isa_irq(int irq)
{

}
# 41 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h"
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/scatterlist.h" 1

#define __ASM_SCATTERLIST_H 

struct scatterlist {
        char * address;

        struct page * page;
        unsigned int offset;
        dma_addr_t dma_address;
        unsigned int length;
};

#define ISA_DMA_THRESHOLD (0x00ffffff)
# 42 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h" 2

# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h" 1
# 12 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
#define _ASM_IO_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pagemap.h" 1

#define _LINUX_PAGEMAP_H 
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pagemap.h"
# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/highmem.h" 1

#define _LINUX_HIGHMEM_H 


# 1 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgalloc.h" 1
# 10 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgalloc.h"
#define _ASM_PGALLOC_H 
# 25 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgalloc.h"
extern void local_flush_tlb_all(void);
extern void local_flush_tlb_mm(struct mm_struct *mm);
extern void local_flush_tlb_range(struct mm_struct *mm, unsigned long start,
                               unsigned long end);
extern void local_flush_tlb_page(struct vm_area_struct *vma,
                                 unsigned long page);
extern void local_flush_tlb_one(unsigned long page);
# 42 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pgalloc.h"
#define flush_tlb_all() local_flush_tlb_all()
#define flush_tlb_mm(mm) local_flush_tlb_mm(mm)
#define flush_tlb_range(mm,vmaddr,end) local_flush_tlb_range(mm, vmaddr, end)
#define flush_tlb_page(vma,page) local_flush_tlb_page(vma, page)



static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void flush_tlb_pgtables(struct mm_struct *mm,
                                      unsigned long start, unsigned long end)
{

}






#define pgd_quicklist (current_cpu_data.pgd_quick)
#define pmd_quicklist ((unsigned long *)0)
#define pte_quicklist (current_cpu_data.pte_quick)
#define pgtable_cache_size (current_cpu_data.pgtable_cache_sz)

#define pmd_populate(mm,pmd,pte) pmd_set(pmd, pte)




extern void pgd_init(unsigned long page);

static __inline__ __attribute__((always_inline)) pgd_t *get_pgd_slow(void)
{
        pgd_t *ret = (pgd_t *)__get_free_pages((0x20 | 0x10 | 0x40 | 0x80 | 0x100), 0), *init;

        if (ret) {
                init = pgd_offset(&init_mm, 0);
                pgd_init((unsigned long)ret);
                memcpy (ret + (0x80000000UL/(1UL << (2 * 14 - ffz(~sizeof(pte_t))))), init + (0x80000000UL/(1UL << (2 * 14 - ffz(~sizeof(pte_t))))),
                        ((((1L << 14) << 0) / sizeof(pgd_t)) - (0x80000000UL/(1UL << (2 * 14 - ffz(~sizeof(pte_t)))))) * sizeof(pgd_t));
        }
        return ret;
}

static __inline__ __attribute__((always_inline)) pgd_t *get_pgd_fast(void)
{
        unsigned long *ret;

        if((ret = (cpu_data[0].pgd_quick)) != ((void *)0)) {
                (cpu_data[0].pgd_quick) = (unsigned long *)(*ret);
                ret[0] = ret[1];
                (cpu_data[0].pgtable_cache_sz)--;
        } else
                ret = (unsigned long *)get_pgd_slow();
        return (pgd_t *)ret;
}

static __inline__ __attribute__((always_inline)) void free_pgd_fast(pgd_t *pgd)
{
        *(unsigned long *)pgd = (unsigned long) (cpu_data[0].pgd_quick);
        (cpu_data[0].pgd_quick) = (unsigned long *) pgd;
        (cpu_data[0].pgtable_cache_sz)++;
}

static __inline__ __attribute__((always_inline)) void free_pgd_slow(pgd_t *pgd)
{
        free_pages((unsigned long)pgd, 0);
}

static __inline__ __attribute__((always_inline)) pte_t *get_pte_fast(void)
{
        unsigned long *ret;

        if((ret = (unsigned long *)(cpu_data[0].pte_quick)) != ((void *)0)) {
                (cpu_data[0].pte_quick) = (unsigned long *)(*ret);
                ret[0] = ret[1];
                (cpu_data[0].pgtable_cache_sz)--;
        }
        return (pte_t *)ret;
}

static __inline__ __attribute__((always_inline)) void free_pte_fast(pte_t *pte)
{
        *(unsigned long *)pte = (unsigned long) (cpu_data[0].pte_quick);
        (cpu_data[0].pte_quick) = (unsigned long *) pte;
        (cpu_data[0].pgtable_cache_sz)++;
}

static __inline__ __attribute__((always_inline)) void free_pte_slow(pte_t *pte)
{
        free_pages(((unsigned long)pte),0);
}


static __inline__ __attribute__((always_inline)) pmd_t *get_pmd_fast(void)
{
        return (pmd_t *)0;
}

static __inline__ __attribute__((always_inline)) void free_pmd_fast(pmd_t *pmd)
{
}

static __inline__ __attribute__((always_inline)) void free_pmd_slow(pmd_t *pmd)
{
}

extern void __bad_pte(pmd_t *pmd);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t *pte_alloc_one(struct mm_struct *mm, unsigned long address)
{
        pte_t *pte;

        pte = (pte_t *) __get_free_pages(((0x20 | 0x10 | 0x40 | 0x80 | 0x100)),0);
        if (pte)
                clear_page(pte);
        return pte;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) pte_t *pte_alloc_one_fast(struct mm_struct *mm, unsigned long address)
{
        unsigned long *ret;

        if ((ret = (unsigned long *)(cpu_data[0].pte_quick)) != ((void *)0)) {
                (cpu_data[0].pte_quick) = (unsigned long *)(*ret);
                ret[0] = ret[1];
                (cpu_data[0].pgtable_cache_sz)--;
        }
        return (pte_t *)ret;
}

static __inline__ __attribute__((always_inline)) void pte_free_fast(pte_t *pte)
{
        *(unsigned long *)pte = (unsigned long) (cpu_data[0].pte_quick);
        (cpu_data[0].pte_quick) = (unsigned long *) pte;
        (cpu_data[0].pgtable_cache_sz)++;
}

static __inline__ __attribute__((always_inline)) void pte_free_slow(pte_t *pte)
{
        free_pages(((unsigned long)pte),0);
}

#define pte_free(pte) pte_free_fast(pte)
#define pgd_free(pgd) free_pgd_fast(pgd)
#define pgd_alloc(mm) get_pgd_fast()





#define pmd_alloc_one_fast(mm,addr) ({ BUG(); ((pmd_t *)1); })
#define pmd_alloc_one(mm,addr) ({ BUG(); ((pmd_t *)2); })
#define pmd_free(x) do { } while (0)
#define pgd_populate(mm,pmd,pte) BUG()

extern int do_check_pgt_cache(int, int);
# 6 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/highmem.h" 2
# 66 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/highmem.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int nr_free_highpages(void) { return 0; }

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void *kmap(struct page *page) { return ((void *)((unsigned long) ((((page) - page_zone(page)->zone_mem_map) << 14) + page_zone(page)->zone_start_paddr) + 0x80000000UL)); }

#define kunmap(page) do { } while (0)

#define kmap_atomic(page,idx) kmap(page)
#define kunmap_atomic(page,idx) kunmap(page)

#define bh_kmap(bh) ((bh)->b_data)
#define bh_kunmap(bh) do { } while (0)
#define kmap_nonblock(page) kmap(page)
#define bh_kmap_irq(bh,flags) ((bh)->b_data)
#define bh_kunmap_irq(bh,flags) do { *(flags) = 0; } while (0)




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void clear_user_highpage(struct page *page, unsigned long vaddr)
{
        void *addr = kmap(page);
        clear_user_page(addr, vaddr);
        do { } while (0);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void clear_highpage(struct page *page)
{
        clear_page(kmap(page));
        do { } while (0);
}




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void memclear_highpage_flush(struct page *page, unsigned int offset, unsigned int size)
{
        char *kaddr;

        if (offset + size > (1L << 14))
                __out_of_line_bug(105);
        kaddr = kmap(page);
        memset(kaddr + offset, 0, size);
        flush_dcache_page(page);
        do { } while (0);
        do { } while (0);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void copy_user_highpage(struct page *to, struct page *from, unsigned long vaddr)
{
        char *vfrom, *vto;

        vfrom = kmap(from);
        vto = kmap(to);
        copy_user_page(vto, vfrom, vaddr);
        do { } while (0);
        do { } while (0);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void copy_highpage(struct page *to, struct page *from)
{
        char *vfrom, *vto;

        vfrom = kmap(from);
        vto = kmap(to);
        copy_page(vto, vfrom);
        do { } while (0);
        do { } while (0);
}
# 17 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pagemap.h" 2
# 26 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pagemap.h"
#define PAGE_CACHE_SHIFT PAGE_SHIFT
#define PAGE_CACHE_SIZE PAGE_SIZE
#define PAGE_CACHE_MASK PAGE_MASK
#define PAGE_CACHE_ALIGN(addr) (((addr)+PAGE_CACHE_SIZE-1)&PAGE_CACHE_MASK)

#define page_cache_get(x) get_page(x)
#define page_cache_release(x) __free_page(x)

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct page *page_cache_alloc(struct address_space *x)
{
        return alloc_pages(x->gfp_mask, 0);
}




#define page_cache_entry(x) virt_to_page(x)

extern unsigned int page_hash_bits;
#define PAGE_HASH_BITS (page_hash_bits)
#define PAGE_HASH_SIZE (1 << PAGE_HASH_BITS)

extern unsigned long page_cache_size;
extern struct page **page_hash_table;

extern void page_cache_init(unsigned long);
# 62 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pagemap.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long _page_hashfn(struct address_space * mapping, unsigned long index)
{
#define i (((unsigned long) mapping)/(sizeof(struct inode) & ~ (sizeof(struct inode) - 1)))
#define s(x) ((x)+((x)>>PAGE_HASH_BITS))
        return (((((unsigned long) mapping)/(sizeof(struct inode) & ~ (sizeof(struct inode) - 1)))+index)+(((((unsigned long) mapping)/(sizeof(struct inode) & ~ (sizeof(struct inode) - 1)))+index)>>(page_hash_bits))) & ((1 << (page_hash_bits))-1);
#undef i
#undef s
}

#define page_hash(mapping,index) (page_hash_table+_page_hashfn(mapping,index))

extern struct page * __find_get_page(struct address_space *mapping,
                                unsigned long index, struct page **hash);
#define find_get_page(mapping,index) __find_get_page(mapping, index, page_hash(mapping, index))

extern struct page * __find_lock_page (struct address_space * mapping,
                                unsigned long index, struct page **hash);
extern struct page * find_or_create_page(struct address_space *mapping,
                                unsigned long index, unsigned int gfp_mask);

extern void lock_page(struct page *page);
extern void unlock_page(struct page *page);
#define find_lock_page(mapping,index) __find_lock_page(mapping, index, page_hash(mapping, index))

extern struct page *find_trylock_page(struct address_space *, unsigned long);

extern void add_to_page_cache(struct page * page, struct address_space *mapping, unsigned long index);
extern void add_to_page_cache_locked(struct page * page, struct address_space *mapping, unsigned long index);
extern int add_to_page_cache_unique(struct page * page, struct address_space *mapping, unsigned long index, struct page **hash);

extern void ___wait_on_page(struct page *);

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void wait_on_page(struct page * page)
{
        if (test_bit(0, &(page)->flags))
                ___wait_on_page(page);
}

extern void wakeup_page_waiters(struct page * page);




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct page *grab_cache_page(struct address_space *mapping, unsigned long index)
{
        return find_or_create_page(mapping, index, mapping->gfp_mask);
}


extern struct page * grab_cache_page_nowait (struct address_space *, unsigned long);

typedef int filler_t(void *, struct page*);

extern struct page *read_cache_page(struct address_space *, unsigned long,
                                filler_t *, void *);
# 16 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h" 2
# 28 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
#define bus_to_baddr(bus,addr) (addr)
#define baddr_to_bus(bus,addr) (addr)
#define __swizzle_addr_w(port) (port)
# 52 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
#define __ioswab16(x) (x)




#define __ioswab32(x) (x)
# 66 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
#define page_to_phys(page) ((page - mem_map) << PAGE_SHIFT)


#define IO_SPACE_LIMIT 0xffff

extern void * __ioremap(phys_t offset, phys_t size, unsigned long flags);
# 85 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
#define ioremap(offset,size) __ioremap((offset), (size), _CACHE_UNCACHED)
# 107 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
#define ioremap_nocache(offset,size) __ioremap((offset), (size), _CACHE_UNCACHED)

#define ioremap_cacheable_cow(offset,size) __ioremap((offset), (size), _CACHE_CACHABLE_COW)

#define ioremap_uncached_accelerated(offset,size) __ioremap((offset), (size), _CACHE_UNCACHED_ACCELERATED)


extern void iounmap(void *addr);






#define readb(addr) (*(volatile unsigned char *)(addr))
#define readw(addr) __ioswab16((*(volatile unsigned short *)(addr)))
#define readl(addr) __ioswab32((*(volatile unsigned int *)(addr)))

#define __raw_readb(addr) (*(volatile unsigned char *)(addr))
#define __raw_readw(addr) (*(volatile unsigned short *)(addr))
#define __raw_readl(addr) (*(volatile unsigned int *)(addr))

#define writeb(b,addr) ((*(volatile unsigned char *)(addr)) = (b))
#define writew(b,addr) ((*(volatile unsigned short *)(addr)) = (__ioswab16(b)))
#define writel(b,addr) ((*(volatile unsigned int *)(addr)) = (__ioswab32(b)))

#define __raw_writeb(b,addr) ((*(volatile unsigned char *)(addr)) = (b))
#define __raw_writew(w,addr) ((*(volatile unsigned short *)(addr)) = (w))
#define __raw_writel(l,addr) ((*(volatile unsigned int *)(addr)) = (l))




#define memset_io(a,b,c) memset((void *)(a),(b),(c))
#define memcpy_fromio(a,b,c) memcpy((a),(void *)(b),(c))
#define memcpy_toio(a,b,c) memcpy((void *)(a),(b),(c))






extern unsigned long isa_slot_offset;
# 159 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
#define __ISA_IO_base ((char *)(isa_slot_offset))

#define isa_readb(a) readb(__ISA_IO_base + (a))
#define isa_readw(a) readw(__ISA_IO_base + (a))
#define isa_readl(a) readl(__ISA_IO_base + (a))
#define isa_writeb(b,a) writeb(b,__ISA_IO_base + (a))
#define isa_writew(w,a) writew(w,__ISA_IO_base + (a))
#define isa_writel(l,a) writel(l,__ISA_IO_base + (a))
#define isa_memset_io(a,b,c) memset_io(__ISA_IO_base + (a),(b),(c))
#define isa_memcpy_fromio(a,b,c) memcpy_fromio((a),__ISA_IO_base + (b),(c))
#define isa_memcpy_toio(a,b,c) memcpy_toio(__ISA_IO_base + (a),(b),(c))





#define eth_io_copy_and_sum(skb,src,len,unused) memcpy_fromio((skb)->data,(src),(len))
#define isa_eth_io_copy_and_sum(a,b,c,d) eth_copy_and_sum((a),(b),(c),(d))
# 188 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int check_signature(unsigned long io_addr,
        const unsigned char *signature, int length)
{
        int retval = 0;
        do {
                if ((*(volatile unsigned char *)(io_addr)) != *signature)
                        goto out;
                io_addr++;
                signature++;
                length--;
        } while (length);
        retval = 1;
out:
        return retval;
}
# 217 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int isa_check_signature(unsigned long io_addr,
        const unsigned char *signature, int length)
{
        int retval = 0;
        do {
                if ((*(volatile unsigned char *)(((char *)(isa_slot_offset)) + (io_addr))) != *signature)
                        goto out;
                io_addr++;
                signature++;
                length--;
        } while (length);
        retval = 1;
out:
        return retval;
}
# 246 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long virt_to_phys(volatile void * address)
{
        return (unsigned long)address - 0x80000000UL;
}
# 264 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void * phys_to_virt(unsigned long address)
{
        return (void *)(address + 0x80000000UL);
}




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long virt_to_bus(volatile void * address)
{
        return (unsigned long)address - 0x80000000UL;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void * bus_to_virt(unsigned long address)
{
        return (void *)(address + 0x80000000UL);
}


#define page_to_bus page_to_phys
# 293 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
extern const unsigned long mips_io_port_base;

#define set_io_port_base(base) do { * (unsigned long *) &mips_io_port_base = (base); } while (0)


#define __SLOW_DOWN_IO __asm__ __volatile__( "sb\t$0,0x80(%0)" : : "r" (mips_io_port_base));
# 310 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
#define SLOW_DOWN_IO 


#define outb(val,port) do { *(volatile u8 *)(mips_io_port_base + (port)) = (val); } while(0)




#define outw(val,port) do { *(volatile u16 *)(mips_io_port_base + __swizzle_addr_w(port)) = __ioswab16(val); } while(0)





#define outl(val,port) do { *(volatile u32 *)(mips_io_port_base + (port)) = __ioswab32(val);} while(0)




#define outb_p(val,port) do { *(volatile u8 *)(mips_io_port_base + (port)) = (val); SLOW_DOWN_IO; } while(0)





#define outw_p(val,port) do { *(volatile u16 *)(mips_io_port_base + __swizzle_addr_w(port)) = __ioswab16(val); SLOW_DOWN_IO; } while(0)






#define outl_p(val,port) do { *(volatile u32 *)(mips_io_port_base + (port)) = __ioswab32(val); SLOW_DOWN_IO; } while(0)





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned char inb(unsigned long port)
{
        return *(volatile u8 *)(mips_io_port_base + port);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned short inw(unsigned long port)
{
        port = (port);

        return (*(volatile u16 *)(mips_io_port_base + port));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int inl(unsigned long port)
{
        return (*(volatile u32 *)(mips_io_port_base + port));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned char inb_p(unsigned long port)
{
        u8 __val;

        __val = *(volatile u8 *)(mips_io_port_base + port);
        ;

        return __val;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned short inw_p(unsigned long port)
{
        u16 __val;

        port = (port);
        __val = *(volatile u16 *)(mips_io_port_base + port);
        ;

        return (__val);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned int inl_p(unsigned long port)
{
        u32 __val;

        __val = *(volatile u32 *)(mips_io_port_base + port);
        ;
        return (__val);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __outsb(unsigned long port, void *addr, unsigned int count)
{
        while (count--) {
                do { *(volatile u8 *)(mips_io_port_base + (port)) = (*(u8 *)addr); } while(0);
                addr++;
        }
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __insb(unsigned long port, void *addr, unsigned int count)
{
        while (count--) {
                *(u8 *)addr = inb(port);
                addr++;
        }
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __outsw(unsigned long port, void *addr, unsigned int count)
{
        while (count--) {
                do { *(volatile u16 *)(mips_io_port_base + (port)) = (*(u16 *)addr); } while(0);
                addr += 2;
        }
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __insw(unsigned long port, void *addr, unsigned int count)
{
        while (count--) {
                *(u16 *)addr = inw(port);
                addr += 2;
        }
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __outsl(unsigned long port, void *addr, unsigned int count)
{
        while (count--) {
                do { *(volatile u32 *)(mips_io_port_base + (port)) = (*(u32 *)addr);} while(0);
                addr += 4;
        }
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void __insl(unsigned long port, void *addr, unsigned int count)
{
        while (count--) {
                *(u32 *)addr = inl(port);
                addr += 4;
        }
}

#define outsb(port,addr,count) __outsb(port, addr, count)
#define insb(port,addr,count) __insb(port, addr, count)
#define outsw(port,addr,count) __outsw(port, addr, count)
#define insw(port,addr,count) __insw(port, addr, count)
#define outsl(port,addr,count) __outsl(port, addr, count)
#define insl(port,addr,count) __insl(port, addr, count)
# 470 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/io.h"
extern void (*_dma_cache_wback_inv)(unsigned long start, unsigned long size);
extern void (*_dma_cache_wback)(unsigned long start, unsigned long size);
extern void (*_dma_cache_inv)(unsigned long start, unsigned long size);

#define dma_cache_wback_inv(start,size) _dma_cache_wback_inv(start,size)
#define dma_cache_wback(start,size) _dma_cache_wback(start,size)
#define dma_cache_inv(start,size) _dma_cache_inv(start,size)
# 44 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h" 2
# 52 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h"
struct pci_dev;






#define PCI_DMA_BUS_IS_PHYS (1)
# 69 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h"
extern void *pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
                                  dma_addr_t *dma_handle);
# 81 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h"
extern void pci_free_consistent(struct pci_dev *hwdev, size_t size,
                                void *vaddr, dma_addr_t dma_handle);
# 91 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) dma_addr_t pci_map_single(struct pci_dev *hwdev, void *ptr,
                                        size_t size, int direction)
{
        unsigned long addr = (unsigned long) ptr;

        if (direction == 3)
                __out_of_line_bug(97);

        _dma_cache_wback_inv(addr,size);

        return (((unsigned long) (ptr) - 0x80000000UL));
}
# 112 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pci_unmap_single(struct pci_dev *hwdev, dma_addr_t dma_addr,
                                    size_t size, int direction)
{
        if (direction == 3)
                __out_of_line_bug(116);

        if (direction != 1) {
                unsigned long addr;

                addr = (dma_addr) + 0x80000000UL;
                _dma_cache_wback_inv(addr,size);
        }
}





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) dma_addr_t pci_map_page(struct pci_dev *hwdev, struct page *page,
                                      unsigned long offset, size_t size,
                                      int direction)
{
        unsigned long addr;

        if (direction == 3)
                __out_of_line_bug(137);

        addr = (unsigned long) ((void *)((unsigned long) ((((page) - page_zone(page)->zone_mem_map) << 14) + page_zone(page)->zone_start_paddr) + 0x80000000UL)) + offset;
        _dma_cache_wback_inv(addr,size);

        return (((page - mem_map) << 14) + offset);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pci_unmap_page(struct pci_dev *hwdev, dma_addr_t dma_address,
                                  size_t size, int direction)
{
        if (direction == 3)
                __out_of_line_bug(149);

        if (direction != 1) {
                unsigned long addr;

                addr = (dma_address) + 0x80000000UL;
                _dma_cache_wback_inv(addr,size);
        }
}


#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME) 
#define DECLARE_PCI_UNMAP_LEN(LEN_NAME) 
#define pci_unmap_addr(PTR,ADDR_NAME) (0)
#define pci_unmap_addr_set(PTR,ADDR_NAME,VAL) do { } while (0)
#define pci_unmap_len(PTR,LEN_NAME) (0)
#define pci_unmap_len_set(PTR,LEN_NAME,VAL) do { } while (0)
# 183 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pci_map_sg(struct pci_dev *hwdev, struct scatterlist *sg,
                             int nents, int direction)
{
        int i;

        if (direction == 3)
                __out_of_line_bug(189);

        for (i = 0; i < nents; i++, sg++) {
                if (sg->address && sg->page)
                        __out_of_line_bug(193);
                else if (!sg->address && !sg->page)
                        __out_of_line_bug(195);

                if (sg->address) {
                        _dma_cache_wback_inv((unsigned long)sg->address,sg->length);

                        sg->dma_address = (((unsigned long) (sg->address) - 0x80000000UL));
                } else {
                        sg->dma_address = ((sg->page - mem_map) << 14) +
                                          sg->offset;
                        _dma_cache_wback_inv((unsigned long) (((void *)((unsigned long) ((((sg->page) - page_zone(sg->page)->zone_mem_map) << 14) + page_zone(sg->page)->zone_start_paddr) + 0x80000000UL)) + sg->offset),sg->length);


                }
        }

        return nents;
}






static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pci_unmap_sg(struct pci_dev *hwdev, struct scatterlist *sg,
                                int nents, int direction)
{
        int i;

        if (direction == 3)
                __out_of_line_bug(224);

        if (direction == 1)
                return;

        for (i = 0; i < nents; i++, sg++) {
                if (sg->address && sg->page)
                        __out_of_line_bug(231);
                else if (!sg->address && !sg->page)
                        __out_of_line_bug(233);

                if (!sg->address)
                        continue;
                _dma_cache_wback_inv((unsigned long)sg->address,sg->length);
        }
}
# 251 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pci_dma_sync_single(struct pci_dev *hwdev,
                                       dma_addr_t dma_handle,
                                       size_t size, int direction)
{
        unsigned long addr;

        if (direction == 3)
                __out_of_line_bug(258);

        addr = (dma_handle) + 0x80000000UL;
        _dma_cache_wback_inv(addr,size);
}
# 271 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pci_dma_sync_sg(struct pci_dev *hwdev,
                                   struct scatterlist *sg,
                                   int nelems, int direction)
{

        int i;


        if (direction == 3)
                __out_of_line_bug(280);



        for (i = 0; i < nelems; i++, sg++)
                _dma_cache_wback_inv((unsigned long)sg->address,sg->length);

}







static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pci_dma_supported(struct pci_dev *hwdev, u64 mask)
{






        if (mask < 0x00ffffff)
                return 0;


        return 1;
}


#define pci_dac_dma_supported(pci_dev,mask) (1)

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) dma64_addr_t pci_dac_page_to_dma(struct pci_dev *pdev,
        struct page *page, unsigned long offset, int direction)
{
        dma64_addr_t addr = ((page - mem_map) << 14) + offset;

        return (dma64_addr_t) (addr);
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) struct page *pci_dac_dma_to_page(struct pci_dev *pdev,
        dma64_addr_t dma_addr)
{
        unsigned long poff = (dma_addr) >> 14;

        return mem_map + poff;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) unsigned long pci_dac_dma_to_offset(struct pci_dev *pdev,
        dma64_addr_t dma_addr)
{
        return dma_addr & ~(~((1L << 14)-1));
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pci_dac_dma_sync_single(struct pci_dev *pdev,
        dma64_addr_t dma_addr, size_t len, int direction)
{
        unsigned long addr;

        if (direction == 3)
                do { __asm__ __volatile__("break %0" : : "i" (512)); } while (0);

        addr = (dma_addr) + 0x80000000UL;
        _dma_cache_wback_inv(addr,len);
}




#define pci_controller_num(pdev) ({ (void)(pdev); 0; })
# 359 "/media/etch/work/sict_cpci/linux-2.4-new/include/asm/pci.h"
#define sg_dma_address(sg) ((sg)->dma_address)
#define sg_dma_len(sg) ((sg)->length)
# 684 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h" 2
# 750 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int pci_module_init(struct pci_driver *drv)
{
        int rc = pci_register_driver (drv);

        if (rc > 0)
                return 0;






        if (rc == 0)
                return 0;







        pci_unregister_driver (drv);

        return rc;
}





#define pci_resource_start(dev,bar) ((dev)->resource[(bar)].start)
#define pci_resource_end(dev,bar) ((dev)->resource[(bar)].end)
#define pci_resource_flags(dev,bar) ((dev)->resource[(bar)].flags)
#define pci_resource_len(dev,bar) ((pci_resource_start((dev),(bar)) == 0 && pci_resource_end((dev),(bar)) == pci_resource_start((dev),(bar))) ? 0 : (pci_resource_end((dev),(bar)) - pci_resource_start((dev),(bar)) + 1))
# 795 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h"
static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void *pci_get_drvdata (struct pci_dev *pdev)
{
        return pdev->driver_data;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void pci_set_drvdata (struct pci_dev *pdev, void *data)
{
        pdev->driver_data = data;
}

static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) char *pci_name(struct pci_dev *pdev)
{
        return pdev->slot_name;
}
# 817 "/media/etch/work/sict_cpci/linux-2.4-new/include/linux/pci.h"
struct pci_fixup {
        int pass;
        u16 vendor, device;
        void (*hook)(struct pci_dev *dev);
};

extern struct pci_fixup pcibios_fixups[];

#define PCI_FIXUP_HEADER 1
#define PCI_FIXUP_FINAL 2

void pci_fixup_device(int pass, struct pci_dev *dev);

extern int pci_pci_problems;
#define PCIPCI_FAIL 1
#define PCIPCI_TRITON 2
#define PCIPCI_NATOMA 4
#define PCIPCI_VIAETBF 8
#define PCIPCI_VSFX 16
#define PCIPCI_ALIMAGIK 32
# 218 "drivers/char/serial.c" 2
# 242 "drivers/char/serial.c"
#define SERIAL_DEV_OFFSET 0





#define _INLINE_ 


static char *serial_name = "Serial driver";

static struct list_head tq_serial = { &(tq_serial), &(tq_serial) };

static struct tty_driver serial_driver, callout_driver;
static int serial_refcount;

static struct timer_list serial_timer;
# 267 "drivers/char/serial.c"
#define WAKEUP_CHARS 256






static struct async_struct *IRQ_ports[128];



static int IRQ_timeout[128];

static struct console sercons;
static int lsr_break_flag;





static unsigned detect_uart_irq (struct serial_state * state);
static void autoconfig(struct serial_state * state);
static void change_speed(struct async_struct *info, struct termios *old);
static void rs_wait_until_sent(struct tty_struct *tty, int timeout);





static struct serial_uart_config uart_config[] = {
        { "unknown", 1, 0 },
        { "8250", 1, 0 },
        { "16450", 1, 0 },
        { "16550", 1, 0 },
        { "16550A", 16, 0x01 | 0x02 },
        { "cirrus", 1, 0 },
        { "ST16650", 1, 0x01 | 0x04 },
        { "ST16650V2", 32, 0x01 | 0x02 |
                  0x04 },
        { "TI16750", 64, 0x01 | 0x02},
        { "Startech", 1, 0},
        { "16C950/954", 128, 0x01 | 0x02},
        { "ST16654", 64, 0x01 | 0x02 |
                  0x04 },
        { "XR16850", 128, 0x01 | 0x02 |
                  0x04 },
        { "RSA", 2048, 0x01 | 0x02 },
        { 0, 0}
};
# 329 "drivers/char/serial.c"
struct serial_state rs_table[64] = {
        { 0, (5*25000000/2/16), 0x1A0, 9, 0x0002 }, { 0, (5*25000000/2/16), 0x1A8, 9, 0x0002 }, { 0, (5*25000000/2/16), 0x1B0, 9, 0x0002 }, { 0, (5*25000000/2/16), 0x1B8, 9, 0x0002 }, { 0, (5*25000000/2/16), 0x2A0, 5, 0x0002 }, { 0, (5*25000000/2/16), 0x2A8, 5, 0x0002 }, { 0, (5*25000000/2/16), 0x2B0, 5, 0x0002 }, { 0, (5*25000000/2/16), 0x2B8, 5, 0x0002 }, { 0, (5*25000000/2/16), 0x330, 4, 0 }, { 0, (5*25000000/2/16), 0x338, 4, 0 }, { 0, (5*25000000/2/16), 0x000, 0, 0 }, { 0, (5*25000000/2/16), 0x000, 0, 0 }, { 0, (5*25000000/2/16), 0x100, 12, 0 }, { 0, (5*25000000/2/16), 0x108, 12, 0 }, { 0, (5*25000000/2/16), 0x110, 12, 0 }, { 0, (5*25000000/2/16), 0x118, 12, 0 }, { 0, (5*25000000/2/16), 0x120, 12, 0 }, { 0, (5*25000000/2/16), 0x128, 12, 0 }, { 0, (5*25000000/2/16), 0x130, 12, 0 }, { 0, (5*25000000/2/16), 0x138, 12, 0 }, { 0, (5*25000000/2/16), 0x140, 12, 0 }, { 0, (5*25000000/2/16), 0x148, 12, 0 }, { 0, (5*25000000/2/16), 0x150, 12, 0 }, { 0, (5*25000000/2/16), 0x158, 12, 0 }, { 0, (5*25000000/2/16), 0x160, 12, 0 }, { 0, (5*25000000/2/16), 0x168, 12, 0 }, { 0, (5*25000000/2/16), 0x170, 12, 0 }, { 0, (5*25000000/2/16), 0x178, 12, 0 }, { .baud_base=(5*25000000/2/16), .iomem_base=0xb2e40000,.irq=2,.flags=(0x10000000 | 0x0040),.iomem_reg_shift=2, .io_type=2},
};

#define NR_PORTS (sizeof(rs_table)/sizeof(struct serial_state))
int serial_nr_ports = (sizeof(rs_table)/sizeof(struct serial_state));


#define NR_PCI_BOARDS 8

static struct pci_board_inst serial_pci_board[8];


#define IS_PCI_REGION_IOPORT(dev,r) (pci_resource_flags((dev), (r)) & IORESOURCE_IO)



#define IS_PCI_REGION_IOMEM(dev,r) (pci_resource_flags((dev), (r)) & IORESOURCE_MEM)



#define PCI_IRQ_RESOURCE(dev,r) ((dev)->irq_resource[r].start)


#define pci_get_subvendor(dev) ((dev)->subsystem_vendor)
#define pci_get_subdevice(dev) ((dev)->subsystem_device)




#define PREPARE_FUNC(dev) (dev->prepare)
#define ACTIVATE_FUNC(dev) (dev->activate)
#define DEACTIVATE_FUNC(dev) (dev->deactivate)


#define HIGH_BITS_OFFSET ((sizeof(long)-sizeof(int))*8)

static struct tty_struct *serial_table[(sizeof(rs_table)/sizeof(struct serial_state))];
static struct termios *serial_termios[(sizeof(rs_table)/sizeof(struct serial_state))];
static struct termios *serial_termios_locked[(sizeof(rs_table)/sizeof(struct serial_state))];






#define DBG_CNT(s) 
# 387 "drivers/char/serial.c"
static unsigned char *tmp_buf;

static struct semaphore tmp_buf_sem = { .count = { (1) }, .waking = { (0) }, .wait = { lock: (spinlock_t) { }, task_list: { &((tmp_buf_sem).wait).task_list, &((tmp_buf_sem).wait).task_list }, } };





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int serial_paranoia_check(struct async_struct *info,
                                        kdev_t device, const char *routine)
{
# 413 "drivers/char/serial.c"
        return 0;
}

static unsigned int serial_in(struct async_struct *info, int offset)
{
        switch (info->io_type) {





        case 2:
                return (*(volatile unsigned char *)((unsigned long) info->iomem_base + (offset<<info->iomem_reg_shift)));

        default:
                return inb(info->port + offset);
        }
}

static void serial_out(struct async_struct *info, int offset,
                                int value)
{
        switch (info->io_type) {






        case 2:
                ((*(volatile unsigned char *)((unsigned long) info->iomem_base + (offset<<info->iomem_reg_shift))) = (value));

                break;
        default:
                do { *(volatile u8 *)(mips_io_port_base + (info->port+offset)) = (value); } while(0);
        }
}







#define serial_inp(info,offset) serial_in(info, offset)
#define serial_outp(info,offset,value) serial_out(info, offset, value)





void serial_icr_write(struct async_struct *info, int offset, int value)
{
        serial_out(info, 7, offset);
        serial_out(info, 0x05, value);
}

unsigned int serial_icr_read(struct async_struct *info, int offset)
{
        int value;

        serial_icr_write(info, 0x00, info->ACR | 0x40);
        serial_out(info, 7, offset);
        value = serial_in(info, 0x05);
        serial_icr_write(info, 0x00, info->ACR);
        return value;
}
# 489 "drivers/char/serial.c"
static void rs_stop(struct tty_struct *tty)
{
        struct async_struct *info = (struct async_struct *)tty->driver_data;
        unsigned long flags;

        if (serial_paranoia_check(info, tty->device, "rs_stop"))
                return;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        if (info->IER & 0x02) {
                info->IER &= ~0x02;
                serial_out(info, 1, info->IER);
        }
        if (info->state->type == 10) {
                info->ACR |= 0x02;
                serial_icr_write(info, 0x00, info->ACR);
        }
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}

static void rs_start(struct tty_struct *tty)
{
        struct async_struct *info = (struct async_struct *)tty->driver_data;
        unsigned long flags;

        if (serial_paranoia_check(info, tty->device, "rs_start"))
                return;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        if (info->xmit.head != info->xmit.tail
            && info->xmit.buf
            && !(info->IER & 0x02)) {
                info->IER |= 0x02;
                serial_out(info, 1, info->IER);
        }
        if (info->state->type == 10) {
                info->ACR &= ~0x02;
                serial_icr_write(info, 0x00, info->ACR);
        }
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}
# 556 "drivers/char/serial.c"
static void rs_sched_event(struct async_struct *info,
                                  int event)
{
        info->event |= 1 << event;
        queue_task(&info->tqueue, &tq_serial);
        mark_bh(SERIAL_BH);
}

static void receive_chars(struct async_struct *info,
                                 int *status, struct pt_regs * regs)
{
        struct tty_struct *tty = info->tty;
        unsigned char ch;
        struct async_icount *icount;
        int max_count = 256;

        icount = &info->state->icount;
        do {
                if (tty->flip.count >= 512) {
                        tty->flip.tqueue.routine((void *) tty);
                        if (tty->flip.count >= 512) {





                                do {
                                        serial_in(info, 0);
                                        icount->overrun++;
                                        *status = serial_in(info, 5);
                                } while ((*status & 0x01) && (max_count-- > 0));
                                return;
                        }
                }
                ch = serial_in(info, 0);
                *tty->flip.char_buf_ptr = ch;
                icount->rx++;




                *tty->flip.flag_buf_ptr = 0;
                if (*status & (0x10 | 0x04 |
                               0x08 | 0x02)) {



                        if (*status & 0x10) {
                                *status &= ~(0x08 | 0x04);
                                icount->brk++;
# 621 "drivers/char/serial.c"
                                if (info->flags & 0x0004)
                                        do_SAK(tty);
                        } else if (*status & 0x04)
                                icount->parity++;
                        else if (*status & 0x08)
                                icount->frame++;
                        if (*status & 0x02)
                                icount->overrun++;




                        *status &= info->read_status_mask;


                        if (info->line == sercons.index) {

                                *status |= lsr_break_flag;
                                lsr_break_flag = 0;
                        }

                        if (*status & (0x10)) {



                                *tty->flip.flag_buf_ptr = 1;
                        } else if (*status & 0x04)
                                *tty->flip.flag_buf_ptr = 3;
                        else if (*status & 0x08)
                                *tty->flip.flag_buf_ptr = 2;
                }
# 663 "drivers/char/serial.c"
                if ((*status & info->ignore_status_mask) == 0) {
                        tty->flip.flag_buf_ptr++;
                        tty->flip.char_buf_ptr++;
                        tty->flip.count++;
                }
                if ((*status & 0x02) &&
                    (tty->flip.count < 512)) {





                        *tty->flip.flag_buf_ptr = 4;
                        tty->flip.count++;
                        tty->flip.flag_buf_ptr++;
                        tty->flip.char_buf_ptr++;
                }



                *status = serial_in(info, 5);
        } while ((*status & 0x01) && (max_count-- > 0));

        tty_flip_buffer_push(tty);



}

static void transmit_chars(struct async_struct *info, int *intr_done)
{
        int count;

        if (info->x_char) {
                serial_out(info, 0, info->x_char);
                info->state->icount.tx++;
                info->x_char = 0;
                if (intr_done)
                        *intr_done = 0;
                return;
        }
        if (info->xmit.head == info->xmit.tail
            || info->tty->stopped
            || info->tty->hw_stopped) {
                info->IER &= ~0x02;
                serial_out(info, 1, info->IER);
                return;
        }

        count = info->xmit_fifo_size;
        do {
                serial_out(info, 0, info->xmit.buf[info->xmit.tail]);
                info->xmit.tail = (info->xmit.tail + 1) & ((1L << 14)-1);
                info->state->icount.tx++;
                if (info->xmit.head == info->xmit.tail)
                        break;
        } while (--count > 0);

        if ((((info->xmit.head) - (info->xmit.tail)) & (((1L << 14))-1)) < 256)


                rs_sched_event(info, 0);




        if (intr_done)
                *intr_done = 0;

        if (info->xmit.head == info->xmit.tail) {
                info->IER &= ~0x02;
                serial_out(info, 1, info->IER);
        }
}

static void check_modem_status(struct async_struct *info)
{
        int status;
        struct async_icount *icount;

        status = serial_in(info, 6);

        if (status & 0x0F) {
                icount = &info->state->icount;

                if (status & 0x04)
                        icount->rng++;
                if (status & 0x02)
                        icount->dsr++;
                if (status & 0x08) {
                        icount->dcd++;





                }
                if (status & 0x01)
                        icount->cts++;
                __wake_up((&info->delta_msr_wait),1, 1);
        }

        if ((info->flags & 0x02000000) && (status & 0x08)) {




                if (status & 0x80)
                        __wake_up((&info->open_wait),1, 1);
                else if (!((info->flags & 0x40000000) &&
                           (info->flags & 0x0400))) {



                        if (info->tty)
                                tty_hangup(info->tty);
                }
        }
        if (info->flags & 0x04000000) {
                if (info->tty->hw_stopped) {
                        if (status & 0x10) {



                                info->tty->hw_stopped = 0;
                                info->IER |= 0x02;
                                serial_out(info, 1, info->IER);
                                rs_sched_event(info, 0);
                                return;
                        }
                } else {
                        if (!(status & 0x10)) {



                                info->tty->hw_stopped = 1;
                                info->IER &= ~0x02;
                                serial_out(info, 1, info->IER);
                        }
                }
        }
}





static void rs_interrupt(int irq, void *dev_id, struct pt_regs * regs)
{
        int status, iir;
        struct async_struct * info;
        int pass_counter = 0;
        struct async_struct *end_mark = 0;
# 825 "drivers/char/serial.c"
        info = IRQ_ports[irq];
        if (!info)
                return;







        do {
                if (!info->tty ||
                    ((iir=serial_in(info, 2)) & 0x01)) {
                        if (!end_mark)
                                end_mark = info;
                        goto next;
                }



                end_mark = 0;

                info->last_active = jiffies;

                status = serial_in(info, 5);



                if (status & 0x01)
                        receive_chars(info, &status, regs);
                check_modem_status(info);






                if (status & 0x20)
                        transmit_chars(info, 0);


        next:
                info = info->next_port;
                if (!info) {
                        info = IRQ_ports[irq];
                        if (pass_counter++ > 256) {



                                break;
                        }
                        continue;
                }
        } while (end_mark != info);
# 888 "drivers/char/serial.c"
}






static void rs_interrupt_single(int irq, void *dev_id, struct pt_regs * regs)
{
        int status, iir;
        int pass_counter = 0;
        struct async_struct * info;
# 909 "drivers/char/serial.c"
        info = IRQ_ports[irq];
        if (!info || !info->tty)
                return;







        iir = serial_in(info, 2);
        do {
                status = serial_in(info, 5);



                if (status & 0x01)
                        receive_chars(info, &status, regs);
                check_modem_status(info);






                if (status & 0x20)
                        transmit_chars(info, 0);

                if (pass_counter++ > 256) {



                        break;
                }
                iir = serial_in(info, 2);



        } while ((iir & 0x01) == 0);
        info->last_active = jiffies;
# 958 "drivers/char/serial.c"
}
# 1063 "drivers/char/serial.c"
static void do_serial_bh(void)
{
        run_task_queue(&tq_serial);
}

static void do_softint(void *private_)
{
        struct async_struct *info = (struct async_struct *) private_;
        struct tty_struct *tty;

        tty = info->tty;
        if (!tty)
                return;

        if (test_and_clear_bit(0, &info->event)) {
                tty_wakeup(tty);




        }
}
# 1093 "drivers/char/serial.c"
static void rs_timer(unsigned long dummy)
{
        static unsigned long last_strobe;
        struct async_struct *info;
        unsigned int i;
        unsigned long flags;

        if ((jiffies - last_strobe) >= (10*100)) {
                for (i=0; i < 128; i++) {
                        info = IRQ_ports[i];
                        if (!info)
                                continue;
                        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();

                        if (info->next_port) {
                                do {
                                        serial_out(info, 1, 0);
                                        info->IER |= 0x02;
                                        serial_out(info, 1, info->IER);
                                        info = info->next_port;
                                } while (info);





                                        rs_interrupt(i, ((void *)0), ((void *)0));
                        } else

                                rs_interrupt_single(i, ((void *)0), ((void *)0));
                        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                }
        }
        last_strobe = jiffies;
        mod_timer(&serial_timer, jiffies + (10*100));

        if (IRQ_ports[0]) {
                __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();

                rs_interrupt(0, ((void *)0), ((void *)0));



                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);

                mod_timer(&serial_timer, jiffies + IRQ_timeout[0]);
        }
}
# 1156 "drivers/char/serial.c"
static void figure_IRQ_timeout(int irq)
{
        struct async_struct *info;
        int timeout = 60*100;

        info = IRQ_ports[irq];
        if (!info) {
                IRQ_timeout[irq] = 60*100;
                return;
        }
        while (info) {
                if (info->timeout < timeout)
                        timeout = info->timeout;
                info = info->next_port;
        }
        if (!irq)
                timeout = timeout / 2;
        IRQ_timeout[irq] = (timeout > 3) ? timeout-2 : 1;
}



static int enable_rsa(struct async_struct *info)
{
        unsigned char mode;
        int result;
        unsigned long flags;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        mode = serial_in(info, (((-8)) + 0));
        result = mode & (1 << 2);

        if (!result) {
                serial_out(info, (((-8)) + 0), mode | (1 << 2));
                mode = serial_in(info, (((-8)) + 0));
                result = mode & (1 << 2);
        }

        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        return result;
}


static int disable_rsa(struct async_struct *info)
{
        unsigned char mode;
        int result;
        unsigned long flags;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        mode = serial_in(info, (((-8)) + 0));
        result = !(mode & (1 << 2));

        if (!result) {
                serial_out(info, (((-8)) + 0), mode & ~(1 << 2));
                mode = serial_in(info, (((-8)) + 0));
                result = !(mode & (1 << 2));
        }

        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        return result;
}


static int startup(struct async_struct * info)
{
        unsigned long flags;
        int retval=0;
        void (*handler)(int, void *, struct pt_regs *);
        struct serial_state *state= info->state;
        unsigned long page;

        unsigned short ICP;


        page = get_zeroed_page((0x20 | 0x10 | 0x40 | 0x80 | 0x100));
        if (!page)
                return -12;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();

        if (info->flags & 0x80000000) {
                free_pages((page),0);
                goto errout;
        }

        if (!((state)->port || ((state)->iomem_base)) || !state->type) {
                if (info->tty)
                        set_bit(1, &info->tty->flags);
                free_pages((page),0);
                goto errout;
        }
        if (info->xmit.buf)
                free_pages((page),0);
        else
                info->xmit.buf = (unsigned char *) page;





        if (uart_config[state->type].flags & 0x04) {

                serial_out(info, 3, 0xBF);
                serial_out(info, 2, 0x10);




                serial_out(info, 3, 0);
                serial_out(info, 1, 0);



                serial_out(info, 3, 0xBF);
                serial_out(info, 2, 0);



                if (state->type == 12) {
                        serial_out(info, 1, 0x30 | 0x00);

                        serial_out(info, 0, 0x60);
                        serial_out(info, 1, 0x30 | 0x80);

                        serial_out(info, 0, 0x60);
                }
                serial_out(info, 3, 0);
        }

        if (state->type == 8) {

                serial_out(info, 1, 0);
        }

        if (state->type == 10) {

                info->ACR = 0;
                serial_out(info, 3, 0xBF);
                serial_out(info, 2, 0x10);
                serial_out(info, 1, 0);
                serial_out(info, 3, 0);
                serial_icr_write(info, 0x0C, 0);
                serial_out(info, 3, 0xBF);
                serial_out(info, 2, 0x10);
                serial_out(info, 3, 0);
        }






        if (state->type == 13) {
                if (state->baud_base != (921600) &&
                    enable_rsa(info))
                        state->baud_base = (921600);
                if (state->baud_base == (921600))
                        serial_out(info, (((-8)) + 2), 0);
        }






        if (uart_config[state->type].flags & 0x01) {
                serial_out(info, 2, 0x01);
                serial_out(info, 2, (0x01 | 0x02 | 0x04));


                serial_out(info, 2, 0);
        }




        (void) serial_in(info, 5);
        (void) serial_in(info, 0);
        (void) serial_in(info, 2);
        (void) serial_in(info, 6);






        if (!(info->flags & 0x4000) &&
            (serial_in(info, 5) == 0xff)) {
                printk("ttyS%d: LSR safety check engaged!\n", state->line);
                if (capable(21)) {
                        if (info->tty)
                                set_bit(1, &info->tty->flags);
                } else
                        retval = -19;
                goto errout;
        }




        if (state->irq && (!IRQ_ports[state->irq] ||
                          !IRQ_ports[state->irq]->next_port)) {
                if (IRQ_ports[state->irq]) {

                        free_irq(state->irq, &IRQ_ports[state->irq]);





                                handler = rs_interrupt;




                } else
                        handler = rs_interrupt_single;

                retval = request_irq(state->irq, handler, 0x02000000,
                                     "serial", &IRQ_ports[state->irq]);
                if (retval) {
                        if (capable(21)) {
                                if (info->tty)
                                        set_bit(1,
                                                &info->tty->flags);
                                retval = 0;
                        }
                        goto errout;
                }
        }




        info->prev_port = 0;
        info->next_port = IRQ_ports[state->irq];
        if (info->next_port)
                info->next_port->prev_port = info;
        IRQ_ports[state->irq] = info;
        figure_IRQ_timeout(state->irq);




        serial_out(info, 3, 0x03);

        info->MCR = 0;
        if (info->tty->termios->c_cflag & 0010017)
                info->MCR = 0x01 | 0x02;

        if (info->flags & 0x0002) {
                if (state->irq == 0)
                        info->MCR |= 0x04;
        } else

        {
                if (state->irq != 0)
                        info->MCR |= 0x08;
        }
        info->MCR |= 0;
        serial_out(info, 4, info->MCR);




        info->IER = 0x08 | 0x04 | 0x01;
        serial_out(info, 1, info->IER);


        if (info->flags & 0x0002) {

                ICP = (info->port & 0xFE0) | 0x01F;
                do { *(volatile u8 *)(mips_io_port_base + (ICP)) = (0x80); ; } while(0);
                (void) inb_p(ICP);
        }





        (void)serial_in(info, 5);
        (void)serial_in(info, 0);
        (void)serial_in(info, 2);
        (void)serial_in(info, 6);

        if (info->tty)
                clear_bit(1, &info->tty->flags);
        info->xmit.head = info->xmit.tail = 0;




        mod_timer(&serial_timer, jiffies + 2*100/100);





        if (info->tty) {
                if ((info->flags & 0x1030) == 0x0010)
                        info->tty->alt_speed = 57600;
                if ((info->flags & 0x1030) == 0x0020)
                        info->tty->alt_speed = 115200;
                if ((info->flags & 0x1030) == 0x1000)
                        info->tty->alt_speed = 230400;
                if ((info->flags & 0x1030) == 0x1010)
                        info->tty->alt_speed = 460800;
        }





        change_speed(info, 0);

        info->flags |= 0x80000000;
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        return 0;

errout:
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        return retval;
}





static void shutdown(struct async_struct * info)
{
        unsigned long flags;
        struct serial_state *state;
        int retval;

        if (!(info->flags & 0x80000000))
                return;

        state = info->state;






        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();





        __wake_up((&info->delta_msr_wait),1, 1);




        if (info->next_port)
                info->next_port->prev_port = info->prev_port;
        if (info->prev_port)
                info->prev_port->next_port = info->next_port;
        else
                IRQ_ports[state->irq] = info->next_port;
        figure_IRQ_timeout(state->irq);




        if (state->irq && (!IRQ_ports[state->irq] ||
                          !IRQ_ports[state->irq]->next_port)) {
                if (IRQ_ports[state->irq]) {
                        free_irq(state->irq, &IRQ_ports[state->irq]);
                        retval = request_irq(state->irq, rs_interrupt_single,
                                             0x02000000, "serial",
                                             &IRQ_ports[state->irq]);

                        if (retval)
                                printk("serial shutdown: request_irq: error %d"
                                       "  Couldn't reacquire IRQ.\n", retval);
                } else
                        free_irq(state->irq, &IRQ_ports[state->irq]);
        }

        if (info->xmit.buf) {
                unsigned long pg = (unsigned long) info->xmit.buf;
                info->xmit.buf = 0;
                free_pages((pg),0);
        }

        info->IER = 0;
        serial_out(info, 1, 0x00);

        if (info->flags & 0x0002) {

                (void) inb((info->port & 0xFE0) | 0x01F);
                info->MCR |= 0x04;
        } else

                info->MCR &= ~0x08;
        info->MCR |= 0;


        serial_out(info, 3, serial_in(info, 3) & ~0x40);

        if (!info->tty || (info->tty->termios->c_cflag & 0002000))
                info->MCR &= ~(0x01|0x02);
        serial_out(info, 4, info->MCR);


        serial_out(info, 2, (0x01 | 0x02 | 0x04));


        serial_out(info, 2, 0);





        if ((state->type == 13) &&
            (state->baud_base == (921600) &&
             disable_rsa(info)))
                state->baud_base = ((921600) / 8);



        (void)serial_in(info, 0);

        if (info->tty)
                set_bit(1, &info->tty->flags);

        if (uart_config[info->state->type].flags & 0x04) {

                serial_out(info, 3, 0xBF);
                serial_out(info, 2, 0x10);
                serial_out(info, 3, 0);
                serial_out(info, 1, 0x10);
                serial_out(info, 3, 0xBF);
                serial_out(info, 2, 0);
                serial_out(info, 3, 0);
        }
        if (info->state->type == 8) {

                serial_out(info, 1, 0x10);
        }
        info->flags &= ~0x80000000;
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}
# 1638 "drivers/char/serial.c"
static void change_speed(struct async_struct *info,
                         struct termios *old_termios)
{
        int quot = 0, baud_base, baud;
        unsigned cflag, cval, fcr = 0;
        int bits;
        unsigned long flags;

        if (!info->tty || !info->tty->termios)
                return;
        cflag = info->tty->termios->c_cflag;
        if (!((info)->port || ((info)->iomem_base)))
                return;


        switch (cflag & 0000060) {
              case 0000000: cval = 0x00; bits = 7; break;
              case 0000020: cval = 0x01; bits = 8; break;
              case 0000040: cval = 0x02; bits = 9; break;
              case 0000060: cval = 0x03; bits = 10; break;

              default: cval = 0x00; bits = 7; break;
              }
        if (cflag & 0000100) {
                cval |= 0x04;
                bits++;
        }
        if (cflag & 0000400) {
                cval |= 0x08;
                bits++;
        }
        if (!(cflag & 0001000))
                cval |= 0x10;

        if (cflag & 010000000000)
                cval |= 0x20;



        baud = tty_get_baud_rate(info->tty);
        if (!baud)
                baud = 9600;

        if ((info->state->type == 13) &&
            (info->state->baud_base != (921600)) &&
            enable_rsa(info))
                info->state->baud_base = (921600);

        baud_base = info->state->baud_base;
        if (info->state->type == 10) {
                if (baud <= baud_base)
                        serial_icr_write(info, 0x02, 0);
                else if (baud <= 2*baud_base) {
                        serial_icr_write(info, 0x02, 0x8);
                        baud_base = baud_base * 2;
                } else if (baud <= 4*baud_base) {
                        serial_icr_write(info, 0x02, 0x4);
                        baud_base = baud_base * 4;
                } else
                        serial_icr_write(info, 0x02, 0);
        }
        if (baud == 38400 &&
            ((info->flags & 0x1030) == 0x0030))
                quot = info->state->custom_divisor;
        else {
                if (baud == 134)

                        quot = (2*baud_base / 269);
                else if (baud)
                        quot = baud_base / baud;
        }

        if (!quot && old_termios) {
                info->tty->termios->c_cflag &= ~0010017;
                info->tty->termios->c_cflag |= (old_termios->c_cflag & 0010017);
                baud = tty_get_baud_rate(info->tty);
                if (!baud)
                        baud = 9600;
                if (baud == 38400 &&
                    ((info->flags & 0x1030) == 0x0030))
                        quot = info->state->custom_divisor;
                else {
                        if (baud == 134)

                                quot = (2*baud_base / 269);
                        else if (baud)
                                quot = baud_base / baud;
                }
        }

        if (!quot)
                quot = baud_base / 9600;





        if (((quot & 0xFF) == 0) && (info->state->type == 10) &&
            (info->state->revision == 0x5201))
                quot++;

        info->quot = quot;
        info->timeout = ((info->xmit_fifo_size*100*bits*quot) / baud_base);
        info->timeout += 100/50;


        if (uart_config[info->state->type].flags & 0x02) {
                if ((info->state->baud_base / quot) < 2400)
                        fcr = 0x01 | 0x00;

                else if (info->state->type == 13)
                        fcr = 0x01 | 0xC0;

                else
                        fcr = 0x01 | 0x80;
        }
        if (info->state->type == 8)
                fcr |= 0x20;


        info->IER &= ~0x08;
        if (info->flags & 0x0800)
                info->IER |= 0x08;
        if (cflag & 020000000000) {
                info->flags |= 0x04000000;
                info->IER |= 0x08;
        } else
                info->flags &= ~0x04000000;
        if (cflag & 0004000)
                info->flags &= ~0x02000000;
        else {
                info->flags |= 0x02000000;
                info->IER |= 0x08;
        }
        serial_out(info, 1, info->IER);




#define RELEVANT_IFLAG(iflag) (iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))

        info->read_status_mask = 0x02 | 0x20 | 0x01;
        if ((((info->tty))->termios->c_iflag & (0000020)))
                info->read_status_mask |= 0x08 | 0x04;
        if ((((info->tty))->termios->c_iflag & (0000002)) || (((info->tty))->termios->c_iflag & (0000010)))
                info->read_status_mask |= 0x10;




        info->ignore_status_mask = 0;
        if ((((info->tty))->termios->c_iflag & (0000004)))
                info->ignore_status_mask |= 0x04 | 0x08;
        if ((((info->tty))->termios->c_iflag & (0000001))) {
                info->ignore_status_mask |= 0x10;




                if ((((info->tty))->termios->c_iflag & (0000004)))
                        info->ignore_status_mask |= 0x02;
        }



        if ((cflag & 0000200) == 0)
                info->ignore_status_mask |= 0x01;
        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        if (uart_config[info->state->type].flags & 0x04) {
                serial_out(info, 3, 0xBF);
                serial_out(info, 2, (cflag & 020000000000) ? 0x80 : 0);

        }
        serial_out(info, 3, cval | 0x80);
        serial_out(info, 0, quot & 0xff);
        serial_out(info, 1, quot >> 8);
        if (info->state->type == 8)
                serial_out(info, 2, fcr);
        serial_out(info, 3, cval);
        info->LCR = cval;
        if (info->state->type != 8) {
                if (fcr & 0x01) {

                        serial_out(info, 2, 0x01);
                }
                serial_out(info, 2, fcr);
        }
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}

static void rs_put_char(struct tty_struct *tty, unsigned char ch)
{
        struct async_struct *info;
        unsigned long flags;

        if (!tty)
                return;

        info = (struct async_struct *)tty->driver_data;

        if (serial_paranoia_check(info, tty->device, "rs_put_char"))
                return;

        if (!info->xmit.buf)
                return;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        if (((((info->xmit.tail)) - (((info->xmit.head)+1))) & ((((1L << 14)))-1)) == 0) {


                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                return;
        }

        info->xmit.buf[info->xmit.head] = ch;
        info->xmit.head = (info->xmit.head + 1) & ((1L << 14)-1);
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}

static void rs_flush_chars(struct tty_struct *tty)
{
        struct async_struct *info = (struct async_struct *)tty->driver_data;
        unsigned long flags;

        if (serial_paranoia_check(info, tty->device, "rs_flush_chars"))
                return;

        if (info->xmit.head == info->xmit.tail
            || tty->stopped
            || tty->hw_stopped
            || !info->xmit.buf)
                return;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        info->IER |= 0x02;
        serial_out(info, 1, info->IER);
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}

static int rs_write(struct tty_struct * tty, int from_user,
                    const unsigned char *buf, int count)
{
        int c, ret = 0;
        struct async_struct *info;
        unsigned long flags;

        if (!tty)
                return 0;

        info = (struct async_struct *)tty->driver_data;

        if (serial_paranoia_check(info, tty->device, "rs_write"))
                return 0;

        if (!info->xmit.buf || !tmp_buf)
                return 0;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags));
        if (from_user) {
                down(&tmp_buf_sem);
                while (1) {
                        int c1;
                        c = ({int end = ((1L << 14)) - 1 - (info->xmit.head); int n = (end + (info->xmit.tail)) & (((1L << 14))-1); n <= end ? n : end+1;});


                        if (count < c)
                                c = count;
                        if (c <= 0)
                                break;

                        c -= ({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = (tmp_buf); __cu_from = (buf); __cu_len = (c); if (__builtin_expect(((((signed long)(((current->thread.current_ds).seg) & (((unsigned long)(__cu_from)) | (((unsigned long)(__cu_from)) + ((__cu_len))) | ((__builtin_constant_p((__cu_len)) && (signed long) ((__cu_len)) > 0) ? 0 : ((__cu_len)))))) == 0)),1)) __cu_len = ({ register void *__cu_to_r __asm__ ("$4"); register const void *__cu_from_r __asm__ ("$5"); register long __cu_len_r __asm__ ("$6"); __cu_to_r = (__cu_to); __cu_from_r = (__cu_from); __cu_len_r = (__cu_len); __asm__ __volatile__( ".set\tnoreorder\n\t" "jal\t" "__copy_user" "\n\t" ".set\tnoat\n\t" "addu" "\t$1, %1, %2\n\t" ".set\tat\n\t" ".set\treorder" : "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r) : : "$8", "$9", "$10", "$11", "$12", "$15", "$24", "$31", "memory"); __cu_len_r; }); __cu_len; });
                        if (!c) {
                                if (!ret)
                                        ret = -14;
                                break;
                        }
                        __cli();
                        c1 = ({int end = ((1L << 14)) - 1 - (info->xmit.head); int n = (end + (info->xmit.tail)) & (((1L << 14))-1); n <= end ? n : end+1;});


                        if (c1 < c)
                                c = c1;
                        memcpy(info->xmit.buf + info->xmit.head, tmp_buf, c);
                        info->xmit.head = ((info->xmit.head + c) &
                                           ((1L << 14)-1));
                        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                        buf += c;
                        count -= c;
                        ret += c;
                }
                up(&tmp_buf_sem);
        } else {
                __cli();
                while (1) {
                        c = ({int end = ((1L << 14)) - 1 - (info->xmit.head); int n = (end + (info->xmit.tail)) & (((1L << 14))-1); n <= end ? n : end+1;});


                        if (count < c)
                                c = count;
                        if (c <= 0) {
                                break;
                        }
                        memcpy(info->xmit.buf + info->xmit.head, buf, c);
                        info->xmit.head = ((info->xmit.head + c) &
                                           ((1L << 14)-1));
                        buf += c;
                        count -= c;
                        ret += c;
                }
                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        }
        if (info->xmit.head != info->xmit.tail
            && !tty->stopped
            && !tty->hw_stopped
            && !(info->IER & 0x02)) {
                info->IER |= 0x02;
                serial_out(info, 1, info->IER);
        }
        return ret;
}

static int rs_write_room(struct tty_struct *tty)
{
        struct async_struct *info = (struct async_struct *)tty->driver_data;

        if (serial_paranoia_check(info, tty->device, "rs_write_room"))
                return 0;
        return ((((info->xmit.tail)) - (((info->xmit.head)+1))) & ((((1L << 14)))-1));
}

static int rs_chars_in_buffer(struct tty_struct *tty)
{
        struct async_struct *info = (struct async_struct *)tty->driver_data;

        if (serial_paranoia_check(info, tty->device, "rs_chars_in_buffer"))
                return 0;
        return (((info->xmit.head) - (info->xmit.tail)) & (((1L << 14))-1));
}

static void rs_flush_buffer(struct tty_struct *tty)
{
        struct async_struct *info = (struct async_struct *)tty->driver_data;
        unsigned long flags;

        if (serial_paranoia_check(info, tty->device, "rs_flush_buffer"))
                return;
        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        info->xmit.head = info->xmit.tail = 0;
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);



        tty_wakeup(tty);
}





static void rs_send_xchar(struct tty_struct *tty, char ch)
{
        struct async_struct *info = (struct async_struct *)tty->driver_data;

        if (serial_paranoia_check(info, tty->device, "rs_send_char"))
                return;

        info->x_char = ch;
        if (ch) {

                info->IER |= 0x02;
                serial_out(info, 1, info->IER);
        }
}
# 2020 "drivers/char/serial.c"
static void rs_throttle(struct tty_struct * tty)
{
        struct async_struct *info = (struct async_struct *)tty->driver_data;
        unsigned long flags;







        if (serial_paranoia_check(info, tty->device, "rs_throttle"))
                return;

        if ((((tty))->termios->c_iflag & (0010000)))
                rs_send_xchar(tty, ((tty)->termios->c_cc[9]));

        if (tty->termios->c_cflag & 020000000000)
                info->MCR &= ~0x02;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        serial_out(info, 4, info->MCR);
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}

static void rs_unthrottle(struct tty_struct * tty)
{
        struct async_struct *info = (struct async_struct *)tty->driver_data;
        unsigned long flags;







        if (serial_paranoia_check(info, tty->device, "rs_unthrottle"))
                return;

        if ((((tty))->termios->c_iflag & (0010000))) {
                if (info->x_char)
                        info->x_char = 0;
                else
                        rs_send_xchar(tty, ((tty)->termios->c_cc[8]));
        }
        if (tty->termios->c_cflag & 020000000000)
                info->MCR |= 0x02;
        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        serial_out(info, 4, info->MCR);
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}







static int get_serial_info(struct async_struct * info,
                           struct serial_struct * retinfo)
{
        struct serial_struct tmp;
        struct serial_state *state = info->state;

        if (!retinfo)
                return -14;
        memset(&tmp, 0, sizeof(tmp));
        tmp.type = state->type;
        tmp.line = state->line;
        tmp.port = state->port;
        if (((sizeof(long)-sizeof(int))*8))
                tmp.port_high = state->port >> ((sizeof(long)-sizeof(int))*8);
        else
                tmp.port_high = 0;
        tmp.irq = state->irq;
        tmp.flags = state->flags;
        tmp.xmit_fifo_size = state->xmit_fifo_size;
        tmp.baud_base = state->baud_base;
        tmp.close_delay = state->close_delay;
        tmp.closing_wait = state->closing_wait;
        tmp.custom_divisor = state->custom_divisor;
        tmp.hub6 = state->hub6;
        tmp.io_type = state->io_type;
        if (({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = (retinfo); __cu_from = (&tmp); __cu_len = (sizeof(*retinfo)); if (__builtin_expect(((((signed long)(((current->thread.current_ds).seg) & (((unsigned long)(__cu_to)) | (((unsigned long)(__cu_to)) + ((__cu_len))) | ((__builtin_constant_p((__cu_len)) && (signed long) ((__cu_len)) > 0) ? 0 : ((__cu_len)))))) == 0)),1)) __cu_len = ({ register void *__cu_to_r __asm__ ("$4"); register const void *__cu_from_r __asm__ ("$5"); register long __cu_len_r __asm__ ("$6"); __cu_to_r = (__cu_to); __cu_from_r = (__cu_from); __cu_len_r = (__cu_len); __asm__ __volatile__( "jal\t" "__copy_user" "\n\t" : "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r) : : "$8", "$9", "$10", "$11", "$12", "$15", "$24", "$31", "memory"); __cu_len_r; }); __cu_len; }))
                return -14;
        return 0;
}

static int set_serial_info(struct async_struct * info,
                           struct serial_struct * new_info)
{
        struct serial_struct new_serial;
        struct serial_state old_state, *state;
        unsigned int i,change_irq,change_port;
        int retval = 0;
        unsigned long new_port;

        if (({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = (&new_serial); __cu_from = (new_info); __cu_len = (sizeof(new_serial)); if (__builtin_expect(((((signed long)(((current->thread.current_ds).seg) & (((unsigned long)(__cu_from)) | (((unsigned long)(__cu_from)) + ((__cu_len))) | ((__builtin_constant_p((__cu_len)) && (signed long) ((__cu_len)) > 0) ? 0 : ((__cu_len)))))) == 0)),1)) __cu_len = ({ register void *__cu_to_r __asm__ ("$4"); register const void *__cu_from_r __asm__ ("$5"); register long __cu_len_r __asm__ ("$6"); __cu_to_r = (__cu_to); __cu_from_r = (__cu_from); __cu_len_r = (__cu_len); __asm__ __volatile__( ".set\tnoreorder\n\t" "jal\t" "__copy_user" "\n\t" ".set\tnoat\n\t" "addu" "\t$1, %1, %2\n\t" ".set\tat\n\t" ".set\treorder" : "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r) : : "$8", "$9", "$10", "$11", "$12", "$15", "$24", "$31", "memory"); __cu_len_r; }); __cu_len; }))
                return -14;
        state = info->state;
        old_state = *state;

        new_port = new_serial.port;
        if (((sizeof(long)-sizeof(int))*8))
                new_port += (unsigned long) new_serial.port_high << ((sizeof(long)-sizeof(int))*8);

        change_irq = new_serial.irq != state->irq;
        change_port = (new_port != ((int) state->port)) ||
                (new_serial.hub6 != state->hub6);

        if (!capable(21)) {
                if (change_irq || change_port ||
                    (new_serial.baud_base != state->baud_base) ||
                    (new_serial.type != state->type) ||
                    (new_serial.close_delay != state->close_delay) ||
                    (new_serial.xmit_fifo_size != state->xmit_fifo_size) ||
                    ((new_serial.flags & ~0x3430) !=
                     (state->flags & ~0x3430)))
                        return -1;
                state->flags = ((state->flags & ~0x3430) |
                               (new_serial.flags & 0x3430));
                info->flags = ((info->flags & ~0x3430) |
                               (new_serial.flags & 0x3430));
                state->custom_divisor = new_serial.custom_divisor;
                goto check_and_exit;
        }

        new_serial.irq = (new_serial.irq);

        if ((new_serial.irq >= 128) || (new_serial.irq < 0) ||
            (new_serial.baud_base < 9600)|| (new_serial.type < 0) ||
            (new_serial.type > 13) || (new_serial.type == 5) ||
            (new_serial.type == 9)) {
                return -22;
        }

        if ((new_serial.type != state->type) ||
            (new_serial.xmit_fifo_size <= 0))
                new_serial.xmit_fifo_size =
                        uart_config[new_serial.type].dfl_xmit_fifo_size;


        if (new_serial.type) {
                for (i = 0 ; i < (sizeof(rs_table)/sizeof(struct serial_state)); i++)
                        if ((state != &rs_table[i]) &&
                            (rs_table[i].io_type == 0) &&
                            (rs_table[i].port == new_port) &&
                            rs_table[i].type)
                                return -125;
        }

        if ((change_port || change_irq) && (state->count > 1))
                return -16;






        state->baud_base = new_serial.baud_base;
        state->flags = ((state->flags & ~0x7FFF) |
                        (new_serial.flags & 0x7FFF));
        info->flags = ((state->flags & ~0xFFC00000) |
                       (info->flags & 0xFFC00000));
        state->custom_divisor = new_serial.custom_divisor;
        state->close_delay = new_serial.close_delay * 100/100;
        state->closing_wait = new_serial.closing_wait * 100/100;

        info->tty->low_latency = (info->flags & 0x2000) ? 1 : 0;

        info->xmit_fifo_size = state->xmit_fifo_size =
                new_serial.xmit_fifo_size;

        if ((state->type != 0) && state->port) {

                if (old_state.type == 13)
                        __release_region(&ioport_resource, (state->port + (-8)), (16));
                else

                __release_region(&ioport_resource, (state->port), (8));
        }
        state->type = new_serial.type;
        if (change_port || change_irq) {




                shutdown(info);
                state->irq = new_serial.irq;
                info->port = state->port = new_port;
                info->hub6 = state->hub6 = new_serial.hub6;
                if (info->hub6)
                        info->io_type = state->io_type = 1;
                else if (info->io_type == 1)
                        info->io_type = state->io_type = 0;
        }
        if ((state->type != 0) && state->port) {

                if (state->type == 13)
                        __request_region(&ioport_resource, (state->port + (-8)), (16), ("serial_rsa(set)"));

                else

                        __request_region(&ioport_resource, (state->port), (8), ("serial(set)"));
        }


check_and_exit:
        if ((!state->port && !state->iomem_base) || !state->type)
                return 0;
        if (info->flags & 0x80000000) {
                if (((old_state.flags & 0x1030) !=
                     (state->flags & 0x1030)) ||
                    (old_state.custom_divisor != state->custom_divisor)) {

                        if ((state->flags & 0x1030) == 0x0010)
                                info->tty->alt_speed = 57600;
                        if ((state->flags & 0x1030) == 0x0020)
                                info->tty->alt_speed = 115200;
                        if ((state->flags & 0x1030) == 0x1000)
                                info->tty->alt_speed = 230400;
                        if ((state->flags & 0x1030) == 0x1010)
                                info->tty->alt_speed = 460800;

                        change_speed(info, 0);
                }
        } else
                retval = startup(info);
        return retval;
}
# 2262 "drivers/char/serial.c"
static int get_lsr_info(struct async_struct * info, unsigned int *value)
{
        unsigned char status;
        unsigned int result;
        unsigned long flags;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        status = serial_in(info, 5);
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        result = ((status & 0x40) ? 0x01 : 0);







        if (info->x_char ||
            (((((info->xmit.head) - (info->xmit.tail)) & (((1L << 14))-1)) > 0) &&

             !info->tty->stopped && !info->tty->hw_stopped))
                result &= ~0x01;

        if (({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = (value); __cu_from = (&result); __cu_len = (sizeof(int)); if (__builtin_expect(((((signed long)(((current->thread.current_ds).seg) & (((unsigned long)(__cu_to)) | (((unsigned long)(__cu_to)) + ((__cu_len))) | ((__builtin_constant_p((__cu_len)) && (signed long) ((__cu_len)) > 0) ? 0 : ((__cu_len)))))) == 0)),1)) __cu_len = ({ register void *__cu_to_r __asm__ ("$4"); register const void *__cu_from_r __asm__ ("$5"); register long __cu_len_r __asm__ ("$6"); __cu_to_r = (__cu_to); __cu_from_r = (__cu_from); __cu_len_r = (__cu_len); __asm__ __volatile__( "jal\t" "__copy_user" "\n\t" : "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r) : : "$8", "$9", "$10", "$11", "$12", "$15", "$24", "$31", "memory"); __cu_len_r; }); __cu_len; }))
                return -14;
        return 0;
}


static int get_modem_info(struct async_struct * info, unsigned int *value)
{
        unsigned char control, status;
        unsigned int result;
        unsigned long flags;

        control = info->MCR;
        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        status = serial_in(info, 6);
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        result = ((control & 0x02) ? 0x004 : 0)
                | ((control & 0x01) ? 0x002 : 0)

                | ((control & 0x04) ? 0x2000 : 0)
                | ((control & 0x08) ? 0x4000 : 0)

                | ((status & 0x80) ? 0x100 : 0)
                | ((status & 0x40) ? 0x200 : 0)
                | ((status & 0x20) ? 0x400 : 0)
                | ((status & 0x10) ? 0x040 : 0);

        if (({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = (value); __cu_from = (&result); __cu_len = (sizeof(int)); if (__builtin_expect(((((signed long)(((current->thread.current_ds).seg) & (((unsigned long)(__cu_to)) | (((unsigned long)(__cu_to)) + ((__cu_len))) | ((__builtin_constant_p((__cu_len)) && (signed long) ((__cu_len)) > 0) ? 0 : ((__cu_len)))))) == 0)),1)) __cu_len = ({ register void *__cu_to_r __asm__ ("$4"); register const void *__cu_from_r __asm__ ("$5"); register long __cu_len_r __asm__ ("$6"); __cu_to_r = (__cu_to); __cu_from_r = (__cu_from); __cu_len_r = (__cu_len); __asm__ __volatile__( "jal\t" "__copy_user" "\n\t" : "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r) : : "$8", "$9", "$10", "$11", "$12", "$15", "$24", "$31", "memory"); __cu_len_r; }); __cu_len; }))
                return -14;
        return 0;
}

static int set_modem_info(struct async_struct * info, unsigned int cmd,
                          unsigned int *value)
{
        unsigned int arg;
        unsigned long flags;

        if (({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = (&arg); __cu_from = (value); __cu_len = (sizeof(int)); if (__builtin_expect(((((signed long)(((current->thread.current_ds).seg) & (((unsigned long)(__cu_from)) | (((unsigned long)(__cu_from)) + ((__cu_len))) | ((__builtin_constant_p((__cu_len)) && (signed long) ((__cu_len)) > 0) ? 0 : ((__cu_len)))))) == 0)),1)) __cu_len = ({ register void *__cu_to_r __asm__ ("$4"); register const void *__cu_from_r __asm__ ("$5"); register long __cu_len_r __asm__ ("$6"); __cu_to_r = (__cu_to); __cu_from_r = (__cu_from); __cu_len_r = (__cu_len); __asm__ __volatile__( ".set\tnoreorder\n\t" "jal\t" "__copy_user" "\n\t" ".set\tnoat\n\t" "addu" "\t$1, %1, %2\n\t" ".set\tat\n\t" ".set\treorder" : "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r) : : "$8", "$9", "$10", "$11", "$12", "$15", "$24", "$31", "memory"); __cu_len_r; }); __cu_len; }))
                return -14;

        switch (cmd) {
        case 0x741b:
                if (arg & 0x004)
                        info->MCR |= 0x02;
                if (arg & 0x002)
                        info->MCR |= 0x01;

                if (arg & 0x2000)
                        info->MCR |= 0x04;
                if (arg & 0x4000)
                        info->MCR |= 0x08;

                if (arg & 0x8000)
                        info->MCR |= 0x10;
                break;
        case 0x741c:
                if (arg & 0x004)
                        info->MCR &= ~0x02;
                if (arg & 0x002)
                        info->MCR &= ~0x01;

                if (arg & 0x2000)
                        info->MCR &= ~0x04;
                if (arg & 0x4000)
                        info->MCR &= ~0x08;

                if (arg & 0x8000)
                        info->MCR &= ~0x10;
                break;
        case 0x741a:
                info->MCR = ((info->MCR & ~(0x02 |

                                            0x04 |
                                            0x08 |

                                            0x10 |
                                            0x01))
                             | ((arg & 0x004) ? 0x02 : 0)

                             | ((arg & 0x2000) ? 0x04 : 0)
                             | ((arg & 0x4000) ? 0x08 : 0)

                             | ((arg & 0x8000) ? 0x10 : 0)
                             | ((arg & 0x002) ? 0x01 : 0));
                break;
        default:
                return -22;
        }
        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        info->MCR |= 0;
        serial_out(info, 4, info->MCR);
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        return 0;
}

static int do_autoconfig(struct async_struct * info)
{
        int irq, retval;

        if (!capable(21))
                return -1;

        if (info->state->count > 1)
                return -16;

        shutdown(info);

        autoconfig(info->state);
        if ((info->state->flags & 0x0080) &&
            (info->state->port != 0 || info->state->iomem_base != 0) &&
            (info->state->type != 0)) {
                irq = detect_uart_irq(info->state);
                if (irq > 0)
                        info->state->irq = irq;
        }

        retval = startup(info);
        if (retval)
                return retval;
        return 0;
}
# 2427 "drivers/char/serial.c"
static void rs_break(struct tty_struct *tty, int break_state)
{
        struct async_struct * info = (struct async_struct *)tty->driver_data;
        unsigned long flags;

        if (serial_paranoia_check(info, tty->device, "rs_break"))
                return;

        if (!((info)->port || ((info)->iomem_base)))
                return;
        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        if (break_state == -1)
                info->LCR |= 0x40;
        else
                info->LCR &= ~0x40;
        serial_out(info, 3, info->LCR);
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}
# 2561 "drivers/char/serial.c"
static int rs_ioctl(struct tty_struct *tty, struct file * file,
                    unsigned int cmd, unsigned long arg)
{
        struct async_struct * info = (struct async_struct *)tty->driver_data;
        struct async_icount cprev, cnow;
        struct serial_icounter_struct icount;
        unsigned long flags;




        if (serial_paranoia_check(info, tty->device, "rs_ioctl"))
                return -19;

        if ((cmd != 0x5484) && (cmd != 0x5485) &&
            (cmd != 0x5488) && (cmd != 0x548d) &&
            (cmd != 0x5491) && (cmd != 0x5492)) {
                if (tty->flags & (1 << 1))
                    return -5;
        }

        switch (cmd) {
# 2622 "drivers/char/serial.c"
                case 0x741d:
                        return get_modem_info(info, (unsigned int *) arg);
                case 0x741b:
                case 0x741c:
                case 0x741a:
                        return set_modem_info(info, cmd, (unsigned int *) arg);
                case 0x5484:
                        return get_serial_info(info,
                                               (struct serial_struct *) arg);
                case 0x5485:
                        return set_serial_info(info,
                                               (struct serial_struct *) arg);
                case 0x5488:
                        return do_autoconfig(info);

                case 0x548e:
                        return get_lsr_info(info, (unsigned int *) arg);

                case 0x548d:
                        if (({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = ((struct async_struct *) arg); __cu_from = (info); __cu_len = (sizeof(struct async_struct)); if (__builtin_expect(((((signed long)(((current->thread.current_ds).seg) & (((unsigned long)(__cu_to)) | (((unsigned long)(__cu_to)) + ((__cu_len))) | ((__builtin_constant_p((__cu_len)) && (signed long) ((__cu_len)) > 0) ? 0 : ((__cu_len)))))) == 0)),1)) __cu_len = ({ register void *__cu_to_r __asm__ ("$4"); register const void *__cu_from_r __asm__ ("$5"); register long __cu_len_r __asm__ ("$6"); __cu_to_r = (__cu_to); __cu_from_r = (__cu_from); __cu_len_r = (__cu_len); __asm__ __volatile__( "jal\t" "__copy_user" "\n\t" : "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r) : : "$8", "$9", "$10", "$11", "$12", "$15", "$24", "$31", "memory"); __cu_len_r; }); __cu_len; }))

                                return -14;
                        return 0;
# 2661 "drivers/char/serial.c"
                case 0x5491:
                        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();

                        cprev = info->state->icount;
                        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);

                        info->IER |= 0x08;
                        serial_out(info, 1, info->IER);
                        while (1) {
                                interruptible_sleep_on(&info->delta_msr_wait);

                                if (signal_pending(current))
                                        return -512;
                                __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
                                cnow = info->state->icount;
                                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                                if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&
                                    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts)
                                        return -5;
                                if ( ((arg & 0x200) && (cnow.rng != cprev.rng)) ||
                                     ((arg & 0x400) && (cnow.dsr != cprev.dsr)) ||
                                     ((arg & 0x100) && (cnow.dcd != cprev.dcd)) ||
                                     ((arg & 0x040) && (cnow.cts != cprev.cts)) ) {
                                        return 0;
                                }
                                cprev = cnow;
                        }
# 2696 "drivers/char/serial.c"
                case 0x5492:
                        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
                        cnow = info->state->icount;
                        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                        icount.cts = cnow.cts;
                        icount.dsr = cnow.dsr;
                        icount.rng = cnow.rng;
                        icount.dcd = cnow.dcd;
                        icount.rx = cnow.rx;
                        icount.tx = cnow.tx;
                        icount.frame = cnow.frame;
                        icount.overrun = cnow.overrun;
                        icount.parity = cnow.parity;
                        icount.brk = cnow.brk;
                        icount.buf_overrun = cnow.buf_overrun;

                        if (({ void *__cu_to; const void *__cu_from; long __cu_len; __cu_to = ((void *)arg); __cu_from = (&icount); __cu_len = (sizeof(icount)); if (__builtin_expect(((((signed long)(((current->thread.current_ds).seg) & (((unsigned long)(__cu_to)) | (((unsigned long)(__cu_to)) + ((__cu_len))) | ((__builtin_constant_p((__cu_len)) && (signed long) ((__cu_len)) > 0) ? 0 : ((__cu_len)))))) == 0)),1)) __cu_len = ({ register void *__cu_to_r __asm__ ("$4"); register const void *__cu_from_r __asm__ ("$5"); register long __cu_len_r __asm__ ("$6"); __cu_to_r = (__cu_to); __cu_from_r = (__cu_from); __cu_len_r = (__cu_len); __asm__ __volatile__( "jal\t" "__copy_user" "\n\t" : "+r" (__cu_to_r), "+r" (__cu_from_r), "+r" (__cu_len_r) : : "$8", "$9", "$10", "$11", "$12", "$15", "$24", "$31", "memory"); __cu_len_r; }); __cu_len; }))
                                return -14;
                        return 0;
                case 0x5489:
                case 0x548a:

                        printk ("TIOCSER?WILD ioctl obsolete, ignored.\n");
                        return 0;

                default:
                        return -515;
                }
        return 0;
}

static void rs_set_termios(struct tty_struct *tty, struct termios *old_termios)
{
        struct async_struct *info = (struct async_struct *)tty->driver_data;
        unsigned long flags;
        unsigned int cflag = tty->termios->c_cflag;

        if ( (cflag == old_termios->c_cflag)
            && ( (tty->termios->c_iflag & (0000001|0000002|0000004|0000010|0000020))
                == (old_termios->c_iflag & (0000001|0000002|0000004|0000010|0000020))))
          return;

        change_speed(info, old_termios);


        if ((old_termios->c_cflag & 0010017) &&
            !(cflag & 0010017)) {
                info->MCR &= ~(0x01|0x02);
                __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
                serial_out(info, 4, info->MCR);
                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        }


        if (!(old_termios->c_cflag & 0010017) &&
            (cflag & 0010017)) {
                info->MCR |= 0x01;
                if (!(tty->termios->c_cflag & 020000000000) ||
                    !test_bit(0, &tty->flags)) {
                        info->MCR |= 0x02;
                }
                __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
                serial_out(info, 4, info->MCR);
                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        }


        if ((old_termios->c_cflag & 020000000000) &&
            !(tty->termios->c_cflag & 020000000000)) {
                tty->hw_stopped = 0;
                rs_start(tty);
        }
# 2780 "drivers/char/serial.c"
}
# 2792 "drivers/char/serial.c"
static void rs_close(struct tty_struct *tty, struct file * filp)
{
        struct async_struct * info = (struct async_struct *)tty->driver_data;
        struct serial_state *state;
        unsigned long flags;

        if (!info || serial_paranoia_check(info, tty->device, "rs_close"))
                return;

        state = info->state;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();

        if (tty_hung_up_p(filp)) {
                ;
                do { } while (0);
                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                return;
        }




        if ((tty->count == 1) && (state->count != 1)) {







                printk("rs_close: bad serial port count; tty->count is 1, "
                       "state->count is %d\n", state->count);
                state->count = 1;
        }
        if (--state->count < 0) {
                printk("rs_close: bad serial port count for ttys%d: %d\n",
                       info->line, state->count);
                state->count = 0;
        }
        if (state->count) {
                ;
                do { } while (0);
                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                return;
        }
        info->flags |= 0x08000000;
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);




        if (info->flags & 0x20000000)
                info->state->normal_termios = *tty->termios;
        if (info->flags & 0x40000000)
                info->state->callout_termios = *tty->termios;




        tty->closing = 1;
        if (state->closing_wait != 65535)
                tty_wait_until_sent(tty, state->closing_wait);






        info->IER &= ~0x04;
        info->read_status_mask &= ~0x01;
        if (info->flags & 0x80000000) {
                serial_out(info, 1, info->IER);





                rs_wait_until_sent(tty, info->timeout);
        }
        shutdown(info);
        if (tty->driver.flush_buffer)
                tty->driver.flush_buffer(tty);
        tty_ldisc_flush(tty);
        tty->closing = 0;
        info->event = 0;
        info->tty = 0;
        if (info->blocked_open) {
                if (state->close_delay) {
                        do { current->state = (1); __asm__ __volatile__( ".set	push\n\t" ".set	noreorder\n\t" ".set	mips2\n\t" "sync\n\t" ".set	pop" : : : "memory"); } while (0);
                        schedule_timeout(state->close_delay);
                }
                __wake_up((&info->open_wait),1, 1);
        }
        info->flags &= ~(0x20000000|0x40000000|
                         0x08000000);
        __wake_up((&info->close_wait),1, 1);
        do { } while (0);
}




static void rs_wait_until_sent(struct tty_struct *tty, int timeout)
{
        struct async_struct * info = (struct async_struct *)tty->driver_data;
        unsigned long orig_jiffies, char_time;
        int lsr;

        if (serial_paranoia_check(info, tty->device, "rs_wait_until_sent"))
                return;

        if (info->state->type == 0)
                return;

        if (info->xmit_fifo_size == 0)
                return;

        orig_jiffies = jiffies;
# 2919 "drivers/char/serial.c"
        char_time = (info->timeout - 100/50) / info->xmit_fifo_size;
        char_time = char_time / 5;
        if (char_time == 0)
                char_time = 1;
        if (timeout && timeout < char_time)
                char_time = timeout;
# 2934 "drivers/char/serial.c"
        if (!timeout || timeout > 2*info->timeout)
                timeout = 2*info->timeout;




        while (!((lsr = serial_in(info, 5)) & 0x40)) {



                do { current->state = (1); __asm__ __volatile__( ".set	push\n\t" ".set	noreorder\n\t" ".set	mips2\n\t" "sync\n\t" ".set	pop" : : : "memory"); } while (0);
                schedule_timeout(char_time);
                if (signal_pending(current))
                        break;
                if (timeout && ((long)(orig_jiffies + timeout) - (long)(jiffies) < 0))
                        break;
        }



}




static void rs_hangup(struct tty_struct *tty)
{
        struct async_struct * info = (struct async_struct *)tty->driver_data;
        struct serial_state *state = info->state;

        if (serial_paranoia_check(info, tty->device, "rs_hangup"))
                return;

        state = info->state;

        rs_flush_buffer(tty);
        if (info->flags & 0x08000000)
                return;
        shutdown(info);
        info->event = 0;
        state->count = 0;
        info->flags &= ~(0x20000000|0x40000000);
        info->tty = 0;
        __wake_up((&info->open_wait),1, 1);
}






static int block_til_ready(struct tty_struct *tty, struct file * filp,
                           struct async_struct *info)
{
        wait_queue_t wait = { task: current, task_list: { ((void *)0), ((void *)0) }, };
        struct serial_state *state = info->state;
        int retval;
        int do_clocal = 0, extra_count = 0;
        unsigned long flags;





        if (tty_hung_up_p(filp) ||
            (info->flags & 0x08000000)) {
                if (info->flags & 0x08000000)
                        interruptible_sleep_on(&info->close_wait);

                return ((info->flags & 0x0001) ?
                        -11 : -512);



        }





        if (tty->driver.subtype == 2) {
                if (info->flags & 0x20000000)
                        return -16;
                if ((info->flags & 0x40000000) &&
                    (info->flags & 0x0100) &&
                    (info->session != current->session))
                    return -16;
                if ((info->flags & 0x40000000) &&
                    (info->flags & 0x0200) &&
                    (info->pgrp != current->pgrp))
                    return -16;
                info->flags |= 0x40000000;
                return 0;
        }





        if ((filp->f_flags & 0x0080) ||
            (tty->flags & (1 << 1))) {
                if (info->flags & 0x40000000)
                        return -16;
                info->flags |= 0x20000000;
                return 0;
        }

        if (info->flags & 0x40000000) {
                if (state->normal_termios.c_cflag & 0004000)
                        do_clocal = 1;
        } else {
                if (tty->termios->c_cflag & 0004000)
                        do_clocal = 1;
        }
# 3056 "drivers/char/serial.c"
        retval = 0;
        add_wait_queue(&info->open_wait, &wait);




        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        if (!tty_hung_up_p(filp)) {
                extra_count = 1;
                state->count--;
        }
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        info->blocked_open++;
        while (1) {
                __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
                if (!(info->flags & 0x40000000) &&
                    (tty->termios->c_cflag & 0010017))
                        serial_out(info, 4,
                                   serial_in(info, 4) |
                                   (0x01 | 0x02));
                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                do { current->state = (1); __asm__ __volatile__( ".set	push\n\t" ".set	noreorder\n\t" ".set	mips2\n\t" "sync\n\t" ".set	pop" : : : "memory"); } while (0);
                if (tty_hung_up_p(filp) ||
                    !(info->flags & 0x80000000)) {

                        if (info->flags & 0x0001)
                                retval = -11;
                        else
                                retval = -512;



                        break;
                }
                if (!(info->flags & 0x40000000) &&
                    !(info->flags & 0x08000000) &&
                    (do_clocal || (serial_in(info, 6) &
                                   0x80)))
                        break;
                if (signal_pending(current)) {
                        retval = -512;
                        break;
                }




                schedule();
        }
        do { current->state = (0); __asm__ __volatile__( ".set	push\n\t" ".set	noreorder\n\t" ".set	mips2\n\t" "sync\n\t" ".set	pop" : : : "memory"); } while (0);
        remove_wait_queue(&info->open_wait, &wait);
        if (extra_count)
                state->count++;
        info->blocked_open--;




        if (retval)
                return retval;
        info->flags |= 0x20000000;
        return 0;
}

static int get_async_struct(int line, struct async_struct **ret_info)
{
        struct async_struct *info;
        struct serial_state *sstate;

        sstate = rs_table + line;
        sstate->count++;
        if (sstate->info) {
                *ret_info = sstate->info;
                return 0;
        }
        info = kmalloc(sizeof(struct async_struct), (0x20 | 0x10 | 0x40 | 0x80 | 0x100));
        if (!info) {
                sstate->count--;
                return -12;
        }
        memset(info, 0, sizeof(struct async_struct));
        init_waitqueue_head(&info->open_wait);
        init_waitqueue_head(&info->close_wait);
        init_waitqueue_head(&info->delta_msr_wait);
        info->magic = 0x5301;
        info->port = sstate->port;
        info->flags = sstate->flags;
        info->io_type = sstate->io_type;
        info->iomem_base = sstate->iomem_base;
        info->iomem_reg_shift = sstate->iomem_reg_shift;
        info->xmit_fifo_size = sstate->xmit_fifo_size;
        info->line = line;
        info->tqueue.routine = do_softint;
        info->tqueue.data = info;
        info->state = sstate;
        if (sstate->info) {
                kfree(info);
                *ret_info = sstate->info;
                return 0;
        }
        *ret_info = sstate->info = info;
        return 0;
}
# 3170 "drivers/char/serial.c"
static int rs_open(struct tty_struct *tty, struct file * filp)
{
        struct async_struct *info;
        int retval, line;
        unsigned long page;

        do { } while (0);
        line = ((unsigned int) ((tty->device) & ((1U << 8) - 1))) - tty->driver.minor_start;
        if ((line < 0) || (line >= (sizeof(rs_table)/sizeof(struct serial_state)))) {
                do { } while (0);
                return -19;
        }
        retval = get_async_struct(line, &info);
        if (retval) {
                do { } while (0);
                return retval;
        }
        tty->driver_data = info;
        info->tty = tty;
        if (serial_paranoia_check(info, tty->device, "rs_open"))
                return -19;






        info->tty->low_latency = (info->flags & 0x2000) ? 1 : 0;





        if (!tmp_buf) {
                page = get_zeroed_page((0x20 | 0x10 | 0x40 | 0x80 | 0x100));
                if (!page)
                        return -12;
                if (tmp_buf)
                        free_pages((page),0);
                else
                        tmp_buf = (unsigned char *) page;
        }




        if (tty_hung_up_p(filp) ||
            (info->flags & 0x08000000)) {
                if (info->flags & 0x08000000)
                        interruptible_sleep_on(&info->close_wait);

                return ((info->flags & 0x0001) ?
                        -11 : -512);



        }




        retval = startup(info);
        if (retval)
                return retval;

        retval = block_til_ready(tty, filp, info);
        if (retval) {




                return retval;
        }

        if ((info->state->count == 1) &&
            (info->flags & 0x0008)) {
                if (tty->driver.subtype == 1)
                        *tty->termios = info->state->normal_termios;
                else
                        *tty->termios = info->state->callout_termios;
                change_speed(info, 0);
        }

        if (sercons.cflag && sercons.index == line) {
                tty->termios->c_cflag = sercons.cflag;
                sercons.cflag = 0;
                change_speed(info, 0);
        }

        info->session = current->session;
        info->pgrp = current->pgrp;




        return 0;
}





static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) int line_info(char *buf, struct serial_state *state)
{
        struct async_struct *info = state->info, scr_info;
        char stat_buf[30], control, status;
        int ret;
        unsigned long flags;




        if (state->type == 0) {
                return 0;
        }

        ret = sprintf(buf, "%d: uart:%s port:%lX irq:%d",
                      state->line, uart_config[state->type].name,
                      (state->port ? state->port : (long)state->iomem_base),
                      state->irq);




        if (!info) {
                info = &scr_info;

                info->magic = 0x5301;
                info->port = state->port;
                info->flags = state->flags;
                info->hub6 = state->hub6;
                info->io_type = state->io_type;
                info->iomem_base = state->iomem_base;
                info->iomem_reg_shift = state->iomem_reg_shift;
                info->quot = 0;
                info->tty = 0;
        }
        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        status = serial_in(info, 6);
        control = info != &scr_info ? info->MCR : serial_in(info, 4);
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);

        stat_buf[0] = 0;
        stat_buf[1] = 0;
        if (control & 0x02)
                strcat(stat_buf, "|RTS");
        if (status & 0x10)
                strcat(stat_buf, "|CTS");
        if (control & 0x01)
                strcat(stat_buf, "|DTR");
        if (status & 0x20)
                strcat(stat_buf, "|DSR");
        if (status & 0x80)
                strcat(stat_buf, "|CD");
        if (status & 0x40)
                strcat(stat_buf, "|RI");

        if (info->quot) {
                ret += sprintf(buf+ret, " baud:%d",
                               state->baud_base / info->quot);
        }

        ret += sprintf(buf+ret, " tx:%d rx:%d",
                      state->icount.tx, state->icount.rx);

        if (state->icount.frame)
                ret += sprintf(buf+ret, " fe:%d", state->icount.frame);

        if (state->icount.parity)
                ret += sprintf(buf+ret, " pe:%d", state->icount.parity);

        if (state->icount.brk)
                ret += sprintf(buf+ret, " brk:%d", state->icount.brk);

        if (state->icount.overrun)
                ret += sprintf(buf+ret, " oe:%d", state->icount.overrun);




        ret += sprintf(buf+ret, " %s\n", stat_buf+1);
        return ret;
}

static int rs_read_proc(char *page, char **start, off_t off, int count,
                        int *eof, void *data)
{
        int i, len = 0, l;
        off_t begin = 0;

        len += sprintf(page, "serinfo:1.0 driver:%s%s revision:%s\n",
                       serial_version, "", serial_revdate);
        for (i = 0; i < (sizeof(rs_table)/sizeof(struct serial_state)) && len < 4000; i++) {
                l = line_info(page + len, &rs_table[i]);
                len += l;
                if (len+begin > off+count)
                        goto done;
                if (len+begin < off) {
                        begin += len;
                        len = 0;
                }
        }
        *eof = 1;
done:
        if (off >= len+begin)
                return 0;
        *start = page + (off-begin);
        return ((count < begin+len-off) ? count : begin+len-off);
}
# 3393 "drivers/char/serial.c"
static char serial_options[] __attribute__ ((__section__ (".data.init"))) =





       " MANY_PORTS"
#define SERIAL_OPT 






       " SHARE_IRQ"
#define SERIAL_OPT 






       " SERIAL_PCI"
#define SERIAL_OPT 
# 3427 "drivers/char/serial.c"
       " enabled\n";



#undef SERIAL_OPT

static void show_serial_version(void)
{
        printk("<6>" "%s version %s%s (%s) with%s", serial_name,
               serial_version, "", serial_revdate,
               serial_options);
}
# 3447 "drivers/char/serial.c"
static unsigned detect_uart_irq (struct serial_state * state)
{
        int irq;
        unsigned long irqs;
        unsigned char save_mcr, save_ier;
        struct async_struct scr_info;


        unsigned char save_ICP=0;
        unsigned short ICP=0;

        if (state->flags & 0x0002) {
                ICP = (state->port & 0xFE0) | 0x01F;
                save_ICP = inb_p(ICP);
                do { *(volatile u8 *)(mips_io_port_base + (ICP)) = (0x80); ; } while(0);
                (void) inb_p(ICP);
        }

        scr_info.magic = 0x5301;
        scr_info.state = state;
        scr_info.port = state->port;
        scr_info.flags = state->flags;



        scr_info.io_type = state->io_type;
        scr_info.iomem_base = state->iomem_base;
        scr_info.iomem_reg_shift = state->iomem_reg_shift;


        probe_irq_off(probe_irq_on());
        save_mcr = serial_in(&scr_info, 4);
        save_ier = serial_in(&scr_info, 1);
        serial_out(&scr_info, 4, 0x04 | 0x08);

        irqs = probe_irq_on();
        serial_out(&scr_info, 4, 0);
        __udelay((10),loops_per_jiffy);
        if (state->flags & 0x0002) {
                serial_out(&scr_info, 4, 0x01 | 0x02);

        } else {
                serial_out(&scr_info, 4, 0x01 | 0x02 | 0x08);

        }
        serial_out(&scr_info, 1, 0x0f);
        (void)serial_in(&scr_info, 5);
        (void)serial_in(&scr_info, 0);
        (void)serial_in(&scr_info, 2);
        (void)serial_in(&scr_info, 6);
        serial_out(&scr_info, 0, 0xFF);
        __udelay((20),loops_per_jiffy);
        irq = probe_irq_off(irqs);

        serial_out(&scr_info, 4, save_mcr);
        serial_out(&scr_info, 1, save_ier);

        if (state->flags & 0x0002)
                do { *(volatile u8 *)(mips_io_port_base + (ICP)) = (save_ICP); ; } while(0);

        return (irq > 0)? irq : 0;
}





static int size_fifo(struct async_struct *info)
{
        unsigned char old_fcr, old_mcr, old_dll, old_dlm;
        int count;

        old_fcr = serial_in(info, 2);
        old_mcr = serial_in(info, 4);
        serial_out(info, 2, 0x01 | 0x02 | 0x04);

        serial_out(info, 4, 0x10);
        serial_out(info, 3, 0x80);
        old_dll = serial_in(info, 0);
        old_dlm = serial_in(info, 1);
        serial_out(info, 0, 0x01);
        serial_out(info, 1, 0x00);
        serial_out(info, 3, 0x03);
        for (count = 0; count < 256; count++)
                serial_out(info, 0, count);
        ( (__builtin_constant_p(20) && (20)<=5) ? __udelay(((20)*1000),loops_per_jiffy) : ({unsigned long msec=(20); while (msec--) __udelay((1000),loops_per_jiffy);}));
        for (count = 0; (serial_in(info, 5) & 0x01) &&
             (count < 256); count++)
                serial_in(info, 0);
        serial_out(info, 2, old_fcr);
        serial_out(info, 4, old_mcr);
        serial_out(info, 3, 0x80);
        serial_out(info, 0, old_dll);
        serial_out(info, 1, old_dlm);

        return count;
}
# 3555 "drivers/char/serial.c"
static void autoconfig_startech_uarts(struct async_struct *info,
                                      struct serial_state *state,
                                      unsigned long flags)
{
        unsigned char scratch, scratch2, scratch3, scratch4;
# 3568 "drivers/char/serial.c"
        if (state->type == 4) {







                info->ACR = 0;
                serial_out(info, 3, 0xBF);
                serial_out(info, 2, 0x10);
                serial_out(info, 3, 0x00);

                scratch = serial_icr_read(info, 0x08);
                scratch2 = serial_icr_read(info, 0x09);
                scratch3 = serial_icr_read(info, 0x0A);

                if (scratch == 0x16 && scratch2 == 0xC9 &&
                    (scratch3 == 0x50 || scratch3 == 0x52 ||
                     scratch3 == 0x54)) {
                        state->type = 10;
                        state->revision = serial_icr_read(info, 0x0B) |
                                (scratch3 << 8);
                        return;
                }
        }
# 3606 "drivers/char/serial.c"
        serial_out(info, 3, 0x80);
        scratch3 = serial_in(info, 0);
        scratch4 = serial_in(info, 1);

        serial_out(info, 0, 0);
        serial_out(info, 1, 0);
        scratch2 = serial_in(info, 0);
        scratch = serial_in(info, 1);
        serial_out(info, 3, 0);

        if (scratch == 0x10 || scratch == 0x14) {
                if (scratch == 0x10)
                        state->revision = scratch2;
                state->type = 12;
                return;
        }



        serial_out(info, 3, 0x80);
        serial_out(info, 0, scratch3);
        serial_out(info, 1, scratch4);
        serial_out(info, 3, 0);







        if (size_fifo(info) == 64)
                state->type = 11;
        else
                state->type = 7;
}
# 3649 "drivers/char/serial.c"
static void autoconfig(struct serial_state * state)
{
        unsigned char status1, status2, scratch, scratch2, scratch3;
        unsigned char save_lcr, save_mcr;
        struct async_struct *info, scr_info;
        unsigned long flags;

        state->type = 0;






        if (!((state)->port || ((state)->iomem_base)))
                return;

        info = &scr_info;

        info->magic = 0x5301;
        info->state = state;
        info->port = state->port;
        info->flags = state->flags;



        info->io_type = state->io_type;
        info->iomem_base = state->iomem_base;
        info->iomem_reg_shift = state->iomem_reg_shift;

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();

        if (!(state->flags & 0x4000) &&
            !state->iomem_base) {
# 3693 "drivers/char/serial.c"
                scratch = serial_in(info, 1);
                serial_out(info, 1, 0);



                scratch2 = serial_in(info, 1);
                serial_out(info, 1, 0x0F);



                scratch3 = serial_in(info, 1);
                serial_out(info, 1, scratch);
                if (scratch2 || scratch3 != 0x0F) {





                        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                        return;
                }
        }

        save_mcr = serial_in(info, 4);
        save_lcr = serial_in(info, 3);
# 3728 "drivers/char/serial.c"
        if (!(state->flags & 0x0040)) {
                serial_out(info, 4, 0x10 | 0x0A);
                status1 = serial_in(info, 6) & 0xF0;
                serial_out(info, 4, save_mcr);
                if (status1 != 0x90) {




                        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                        return;
                }
        }
        serial_out(info, 3, 0xBF);
        serial_out(info, 2, 0);
        serial_out(info, 3, 0);
        serial_out(info, 2, 0x01);
        scratch = serial_in(info, 2) >> 6;
        switch (scratch) {
                case 0:
                        state->type = 2;
                        break;
                case 1:
                        state->type = 0;
                        break;
                case 2:
                        state->type = 3;
                        break;
                case 3:
                        state->type = 4;
                        break;
        }
        if (state->type == 4) {

                serial_out(info, 3, 0x80);
                if (serial_in(info, 2) == 0) {
                        serial_out(info, 2, 0xA8);
                        if (serial_in(info, 2) == 0) {


                                goto out;
                        }
                        state->type = 6;
                        serial_out(info, 2, 0);
                } else {
                        serial_out(info, 3, 0xBF);
                        if (serial_in(info, 2) == 0)
                                autoconfig_startech_uarts(info, state, flags);
                }
        }
        if (state->type == 4) {

                serial_out(info, 3, save_lcr | 0x80);
                serial_out(info, 2, 0x01 | 0x20);

                scratch = serial_in(info, 2) >> 5;
                if (scratch == 7) {






                        serial_out(info, 2, 0x01);
                        serial_out(info, 3, 0);
                        serial_out(info, 2, 0x01 | 0x20);

                        scratch = serial_in(info, 2) >> 5;
                        if (scratch == 6)
                                state->type = 8;
                }
                serial_out(info, 2, 0x01);
        }
# 3820 "drivers/char/serial.c"
out:
        serial_out(info, 3, save_lcr);
        if (state->type == 2) {
                scratch = serial_in(info, 7);
                serial_out(info, 7, 0xa5);
                status1 = serial_in(info, 7);
                serial_out(info, 7, 0x5a);
                status2 = serial_in(info, 7);
                serial_out(info, 7, scratch);

                if ((status1 != 0xa5) || (status2 != 0x5a))
                        state->type = 1;
        }
        state->xmit_fifo_size = uart_config[state->type].dfl_xmit_fifo_size;

        if (state->type == 0) {
                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                return;
        }

        if (info->port) {

                if (state->type == 13)
                        __request_region(&ioport_resource, (info->port + (-8)), (16), ("serial_rsa(auto)"));

                else

                        __request_region(&ioport_resource, (info->port), (8), ("serial(auto)"));
        }





        if (state->type == 13)
                serial_out(info, (((-8)) + 2), 0);

        serial_out(info, 4, save_mcr);
        serial_out(info, 2, (0x01 | 0x02 | 0x04));


        serial_out(info, 2, 0);
        (void)serial_in(info, 0);
        serial_out(info, 1, 0);

        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}

int register_serial(struct serial_struct *req);
void unregister_serial(int line);


error this_object_must_be_defined_as_export_objs_in_the_Makefile;
error this_object_must_be_defined_as_export_objs_in_the_Makefile;
# 3886 "drivers/char/serial.c"
static void printk_pnp_dev_id(unsigned short vendor,
                                     unsigned short device)
{
        printk("%c%c%c%x%x%x%x",
               'A' + ((vendor >> 2) & 0x3f) - 1,
               'A' + (((vendor & 3) << 3) | ((vendor >> 13) & 7)) - 1,
               'A' + ((vendor >> 8) & 0x1f) - 1,
               (device >> 4) & 0x0f,
               device & 0x0f,
               (device >> 12) & 0x0f,
               (device >> 8) & 0x0f);
}

static int get_pci_port(struct pci_dev *dev,
                                  struct pci_board *board,
                                  struct serial_struct *req,
                                  int idx)
{
        unsigned long port;
        int base_idx;
        int max_port;
        int offset;

        base_idx = (board->flags & 0x0007);
        if (board->flags & 0x0100)
                base_idx += idx;

        if (board->flags & 0x0800) {
                max_port = (((((dev))->resource[((base_idx))].start) == 0 && (((dev))->resource[((base_idx))].end) == (((dev))->resource[((base_idx))].start)) ? 0 : ((((dev))->resource[((base_idx))].end) - (((dev))->resource[((base_idx))].start) + 1)) / 8;
                if (idx >= max_port)
                        return 1;
        }

        offset = board->first_uart_offset;



        if(dev->vendor == 0x1409 )
                switch(idx) {
                        case 0: base_idx=0;
                                break;
                        case 1: base_idx=0; offset=8;
                                break;
                        case 2: base_idx=1;
                                break;
                        case 3: base_idx=1; offset=8;
                                break;
                        case 4:
                        case 5:
                        case 6:
                        case 7: base_idx=idx-2;
                }


        if (dev->vendor == 0x14D2 &&
            (dev->device == 0x8040 ||
             dev->device == 0x8080)) {
                switch (idx) {
                case 0: base_idx = 1;
                        break;
                case 1: base_idx = 2;
                        break;
                default:
                        base_idx = 4;
                        offset = 8 * (idx - 2);
                }

        }




        if (dev->vendor == 0x103c &&
                        dev->device == 0x1048) {
                switch (dev->subsystem_device) {
                case 0x104B:
                        if (idx == 3) idx++;
                        break;
                case 0x1282:
                        if (idx > 0) idx++;
                        if (idx > 2) idx++;
                        break;
                }
                if (idx > 2) {
                        offset = 0x18;
                }
        }

        port = ((dev)->resource[(base_idx)].start) + offset;

        if ((board->flags & 0x0100) == 0)
                port += idx * (board->uart_offset ? board->uart_offset : 8);

        if (((((dev))->resource[((base_idx))].flags) & 0x00000100)) {
                req->port = port;
                if (((sizeof(long)-sizeof(int))*8))
                        req->port_high = port >> ((sizeof(long)-sizeof(int))*8);
                else
                        req->port_high = 0;
                return 0;
        }
        req->io_type = 2;
        req->iomem_base = __ioremap((port), (board->uart_offset), (2<<9));
        req->iomem_reg_shift = board->reg_shift;
        req->port = 0;
        return 0;
}

static int get_pci_irq(struct pci_dev *dev,
                                struct pci_board *board,
                                int idx)
{
        int base_idx;

        if ((board->flags & 0x0400) == 0)
                return dev->irq;

        base_idx = ((board->flags & (0x0007 << 4)) >> 4);
        if (board->flags & 0x0200)
                base_idx += idx;

        return ((dev)->irq_resource[base_idx].start);
}




static void start_pci_pnp_board(struct pci_dev *dev,
                                       struct pci_board *board)
{
        int k, line;
        struct serial_struct serial_req;
        int base_baud;

       if ((dev->prepare) && ((dev->prepare))(dev) < 0) {
               printk("serial: PNP device '");
               printk_pnp_dev_id(dev->vendor, dev->device);
               printk("' prepare failed\n");
               return;
       }

       if ((dev->activate) && ((dev->activate))(dev) < 0) {
               printk("serial: PNP device '");
               printk_pnp_dev_id(dev->vendor, dev->device);
               printk("' activate failed\n");
               return;
       }




        if (board->init_fn && ((board->init_fn)(dev, board, 1) != 0))
                return;





        if ((dev->deactivate) || board->init_fn) {
                for (k=0; k < 8; k++)
                        if (serial_pci_board[k].dev == 0)
                                break;
                if (k >= 8)
                        return;
                serial_pci_board[k].board = *board;
                serial_pci_board[k].dev = dev;
        }

        base_baud = board->base_baud;
        if (!base_baud)
                base_baud = (5*25000000/2/16);
        memset(&serial_req, 0, sizeof(serial_req));

        for (k=0; k < board->num_ports; k++) {
                serial_req.irq = get_pci_irq(dev, board, k);
                if (get_pci_port(dev, board, &serial_req, k))
                        break;
                serial_req.flags = 0x0040 | 0x8000;




                line = register_serial(&serial_req);
                if (line < 0)
                        break;
                rs_table[line].baud_base = base_baud;
                rs_table[line].dev = dev;
        }
}
# 4084 "drivers/char/serial.c"
static int
pci_plx9050_fn(struct pci_dev *dev, struct pci_board *board, int enable)
{
        u8 data, *p, irq_config;
        int pci_config;

        irq_config = 0x41;
        pci_config = 0x2;
        if (dev->vendor == 0x14d4)
                irq_config = 0x43;
        if ((dev->vendor == 0x10b5) &&
            (dev->device == 0x106a)) {
# 4104 "drivers/char/serial.c"
                irq_config = 0x5b;
                pci_config = 0x2 | 0x1;
        }

        pci_read_config_byte(dev, 0x04, &data);

        if (enable)
                pci_write_config_byte(dev, 0x04,
                                      data | pci_config);


        p = __ioremap((((dev)->resource[(0)].start)), (0x80), (2<<9));
        ((*(volatile unsigned int *)((unsigned long)p + 0x4c)) = ((enable ? irq_config : 0x00)));
        iounmap(p);

        if (!enable)
                pci_write_config_byte(dev, 0x04,
                                      data & ~pci_config);
        return 0;
}
# 4147 "drivers/char/serial.c"
#define PCI_DEVICE_ID_SIIG_1S_10x (PCI_DEVICE_ID_SIIG_1S_10x_550 & 0xfffc)
#define PCI_DEVICE_ID_SIIG_2S_10x (PCI_DEVICE_ID_SIIG_2S_10x_550 & 0xfff8)

int
pci_siig10x_fn(struct pci_dev *dev, struct pci_board *board, int enable)
{
       u16 data, *p;

       if (!enable) return 0;

       p = __ioremap((((dev)->resource[(0)].start)), (0x80), (2<<9));

       switch (dev->device & 0xfff8) {
               case (0x1000 & 0xfffc):
                       data = 0xffdf;
                       break;
               case (0x1030 & 0xfff8):
                       data = 0xf7ff;
                       break;
               default:
                       data = 0xfffb;
                       break;
       }

       ((*(volatile unsigned short *)((unsigned long) p + 0x28)) = ((((*(volatile unsigned short *)((unsigned long) p + 0x28))) & data)));
       iounmap(p);
       return 0;
}
error this_object_must_be_defined_as_export_objs_in_the_Makefile;

#define PCI_DEVICE_ID_SIIG_2S_20x (PCI_DEVICE_ID_SIIG_2S_20x_550 & 0xfffc)
#define PCI_DEVICE_ID_SIIG_2S1P_20x (PCI_DEVICE_ID_SIIG_2S1P_20x_550 & 0xfffc)

int
pci_siig20x_fn(struct pci_dev *dev, struct pci_board *board, int enable)
{
       u8 data;

       if (!enable) return 0;


       pci_read_config_byte(dev, 0x6f, &data);
       pci_write_config_byte(dev, 0x6f, data & 0xef);


       if (((dev->device & 0xfffc) == (0x2030 & 0xfffc)) ||
           ((dev->device & 0xfffc) == (0x2060 & 0xfffc))) {
               pci_read_config_byte(dev, 0x73, &data);
               pci_write_config_byte(dev, 0x73, data & 0xef);
       }
       return 0;
}
error this_object_must_be_defined_as_export_objs_in_the_Makefile;


static int
pci_inteli960ni_fn(struct pci_dev *dev,
                   struct pci_board *board,
                   int enable)
{
        unsigned long oldval;

        if (!(((dev)->subsystem_device) & 0x1000))
                return(-1);

        if (!enable)
                return(0);






        pci_read_config_dword(dev, 0x44, (void*) &oldval);
        if (oldval == 0x00001000L) {
                printk("<7>" "Local i960 firmware missing");
                return(-1);
        }
        return(0);
}






static unsigned short timedia_single_port[] = {
        0x4025, 0x4027, 0x4028, 0x5025, 0x5027, 0 };
static unsigned short timedia_dual_port[] = {
        0x0002, 0x4036, 0x4037, 0x4038, 0x4078, 0x4079, 0x4085,
        0x4088, 0x4089, 0x5037, 0x5078, 0x5079, 0x5085, 0x6079,
        0x7079, 0x8079, 0x8137, 0x8138, 0x8237, 0x8238, 0x9079,
        0x9137, 0x9138, 0x9237, 0x9238, 0xA079, 0xB079, 0xC079,
        0xD079, 0 };
static unsigned short timedia_quad_port[] = {
        0x4055, 0x4056, 0x4095, 0x4096, 0x5056, 0x8156, 0x8157,
        0x8256, 0x8257, 0x9056, 0x9156, 0x9157, 0x9158, 0x9159,
        0x9256, 0x9257, 0xA056, 0xA157, 0xA158, 0xA159, 0xB056,
        0xB157, 0 };
static unsigned short timedia_eight_port[] = {
        0x4065, 0x4066, 0x5065, 0x5066, 0x8166, 0x9066, 0x9166,
        0x9167, 0x9168, 0xA066, 0xA167, 0xA168, 0 };
static struct timedia_struct {
        int num;
        unsigned short *ids;
} timedia_data[] = {
        { 1, timedia_single_port },
        { 2, timedia_dual_port },
        { 4, timedia_quad_port },
        { 8, timedia_eight_port },
        { 0, 0 }
};

static int
pci_timedia_fn(struct pci_dev *dev, struct pci_board *board, int enable)
{
        int i, j;
        unsigned short *ids;

        if (!enable)
                return 0;

        for (i=0; timedia_data[i].num; i++) {
                ids = timedia_data[i].ids;
                for (j=0; ids[j]; j++) {
                        if (((dev)->subsystem_device) == ids[j]) {
                                board->num_ports = timedia_data[i].num;
                                return 0;
                        }
                }
        }
        return 0;
}
# 4288 "drivers/char/serial.c"
static int
pci_hp_diva(struct pci_dev *dev, struct pci_board *board, int enable)
{
        if (!enable)
                return 0;

        switch (dev->subsystem_device) {
        case 0x1049:
        case 0x1223:
        case 0x1226:
        case 0x1282:
                board->num_ports = 3;
                break;
        case 0x104A:
                board->num_ports = 2;
                break;
        case 0x104B:
                board->num_ports = 4;
                break;
        case 0x1227:
                board->num_ports = 1;
                break;
        }

        return 0;
}

static int
pci_xircom_fn(struct pci_dev *dev, struct pci_board *board, int enable)
{
        do { current->state = (2); } while (0);
        schedule_timeout(100/10);
        return 0;
}







enum pci_board_num_t {
        pbn_b0_1_115200,
        pbn_default = 0,

        pbn_b0_2_115200,
        pbn_b0_4_115200,

        pbn_b0_1_921600,
        pbn_b0_2_921600,
        pbn_b0_4_921600,

        pbn_b0_bt_1_115200,
        pbn_b0_bt_2_115200,
        pbn_b0_bt_1_460800,
        pbn_b0_bt_2_460800,
        pbn_b0_bt_2_921600,

        pbn_b1_1_115200,
        pbn_b1_2_115200,
        pbn_b1_4_115200,
        pbn_b1_8_115200,

        pbn_b1_2_921600,
        pbn_b1_4_921600,
        pbn_b1_8_921600,

        pbn_b1_2_1382400,
        pbn_b1_4_1382400,
        pbn_b1_8_1382400,

        pbn_b2_1_115200,
        pbn_b2_8_115200,
        pbn_b2_4_460800,
        pbn_b2_8_460800,
        pbn_b2_16_460800,
        pbn_b2_4_921600,
        pbn_b2_8_921600,

        pbn_b2_bt_1_115200,
        pbn_b2_bt_2_115200,
        pbn_b2_bt_4_115200,
        pbn_b2_bt_2_921600,

        pbn_panacom,
        pbn_panacom2,
        pbn_panacom4,
        pbn_plx_romulus,
        pbn_oxsemi,
        pbn_timedia,
        pbn_intel_i960,
        pbn_sgi_ioc3,
        pbn_hp_diva,




        pbn_dci_pccom4,
        pbn_dci_pccom8,

        pbn_xircom_combo,

        pbn_siig10x_0,
        pbn_siig10x_1,
        pbn_siig10x_2,
        pbn_siig10x_4,
        pbn_siig20x_0,
        pbn_siig20x_2,
        pbn_siig20x_4,

        pbn_computone_4,
        pbn_computone_6,
        pbn_computone_8,
};

static struct pci_board pci_boards[] = {
# 4412 "drivers/char/serial.c"
        { 0x0000, 1, 115200 },


        { 0x0000, 2, 115200 },
        { 0x0000, 4, 115200 },

        { 0x0000, 1, 921600 },
        { 0x0000, 2, 921600 },
        { 0x0000, 4, 921600 },

        { 0x0000 | 0x0100, 1, 115200 },
        { 0x0000 | 0x0100, 2, 115200 },
        { 0x0000 | 0x0100, 1, 460800 },
        { 0x0000 | 0x0100, 2, 460800 },
        { 0x0000 | 0x0100, 2, 921600 },

        { 0x0001, 1, 115200 },
        { 0x0001, 2, 115200 },
        { 0x0001, 4, 115200 },
        { 0x0001, 8, 115200 },

        { 0x0001, 2, 921600 },
        { 0x0001, 4, 921600 },
        { 0x0001, 8, 921600 },

        { 0x0001, 2, 1382400 },
        { 0x0001, 4, 1382400 },
        { 0x0001, 8, 1382400 },

        { 0x0002, 1, 115200 },
        { 0x0002, 8, 115200 },
        { 0x0002, 4, 460800 },
        { 0x0002, 8, 460800 },
        { 0x0002, 16, 460800 },
        { 0x0002, 4, 921600 },
        { 0x0002, 8, 921600 },

        { 0x0002 | 0x0100, 1, 115200 },
        { 0x0002 | 0x0100, 2, 115200 },
        { 0x0002 | 0x0100, 4, 115200 },
        { 0x0002 | 0x0100, 2, 921600 },

        { 0x0002, 2, 921600,
                0x400, 7, pci_plx9050_fn },
        { 0x0002 | 0x0100, 2, 921600,
                0x400, 7, pci_plx9050_fn },
        { 0x0002 | 0x0100, 4, 921600,
                0x400, 7, pci_plx9050_fn },
        { 0x0002, 4, 921600,
                0x20, 2, pci_plx9050_fn, 0x03 },


        { 0x0000 | 0x0800, 32, 115200 },
        { 0x0100, 1, 921600,
                0, 0, pci_timedia_fn },

        { 0x0000, 32, 921600,
                8<<2, 2, pci_inteli960ni_fn, 0x10000},
        { 0x0000 | 0x0400,
                1, 458333, 0, 0, 0, 0x20178 },
        { 0x0000, 5, 115200, 8, 0, pci_hp_diva, 0},
# 4482 "drivers/char/serial.c"
        {0x0003, 4, 115200, 8},
        {0x0003, 8, 115200, 8},

        { 0x0000, 1, 115200,
                0, 0, pci_xircom_fn },

        { 0x0002, 1, 460800,
                0, 0, pci_siig10x_fn },
        { 0x0002, 1, 921600,
                0, 0, pci_siig10x_fn },
        { 0x0002 | 0x0100, 2, 921600,
                0, 0, pci_siig10x_fn },
        { 0x0002 | 0x0100, 4, 921600,
                0, 0, pci_siig10x_fn },
        { 0x0000, 1, 921600,
                0, 0, pci_siig20x_fn },
        { 0x0000 | 0x0100, 2, 921600,
                0, 0, pci_siig20x_fn },
        { 0x0000 | 0x0100, 4, 921600,
                0, 0, pci_siig20x_fn },

        { 0x0000, 4, 921600,
                0x40, 2, ((void *)0), 0x200 },
        { 0x0000, 6, 921600,
                0x40, 2, ((void *)0), 0x200 },
        { 0x0000, 8, 921600,
                0x40, 2, ((void *)0), 0x200 },
};






static int serial_pci_guess_board(struct pci_dev *dev,
                                           struct pci_board *board)
{
        int num_iomem = 0, num_port = 0, first_port = -1;
        int i;
# 4529 "drivers/char/serial.c"
        if ((((dev->class >> 8) != 0x0700) &&
            ((dev->class >> 8) != 0x0703)) ||
            (dev->class & 0xff) > 6)
                return 1;

        for (i=0; i < 6; i++) {
                if (((((dev))->resource[((i))].flags) & 0x00000100)) {
                        num_port++;
                        if (first_port == -1)
                                first_port = i;
                }
                if (((((dev))->resource[((i))].flags) & 0x00000200))
                        num_iomem++;
        }





        if (num_iomem <= 1 && num_port == 1) {
                board->flags = first_port;
                return 0;
        }
        return 1;
}

static int serial_init_one(struct pci_dev *dev,
                                     const struct pci_device_id *ent)
{
        struct pci_board *board, tmp;
        int rc;

        board = &pci_boards[ent->driver_data];

        rc = pci_enable_device(dev);
        if (rc) return rc;

        if (ent->driver_data == pbn_default &&
            serial_pci_guess_board(dev, board))
                return -19;
        else if (serial_pci_guess_board(dev, &tmp) == 0) {
                printk("<6>" "Redundant entry in serial pci_table.  "
                       "Please send the output of\n"
                       "lspci -vv, this message (%04x,%04x,%04x,%04x)\n"
                       "and the manufacturer and name of "
                       "serial board or modem board\n"
                       "to serial-pci-info@lists.sourceforge.net.\n",
                       dev->vendor, dev->device,
                       ((dev)->subsystem_vendor), ((dev)->subsystem_device));
        }

        start_pci_pnp_board(dev, board);

        return 0;
}

static void serial_remove_one(struct pci_dev *dev)
{
        int i;





        for(i = 0; i < (sizeof(rs_table)/sizeof(struct serial_state)); i++) {
                if (rs_table[i].dev != dev)
                        continue;
                unregister_serial(i);
                rs_table[i].dev = 0;
        }



        for (i=0; i < 8; i++) {
                struct pci_board_inst *brd = &serial_pci_board[i];

                if (serial_pci_board[i].dev != dev)
                        continue;
                if (brd->board.init_fn)
                        (brd->board.init_fn)(brd->dev, &brd->board, 0);
                if ((brd->dev->deactivate))
                        ((brd->dev->deactivate))(brd->dev);
                serial_pci_board[i].dev = 0;
        }
}


static struct pci_device_id serial_pci_tbl[] = {
        { 0x11b0, 0x0001,
                0x12c4,
                0x0001, 0, 0,
                pbn_b1_8_1382400 },
        { 0x11b0, 0x0001,
                0x12c4,
                0x0002, 0, 0,
                pbn_b1_4_1382400 },
        { 0x11b0, 0x0001,
                0x12c4,
                0x0003, 0, 0,
                pbn_b1_2_1382400 },
        { 0x11b0, 0x0002,
                0x12c4,
                0x0001, 0, 0,
                pbn_b1_8_1382400 },
        { 0x11b0, 0x0002,
                0x12c4,
                0x0002, 0, 0,
                pbn_b1_4_1382400 },
        { 0x11b0, 0x0002,
                0x12c4,
                0x0003, 0, 0,
                pbn_b1_2_1382400 },
        { 0x11b0, 0x0002,
                0x12c4,
                0x0004, 0, 0,
                pbn_b1_8_921600 },
        { 0x11b0, 0x0002,
                0x12c4,
                0x0005, 0, 0,
                pbn_b1_8_921600 },
        { 0x11b0, 0x0002,
                0x12c4,
                0x0006, 0, 0,
                pbn_b1_4_921600 },
        { 0x11b0, 0x0002,
                0x12c4,
                0x0007, 0, 0,
                pbn_b1_4_921600 },
        { 0x11b0, 0x0002,
                0x12c4,
                0x0008, 0, 0,
                pbn_b1_2_921600 },
        { 0x11b0, 0x0002,
                0x12c4,
                0x0009, 0, 0,
                pbn_b1_8_921600 },
        { 0x11b0, 0x0002,
                0x12c4,
                0x000A, 0, 0,
                pbn_b1_8_921600 },
        { 0x11b0, 0x0002,
                0x12c4,
                0x000B, 0, 0,
                pbn_b1_4_921600 },

        { 0x135e, 0x7101,
                (~0), (~0), 0, 0,
                pbn_b2_bt_1_115200 },
        { 0x135e, 0x7201,
                (~0), (~0), 0, 0,
                pbn_b2_bt_2_115200 },
        { 0x135e, 0x7402,
                (~0), (~0), 0, 0,
                pbn_b2_bt_4_115200 },
        { 0x135e, 0x7202,
                (~0), (~0), 0, 0,
                pbn_b2_bt_2_115200 },
        { 0x135e, 0x7401,
                (~0), (~0), 0, 0,
                pbn_b2_bt_4_115200 },
        { 0x135e, 0x7801,
                (~0), (~0), 0, 0,
                pbn_b2_8_115200 },

        { 0x10b5, 0xa001,
                (~0), (~0), 0, 0,
                pbn_b2_bt_2_115200 },
        { 0x10b5, 0x1103,
                (~0), (~0), 0, 0,
                pbn_b2_bt_2_921600 },

        { 0x10b5, 0x1076,
                (~0), (~0), 0, 0,
                pbn_b2_8_921600 },
        { 0x10b5, 0x1077,
                (~0), (~0), 0, 0,
                pbn_b2_4_921600 },
        { 0x10b5, 0x9050,
                0x11a9,
                0x5334, 0, 0,
                pbn_panacom },
        { 0x14d4, 0x0400,
                (~0), (~0), 0, 0,
                pbn_panacom4 },
        { 0x14d4, 0x0402,
                (~0), (~0), 0, 0,
                pbn_panacom2 },
        { 0x10b5, 0x9050,
                0x12E0,
                0x0031, 0, 0,
                pbn_b2_4_460800 },
        { 0x10b5, 0x9050,
                0x12E0,
                0x0021, 0, 0,
                pbn_b2_8_460800 },
        { 0x10b5, 0x9050,
                0x12E0,
                0x0011, 0, 0,
                pbn_b2_16_460800 },
        { 0x10b5, 0x9050,
                0x12E0,
                0x0041, 0, 0,
                pbn_b2_16_460800 },
        { 0x10b5, 0x9050,
                0x124D,
                0xF001, 0, 0,
                pbn_b2_4_460800 },
        { 0x10b5, 0x9050,
                0x124D,
                0xF010, 0, 0,
                pbn_b2_8_460800 },


        { 0x10b5, 0x106a,
                0x10b5, 0x106a, 0, 0,
                pbn_plx_romulus },
        { 0x135C, 0x0010,
                (~0), (~0), 0, 0,
                pbn_b1_4_115200 },
        { 0x135C, 0x0020,
                (~0), (~0), 0, 0,
                pbn_b1_2_115200 },
        { 0x135C, 0x0050,
                (~0), (~0), 0, 0,
                pbn_b1_8_115200 },
        { 0x135C, 0x0060,
                (~0), (~0), 0, 0,
                pbn_b1_8_115200 },
        { 0x11cb, 0x9501,
                0x11cb, 0xa004, 0, 0,
                pbn_b0_4_921600 },
        { 0x1415, 0x9501,
                (~0), (~0), 0, 0,
                pbn_b0_4_115200 },
        { 0x1415, 0x9521,
                (~0), (~0), 0, 0,
                pbn_b0_bt_2_921600 },


        { 0x11c1, 0x480,
                (~0), (~0), 0, 0,
                pbn_b1_1_115200 },


        { 0x12B9, 0x1008,
                (~0), (~0), },


        { 0x14D2, 0xA001,
                (~0), (~0), 0, 0,
                pbn_b0_1_921600 },
        { 0x14D2, 0xA005,
                (~0), (~0), 0, 0,
                pbn_b0_2_921600 },
        { 0x14D2, 0xA003,
                (~0), (~0), 0, 0,
                pbn_b0_4_921600 },
        { 0x14D2, 0xA004,
                (~0), (~0), 0, 0,
                pbn_b0_4_921600 },
        { 0x14D2, 0x8010,
                (~0), (~0),
                0x0001, 1, 921600 },
        { 0x14D2, 0x8020,
                (~0), (~0),
                0x0001 | 0x0100, 2, 921600 },

        { 0x14D2, 0x8040,
                (~0), (~0),
                0x0100, 4, 921600 },
        { 0x14D2, 0x8080,
                (~0), (~0),
                0x0100, 8, 921600 },

        { 0x131f, 0x1000,
                (~0), (~0), 0, 0,
                pbn_siig10x_0 },
        { 0x131f, 0x1001,
                (~0), (~0), 0, 0,
                pbn_siig10x_0 },
        { 0x131f, 0x1002,
                (~0), (~0), 0, 0,
                pbn_siig10x_0 },
        { 0x131f, 0x1030,
                (~0), (~0), 0, 0,
                pbn_siig10x_2 },
        { 0x131f, 0x1031,
                (~0), (~0), 0, 0,
                pbn_siig10x_2 },
        { 0x131f, 0x1032,
                (~0), (~0), 0, 0,
                pbn_siig10x_2 },
        { 0x131f, 0x1050,
                (~0), (~0), 0, 0,
                pbn_siig10x_4 },
        { 0x131f, 0x1051,
                (~0), (~0), 0, 0,
                pbn_siig10x_4 },
        { 0x131f, 0x1052,
                (~0), (~0), 0, 0,
                pbn_siig10x_4 },
        { 0x131f, 0x2000,
                (~0), (~0), 0, 0,
                pbn_siig20x_0 },
        { 0x131f, 0x2001,
                (~0), (~0), 0, 0,
                pbn_siig20x_0 },
        { 0x131f, 0x2002,
                (~0), (~0), 0, 0,
                pbn_siig20x_0 },
        { 0x131f, 0x2030,
                (~0), (~0), 0, 0,
                pbn_siig20x_2 },
        { 0x131f, 0x2031,
                (~0), (~0), 0, 0,
                pbn_siig20x_2 },
        { 0x131f, 0x2032,
                (~0), (~0), 0, 0,
                pbn_siig20x_2 },
        { 0x131f, 0x2050,
                (~0), (~0), 0, 0,
                pbn_siig20x_4 },
        { 0x131f, 0x2051,
                (~0), (~0), 0, 0,
                pbn_siig20x_4 },
        { 0x131f, 0x2052,
                (~0), (~0), 0, 0,
                pbn_siig20x_4 },


        { 0x8e0e, 0x0302,
                0x8e0e, 0x0001,
                0, 0, pbn_computone_4 },
        { 0x8e0e, 0x0302,
                0x8e0e, 0x0002,
                0, 0, pbn_computone_8 },
        { 0x8e0e, 0x0302,
                0x8e0e, 0x0003,
                0, 0, pbn_computone_6 },

        { 0x1415, 0x9511,
                (~0), (~0), 0, 0, pbn_oxsemi },
        { 0x1409, 0x7168,
                0x1409, (~0), 0, 0, pbn_timedia },

        { 0x1407, 0x0100,
                (~0), (~0), 0, 0,
                pbn_b0_bt_2_115200 },
        { 0x1407, 0x0101,
                (~0), (~0), 0, 0,
                pbn_b0_bt_2_115200 },
        { 0x1407, 0x0102,
                (~0), (~0), 0, 0,
                pbn_b0_bt_2_115200 },
        { 0x1407, 0x0200,
                (~0), (~0), 0, 0,
                pbn_b0_bt_2_460800 },
        { 0x1407, 0x0201,
                (~0), (~0), 0, 0,
                pbn_b0_bt_2_460800 },
        { 0x1407, 0x0202,
                (~0), (~0), 0, 0,
                pbn_b0_bt_2_460800 },
        { 0x1407, 0x0500,
                (~0), (~0), 0, 0,
                pbn_b0_bt_1_115200 },
        { 0x1407, 0x0600,
                (~0), (~0), 0, 0,
                pbn_b0_bt_1_460800 },


        { 0x15aa, 0x2000,
                (~0), (~0), 0, 0,
                pbn_b2_bt_2_115200 },


        { 0x8086, 0x1960,
                0xE4BF, (~0), 0, 0,
                pbn_intel_i960 },


        { 0x115d, 0x0103,
                (~0), (~0), 0, 0,
                pbn_xircom_combo },






        { 0x127A, 0x1004,
                0x1048, 0x1500, 0, 0,
                pbn_b1_1_115200 },

        { 0x10a9, 0x0003,
                0xFF00, 0, 0, 0,
                pbn_sgi_ioc3 },


        { 0x103c, 0x1048,
                (~0), (~0), 0, 0,
                pbn_hp_diva },
        { 0x103c, 0x1290,
                (~0), (~0), 0, 0,
                pbn_b2_1_115200 },
# 4945 "drivers/char/serial.c"
        { 0x6666, 0x0001,
                (~0), (~0), 0, 0,
                pbn_dci_pccom4 },
        { 0x6666, 0x0002,
                (~0), (~0), 0, 0,
                pbn_dci_pccom8 },

       { (~0), (~0), (~0), (~0),
         0x0700 << 8, 0xffff00, },
       { (~0), (~0), (~0), (~0),
         0x0703 << 8, 0xffff00, },
       { 0, }
};

static const struct pci_device_id * __module_pci_device_table __attribute__((__unused__)) __attribute__ ((__section__(".data.exit"))) = serial_pci_tbl;

static struct pci_driver serial_pci_driver = {
       name: "serial",
       probe: serial_init_one,
       remove: serial_remove_one,
       id_table: serial_pci_tbl,
};
# 4976 "drivers/char/serial.c"
static void probe_serial_pci(void)
{
# 4986 "drivers/char/serial.c"
        if (pci_module_init (&serial_pci_driver) != 0)
                serial_pci_driver.name = "";




        return;
}
# 5419 "drivers/char/serial.c"
static int __attribute__ ((__section__ (".text.init"))) rs_init(void)
{
        int i;
        struct serial_state * state;

        init_bh(SERIAL_BH, do_serial_bh);
        init_timer(&serial_timer);
        serial_timer.function = rs_timer;
        mod_timer(&serial_timer, jiffies + (10*100));

        for (i = 0; i < 128; i++) {
                IRQ_ports[i] = 0;
                IRQ_timeout[i] = 0;




        }





        if (sercons.flags & (2)) {
                for(i = 0; i < (sizeof(rs_table)/sizeof(struct serial_state)); i++)
                        if (i != sercons.index &&
                            rs_table[i].irq == rs_table[sercons.index].irq)
                                rs_table[i].irq = 0;
        }

        show_serial_version();



        memset(&serial_driver, 0, sizeof(struct tty_driver));
        serial_driver.magic = 0x5402;

        serial_driver.driver_name = "serial";




        serial_driver.name = "ttyS";

        serial_driver.major = 4;
        serial_driver.minor_start = 64 + 0;
        serial_driver.name_base = 0;
        serial_driver.num = (sizeof(rs_table)/sizeof(struct serial_state));
        serial_driver.type = 0x0003;
        serial_driver.subtype = 1;
        serial_driver.init_termios = tty_std_termios;
        serial_driver.init_termios.c_cflag =
                0000015 | 0000060 | 0000200 | 0002000 | 0004000;
        serial_driver.flags = 0x0004 | 0x0008;
        serial_driver.refcount = &serial_refcount;
        serial_driver.table = serial_table;
        serial_driver.termios = serial_termios;
        serial_driver.termios_locked = serial_termios_locked;

        serial_driver.open = rs_open;
        serial_driver.close = rs_close;
        serial_driver.write = rs_write;
        serial_driver.put_char = rs_put_char;
        serial_driver.flush_chars = rs_flush_chars;
        serial_driver.write_room = rs_write_room;
        serial_driver.chars_in_buffer = rs_chars_in_buffer;
        serial_driver.flush_buffer = rs_flush_buffer;
        serial_driver.ioctl = rs_ioctl;
        serial_driver.throttle = rs_throttle;
        serial_driver.unthrottle = rs_unthrottle;
        serial_driver.set_termios = rs_set_termios;
        serial_driver.stop = rs_stop;
        serial_driver.start = rs_start;
        serial_driver.hangup = rs_hangup;

        serial_driver.break_ctl = rs_break;


        serial_driver.send_xchar = rs_send_xchar;
        serial_driver.wait_until_sent = rs_wait_until_sent;
        serial_driver.read_proc = rs_read_proc;






        callout_driver = serial_driver;



        callout_driver.name = "cua";

        callout_driver.major = 5;
        callout_driver.subtype = 2;

        callout_driver.read_proc = 0;
        callout_driver.proc_entry = 0;


        if (tty_register_driver(&serial_driver))
                panic("Couldn't register serial driver\n");
        if (tty_register_driver(&callout_driver))
                panic("Couldn't register callout driver\n");

        for (i = 0, state = rs_table; i < (sizeof(rs_table)/sizeof(struct serial_state)); i++,state++) {
                state->magic = 0x5302;
                state->line = i;
                state->type = 0;
                state->custom_divisor = 0;
                state->close_delay = 5*100/10;
                state->closing_wait = 30*100;
                state->callout_termios = callout_driver.init_termios;
                state->normal_termios = serial_driver.init_termios;
                state->icount.cts = state->icount.dsr =
                        state->icount.rng = state->icount.dcd = 0;
                state->icount.rx = state->icount.tx = 0;
                state->icount.frame = state->icount.parity = 0;
                state->icount.overrun = state->icount.brk = 0;
                state->irq = (state->irq);
                if (state->hub6)
                        state->io_type = 1;
                if (state->port && __check_region(&ioport_resource, (state->port), (8)))
                        continue;




                if (state->flags & 0x10000000)
                        autoconfig(state);
        }
        for (i = 0, state = rs_table; i < (sizeof(rs_table)/sizeof(struct serial_state)); i++,state++) {
                if (state->type == 0)
                        continue;
                if ( (state->flags & 0x10000000)
                    && (state->flags & 0x0080)
                    && (state->port != 0 || state->iomem_base != 0))
                        state->irq = detect_uart_irq(state);
                if (state->io_type == 2) {
                        printk("<6>""ttyS%02d%s at 0x%p (irq = %d) is a %s\n",
                               state->line + 0,
                               (state->flags & 0x0002) ? " FourPort" : "",
                               state->iomem_base, state->irq,
                               uart_config[state->type].name);
                }
                else {
                        printk("<6>" "ttyS%02d%s at 0x%04lx (irq = %d) is a %s\n",
                               state->line + 0,
                               (state->flags & 0x0002) ? " FourPort" : "",
                               state->port, state->irq,
                               uart_config[state->type].name);
                }
                tty_register_devfs(&serial_driver, 0,
                                   serial_driver.minor_start + state->line);
                tty_register_devfs(&callout_driver, 0,
                                   callout_driver.minor_start + state->line);
        }

        probe_serial_pci();




        return 0;
}





int __attribute__ ((__section__ (".text.init"))) early_serial_setup(struct serial_struct *req)
{
        int i = req->line;

        if (i >= 128)
                return(-2);
        rs_table[i].magic = 0;
        rs_table[i].baud_base = req->baud_base;
        rs_table[i].port = req->port;
        if (((sizeof(long)-sizeof(int))*8))
                rs_table[i].port += (unsigned long) req->port_high <<
                                                        ((sizeof(long)-sizeof(int))*8);
        rs_table[i].irq = req->irq;
        rs_table[i].flags = req->flags;
        rs_table[i].close_delay = req->close_delay;
        rs_table[i].io_type = req->io_type;
        rs_table[i].hub6 = req->hub6;
        rs_table[i].iomem_base = req->iomem_base;
        rs_table[i].iomem_reg_shift = req->iomem_reg_shift;
        rs_table[i].type = req->type;
        rs_table[i].xmit_fifo_size = req->xmit_fifo_size;
        rs_table[i].custom_divisor = req->custom_divisor;
        rs_table[i].closing_wait = req->closing_wait;
        return(0);
}
# 5634 "drivers/char/serial.c"
int register_serial(struct serial_struct *req)
{
        int i;
        unsigned long flags;
        struct serial_state *state;
        struct async_struct *info;
        unsigned long port;

        port = req->port;
        if (((sizeof(long)-sizeof(int))*8))
                port += (unsigned long) req->port_high << ((sizeof(long)-sizeof(int))*8);

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        for (i = 0; i < (sizeof(rs_table)/sizeof(struct serial_state)); i++) {
                if ((rs_table[i].port == port) &&
                    (rs_table[i].iomem_base == req->iomem_base))
                        break;
        }
# 5660 "drivers/char/serial.c"
        if (i == (sizeof(rs_table)/sizeof(struct serial_state))) {
                for (i = 0; i < (sizeof(rs_table)/sizeof(struct serial_state)); i++)
                        if ((rs_table[i].type == 0) &&
                            (rs_table[i].count == 0))
                                break;
        }
        if (i == (sizeof(rs_table)/sizeof(struct serial_state))) {
                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                return -1;
        }
        state = &rs_table[i];
        if (rs_table[i].count) {
                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                printk("Couldn't configure serial #%d (port=%ld,irq=%d): "
                       "device already open\n", i, port, req->irq);
                return -1;
        }
        state->irq = req->irq;
        state->port = port;
        state->flags = req->flags;
        state->io_type = req->io_type;
        state->iomem_base = req->iomem_base;
        state->iomem_reg_shift = req->iomem_reg_shift;
        if (req->baud_base)
                state->baud_base = req->baud_base;
        if ((info = state->info) != ((void *)0)) {
                info->port = port;
                info->flags = req->flags;
                info->io_type = req->io_type;
                info->iomem_base = req->iomem_base;
                info->iomem_reg_shift = req->iomem_reg_shift;
        }
        autoconfig(state);
        if (state->type == 0) {
                do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
                printk("register_serial(): autoconfig failed\n");
                return -1;
        }
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);

        if ((state->flags & 0x0080) && ((state)->port || ((state)->iomem_base)))
                state->irq = detect_uart_irq(state);

       printk("<6>" "ttyS%02d at %s 0x%04lx (irq = %d) is a %s\n",
              state->line + 0,
              state->iomem_base ? "iomem" : "port",
              state->iomem_base ? (unsigned long)state->iomem_base :
              state->port, state->irq, uart_config[state->type].name);
        tty_register_devfs(&serial_driver, 0,
                           serial_driver.minor_start + state->line);
        tty_register_devfs(&callout_driver, 0,
                           callout_driver.minor_start + state->line);
        return state->line + 0;
}
# 5724 "drivers/char/serial.c"
void unregister_serial(int line)
{
        unsigned long flags;
        struct serial_state *state = &rs_table[line];

        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        if (state->info && state->info->tty)
                tty_hangup(state->info->tty);
        state->type = 0;
        printk("<6>" "ttyS%02d unloaded\n", state->line);



        tty_unregister_devfs(&serial_driver,
                             serial_driver.minor_start + state->line);
        tty_unregister_devfs(&callout_driver,
                             callout_driver.minor_start + state->line);
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}

static void __attribute__((__unused__)) __attribute__ (( __section__(".text.exit"))) rs_fini(void)
{
        unsigned long flags;
        int e1, e2;
        int i;
        struct async_struct *info;


        del_timer(&serial_timer);
        __asm__ __volatile__( "__save_flags %0" : "=r" (flags)); __cli();
        remove_bh(SERIAL_BH);
        if ((e1 = tty_unregister_driver(&serial_driver)))
                printk("serial: failed to unregister serial driver (%d)\n",
                       e1);
        if ((e2 = tty_unregister_driver(&callout_driver)))
                printk("serial: failed to unregister callout driver (%d)\n",
                       e2);
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);

        for (i = 0; i < (sizeof(rs_table)/sizeof(struct serial_state)); i++) {
                if ((info = rs_table[i].info)) {
                        rs_table[i].info = ((void *)0);
                        kfree(info);
                }
                if ((rs_table[i].type != 0) && rs_table[i].port) {

                        if (rs_table[i].type == 13)
                                __release_region(&ioport_resource, (rs_table[i].port + (-8)), (16));

                        else

                                __release_region(&ioport_resource, (rs_table[i].port), (8));
                }

                if (rs_table[i].iomem_base)
                        iounmap(rs_table[i].iomem_base);

        }

        for (i=0; i < 8; i++) {
                struct pci_board_inst *brd = &serial_pci_board[i];

                if (serial_pci_board[i].dev == 0)
                        continue;
                if (brd->board.init_fn)
                        (brd->board.init_fn)(brd->dev, &brd->board, 0);
                if ((brd->dev->deactivate))
                        ((brd->dev->deactivate))(brd->dev);
        }

        if (tmp_buf) {
                unsigned long pg = (unsigned long) tmp_buf;
                tmp_buf = ((void *)0);
                free_pages((pg),0);
        }


        if (serial_pci_driver.name[0])
                pci_unregister_driver (&serial_pci_driver);

}

static initcall_t __initcall_rs_init __attribute__((__unused__)) __attribute__((__unused__)) __attribute__ ((__section__ (".initcall.init"))) = rs_init;;
static exitcall_t __exitcall_rs_fini __attribute__((__unused__)) __attribute__ ((__section__ (".exitcall.exit"))) = rs_fini;;
;
;
;
# 5820 "drivers/char/serial.c"
#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)

static struct async_struct async_sercons;




static __inline__ __attribute__((always_inline)) __attribute__((always_inline)) void wait_for_xmitr(struct async_struct *info)
{
        unsigned int status, tmout = 1000000;

        do {
                status = serial_in(info, 5);

                if (status & 0x10)
                        lsr_break_flag = 0x10;

                if (--tmout == 0)
                        break;
        } while((status & (0x40 | 0x20)) != (0x40 | 0x20));


        if (info->flags & 0x00800000) {
                tmout = 1000000;
                while (--tmout &&
                       ((serial_in(info, 6) & 0x10) == 0));
        }
}
# 5856 "drivers/char/serial.c"
static void serial_console_write(struct console *co, const char *s,
                                unsigned count)
{
        static struct async_struct *info = &async_sercons;
        int ier;
        unsigned i;




        ier = serial_in(info, 1);
        serial_out(info, 1, 0x00);




        for (i = 0; i < count; i++, s++) {
                wait_for_xmitr(info);





                serial_out(info, 0, *s);
                if (*s == 10) {
                        wait_for_xmitr(info);
                        serial_out(info, 0, 13);
                }
        }





        wait_for_xmitr(info);
        serial_out(info, 1, ier);
}

static kdev_t serial_console_device(struct console *c)
{
        return (((4) << 8) | (64 + c->index));
}







static int __attribute__ ((__section__ (".text.init"))) serial_console_setup(struct console *co, char *options)
{
        static struct async_struct *info;
        struct serial_state *state;
        unsigned cval;
        int baud = 9600;
        int bits = 8;
        int parity = 'n';
        int doflow = 0;
        int cflag = 0000200 | 0002000 | 0004000;
        int quot = 0;
        char *s;

        if (options) {
                baud = simple_strtoul(options, ((void *)0), 10);
                s = options;
                while(*s >= '0' && *s <= '9')
                        s++;
                if (*s) parity = *s++;
                if (*s) bits = *s++ - '0';
                if (*s) doflow = (*s++ == 'r');
        }




        switch(baud) {
                case 1200:
                        cflag |= 0000011;
                        break;
                case 2400:
                        cflag |= 0000013;
                        break;
                case 4800:
                        cflag |= 0000014;
                        break;
                case 19200:
                        cflag |= 0000016;
                        break;
                case 38400:
                        cflag |= 0000017;
                        break;
                case 57600:
                        cflag |= 0010001;
                        break;
                case 115200:
                        cflag |= 0010002;
                        break;
                case 9600:
                default:
                        cflag |= 0000015;



                        baud = 9600;
                        break;
        }
        switch(bits) {
                case 7:
                        cflag |= 0000040;
                        break;
                default:
                case 8:
                        cflag |= 0000060;
                        break;
        }
        switch(parity) {
                case 'o': case 'O':
                        cflag |= 0001000;
                        break;
                case 'e': case 'E':
                        cflag |= 0000400;
                        break;
        }
        co->cflag = cflag;




        state = rs_table + co->index;
        if (doflow)
                state->flags |= 0x00800000;
        info = &async_sercons;
        info->magic = 0x5301;
        info->state = state;
        info->port = state->port;
        info->flags = state->flags;



        info->io_type = state->io_type;
        info->iomem_base = state->iomem_base;
        info->iomem_reg_shift = state->iomem_reg_shift;
        quot = state->baud_base / baud;
        cval = cflag & (0000060 | 0000100);



        cval >>= 4;

        if (cflag & 0000400)
                cval |= 0x08;
        if (!(cflag & 0001000))
                cval |= 0x10;





        serial_out(info, 3, cval | 0x80);
        serial_out(info, 0, quot & 0xff);
        serial_out(info, 1, quot >> 8);
        serial_out(info, 3, cval);
        serial_out(info, 1, 0);
        serial_out(info, 4, 0x01 | 0x02);




        if (serial_in(info, 5) == 0xff)
                return -1;

        return 0;
}

static struct console sercons = {
        name: "ttyS",
        write: serial_console_write,
        device: serial_console_device,
        setup: serial_console_setup,
        flags: (1),
        index: -1,
};




void __attribute__ ((__section__ (".text.init"))) serial_console_init(void)
{
        register_console(&sercons);
}
